```javascript
/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

let buttonStore;
const getStore = (isMobile) => isMobile ? buttonStore : JSON.parse(localStorage.getItem("buttons"));
const initializeButtonStore = (app, storeEvents) => {
    const files = app.vault.getMarkdownFiles();
    const blocksArr = files
        .map((file) => {
        const cache = app.metadataCache.getFileCache(file);
        return buildButtonArray(cache, file);
    })
        .filter((arr) => arr !== undefined)
        .flat();
    localStorage.setItem("buttons", JSON.stringify(blocksArr));
    buttonStore = blocksArr;
    storeEvents.trigger('index-complete');
};
const addButtonToStore = (app, file) => {
    const cache = app.metadataCache.getFileCache(file);
    const buttons = buildButtonArray(cache, file);
    const store = getStore(app.isMobile);
    const newStore = buttons && store
        ? removeDuplicates([…buttons, …store])
        : store
            ? removeDuplicates(store)
            : buttons
                ? removeDuplicates(buttons)
                : [];
    localStorage.setItem("buttons", JSON.stringify(newStore));
    buttonStore = newStore;
};
const getButtonFromStore = async (app, args) => {
    const store = getStore(app.isMobile);
    args.id;
    if (args.id) {
        const storedButton = store &&
            store.filter((item) => `BUTTON[button-${args.id}]` === item.id)[0];
        if (storedButton) {
            const file = app.vault.getAbstractFileByPath(storedButton.path);
            const content = await app.vault.cachedRead(file);
            const contentArray = content.split("\n");
            const button = contentArray
                .slice(storedButton.position.start.line + 1, storedButton.position.end.line)
                .join("\n");
            const storedArgs = createArgumentObject(button);
            return {
                args: { …storedArgs, …args },
                id: storedButton.id.split("button-")[1],
            };
        }
    }
};
const getButtonById = async (app, id) => {
    const store = getStore(app.isMobile);
    const storedButton = store.filter((item) => `BUTTON[button-${id}]` === item.id)[0];
    if (storedButton) {
        const file = app.vault.getAbstractFileByPath(storedButton.path);
        const content = await app.vault.cachedRead(file);
        const contentArray = content.split("\n");
        const button = contentArray
            .slice(storedButton.position.start.line + 1, storedButton.position.end.line)
            .join("\n");
        return createArgumentObject(button);
    }
};
const getButtonSwapById = async (app, id) => {
    const store = getStore(app.isMobile);
    const storedButton = store.filter((item) => `BUTTON[button-${id}]` === item.id)[0];
    if (storedButton) {
        return storedButton.swap;
    }
};
const setButtonSwapById = async (app, id, newSwap) => {
    const store = getStore(app.isMobile);
    const storedButton = store.filter((item) => `BUTTON[button-${id}]` === item.id)[0];
    if (storedButton) {
        storedButton.swap = newSwap;
        const newStore = removeDuplicates([…store, storedButton]);
        localStorage.setItem("buttons", JSON.stringify(newStore));
        buttonStore = newStore;
    }
};
const buildButtonArray = (cache, file) => {
    const blocks = cache && cache.blocks;
    if (blocks) {
        const blockKeys = Array.from(Object.keys(blocks));
        const blockArray = blockKeys
            .map((key) => blocks[key])
            .map((obj) => {
            obj["path"] = file.path;
            obj["swap"] = 0;
            return obj;
        })
            .filter((block) => block.id.includes("button"));
        return blockArray;
    }
};
function removeDuplicates(arr) {
    return arr && arr[0]
        ? arr.filter((v, i, a) => a.findIndex((t) => t.id === v.id ||
            (t.path === v.path &&
                t.position.start.line === v.position.start.line &&
                t.position.end.line === v.position.end.line)) === i)
        : arr;
}

function nanoid(num) {
    let result = "";
    const characters = "abcdefghijklmnopqrstuvwxyz0123456789";
    const charactersLength = characters.length;
    for (let i = 0; i < num; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
}
const insertButton = (app, outputObject) => {
    const buttonArr = [];
    buttonArr.push("```button");
    outputObject.name && buttonArr.push(`name ${outputObject.name}`);
    outputObject.type && buttonArr.push(`type ${outputObject.type}`);
    outputObject.action && buttonArr.push(`action ${outputObject.action}`);
    outputObject.id && buttonArr.push(`id ${outputObject.id}`);
    outputObject.swap && buttonArr.push(`swap ${outputObject.swap}`);
    outputObject.remove && buttonArr.push(`remove ${outputObject.remove}`);
    outputObject.replace && buttonArr.push(`replace ${outputObject.replace}`);
    outputObject.templater === true &&
        buttonArr.push(`templater ${outputObject.templater}`);
    outputObject.color && buttonArr.push(`color ${outputObject.color}`);
    outputObject.class && buttonArr.push(`class ${outputObject.class}`);
    buttonArr.push("```");
    outputObject.blockId
        ? buttonArr.push(`^button-${outputObject.blockId}`)
        : buttonArr.push(`^button-${nanoid(4)}`);
    const page = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    const editor = page.editor;
    editor.replaceSelection(buttonArr.join("\n"));
    addButtonToStore(app, page.file);
};
const insertInlineButton = (app, id) => {
    const page = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    const editor = page.editor;
    editor.replaceSelection(`\`BUTTON[button-${id}\]``);
};
const createArgumentObject = (source) => source.split("\n").reduce((acc, i) => {
    const split = i.split(" ");
    const key = split[0].toLowerCase();
    acc[key] = split.filter((item) => item !== split[0]).join(" ").trim();
    return acc;
}, {});

const createContentArray = async (app) => {
    const activeView = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    if (activeView) {
        const file = activeView.file;
        const content = await app.vault.read(file);
        return { contentArray: content.split("\n"), file };
    }
    new obsidian.Notice("Could not get Active View", 1000);
    console.error("could not get active view");
};
const handleValueArray = (value, callback) => {
    if (value.includes("[") && value.includes("]")) {
        const args = value.match(/\[(.*)\]/);
        if (args[1]) {
            const argArray = args[1].split(/,\s?/);
            if (argArray[0]) {
                callback(argArray);
            }
        }
    }
};
function getNewArgs(app, position) {
    const promise = new Promise((resolve) => {
        setTimeout(async () => {
            const activeView = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
            const newContent = await app.vault
                .cachedRead(activeView.file)
                .then((content) => content.split("\n"));
            const newButton = newContent
                .splice(position.lineStart, position.lineEnd - position.lineStart)
                .join("\n")
                .replace("```button", "")
                .replace("```", "");
            resolve({ args: createArgumentObject(newButton) });
        }, 150);
    });
    return promise;
}
const wrapAround = (value, size) => {
    return ((value % size) + size) % size;
};

const buttonEventListener = (app, callback) => {
    return app.metadataCache.on("changed", (file) => {
        callback(app, file);
    });
};
const openFileListener = (app, storeEvents, callback) => {
    return app.workspace.on("file-open", () => {
        callback(app, storeEvents);
    });
};

const removeButton = async (app, remove, lineStart, lineEnd) => {
    const { contentArray, file } = await createContentArray(app);
    const store = getStore(app.isMobile);
    if (remove === "true") {
        const numberOfItems = lineEnd - lineStart;
        contentArray.splice(lineStart, numberOfItems + 1);
        if (contentArray[lineStart] &&
            contentArray[lineStart].includes("^button-")) {
            contentArray.splice(lineStart, 1);
        }
        const content = contentArray.join("\n");
        await app.vault.modify(file, content);
    }
    if (lineStart === lineEnd) {
        contentArray.splice(lineStart, 1);
        const content = contentArray.join("\n");
        await app.vault.modify(file, content);
    }
    else {
        handleValueArray(remove, async (argArray) => {
            const buttons = store &&
                store.filter((item) => {
                    let exists;
                    argArray.forEach((arg) => {
                        if (item.id === `BUTTON[button-${arg}]` && item.path === file.path) {
                            exists = true;
                        }
                    });
                    return exists;
                });
            if (buttons[0]) {
                let offset = 0;
                buttons.forEach((button) => {
                    const start = button.position.start.line - offset;
                    const numLines = button.position.end.line - button.position.start.line;
                    contentArray.splice(start, numLines + 2);
                    offset += numLines + 2;
                });
                const content = contentArray.join("\n");
                await app.vault.modify(file, content);
            }
        });
    }
};

const removeSection = async (app, section) => {
    const { contentArray, file } = await createContentArray(app);
    if (section.includes("[") && section.includes("]")) {
        const args = section.match(/\[(.*)\]/);
        if (args[1]) {
            const argArray = args[1].split(/,\s?/);
            if (argArray[0]) {
                const start = parseInt(argArray[0]) - 1;
                const end = parseInt(argArray[1]);
                const numLines = end - start;
                contentArray.splice(start, numLines);
                const content = contentArray.join("\n");
                await app.vault.modify(file, content);
            }
        }
    }
};

const prependContent = async (app, insert, lineStart) => {
    const activeView = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    if (activeView) {
        const file = activeView.file;
        let content = await app.vault.read(file);
        const contentArray = content.split("\n");
        contentArray.splice(lineStart, 0, insert);
        content = contentArray.join("\n");
        await app.vault.modify(file, content);
    }
    else {
        new obsidian.Notice("There was an issue prepending content, please try again", 2000);
    }
};

const appendContent = async (app, insert, lineEnd) => {
    const activeView = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    if (activeView) {
        const file = activeView.file;
        let content = await app.vault.read(file);
        const contentArray = content.split("\n");
        let insertionPoint;
        if (contentArray[lineEnd + 1] &&
            contentArray[lineEnd + 1].includes("^button")) {
            insertionPoint = lineEnd + 2;
            insert = `\n${insert}`;
        }
        else {
            insertionPoint = lineEnd + 1;
        }
        contentArray.splice(insertionPoint, 0, `${insert}`);
        content = contentArray.join("\n");
        await app.vault.modify(file, content);
    }
    else {
        new obsidian.Notice("There was an issue appending content, please try again", 2000);
    }
};

const addContentAtLine = async (app, insert, type) => {
    const lineNumber = type.match(/(\d+)/g);
    if (lineNumber[0]) {
        const insertionPoint = parseInt(lineNumber[0]) - 1;
        const activeView = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
        if (activeView) {
            const file = activeView.file;
            let content = await app.vault.read(file);
            const contentArray = content.split("\n");
            contentArray.splice(insertionPoint, 0, `${insert}`);
            content = contentArray.join("\n");
            await app.vault.modify(file, content);
        }
    }
    else {
        new obsidian.Notice("There was an issue adding content, please try again", 2000);
    }
};

```