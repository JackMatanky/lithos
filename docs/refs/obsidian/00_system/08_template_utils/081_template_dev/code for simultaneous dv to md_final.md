```javascript
/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

/*
RegEx for finding DataView Tables: (```dataview)([\s\S])*?(```)
*/

'use strict';

var obsidian = require('obsidian');

function removeDuplicates(arr) {
    return arr && arr[0]
        ? arr.filter((v, i, a) => a.findIndex((t) => t.id === v.id ||
            (t.path === v.path &&
                t.position.start.line === v.position.start.line &&
                t.position.end.line === v.position.end.line)) === i)
        : arr;
}

function nanoid(num) {
    let result = "";
    const characters = "abcdefghijklmnopqrstuvwxyz0123456789";
    const charactersLength = characters.length;
    for (let i = 0; i < num; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
}



const createArgumentObject = (source) => source.split("\n").reduce((acc, i) => {
    const split = i.split(" ");
    const key = split[0].toLowerCase();
    acc[key] = split.filter((item) => item !== split[0]).join(" ").trim();
    return acc;
}, {});

const createContentArray = async (app) => {
    const activeView = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    if (activeView) {
        const file = activeView.file;
        const content = await app.vault.read(file);
        return { contentArray: content.split("\n"), file };
    }
    new obsidian.Notice("Could not get Active View", 1000);
    console.error("could not get active view");
};

const handleValueArray = (value, callback) => {
    if (value.includes("[") && value.includes("]")) {
        const args = value.match(/\[(.*)\]/);
        if (args[1]) {
            const argArray = args[1].split(/,\s?/);
            if (argArray[0]) {
                callback(argArray);
            }
        }
    }
};

function getNewArgs(app, position) {
    const promise = new Promise((resolve) => {
        setTimeout(async () => {
            const activeView = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
            const newContent = await app.vault
                .cachedRead(activeView.file)
                .then((content) => content.split("\n"));
            const newButton = newContent
                .splice(position.lineStart, position.lineEnd - position.lineStart)
                .join("\n")
                .replace("```button", "")
                .replace("```", "");
            resolve({ args: createArgumentObject(newButton) });
        }, 150);
    });
    return promise;
}

const wrapAround = (value, size) => {
    return ((value % size) + size) % size;
};

const buttonEventListener = (app, callback) => {
    return app.metadataCache.on("changed", (file) => {
        callback(app, file);
    });
};

const openFileListener = (app, storeEvents, callback) => {
    return app.workspace.on("file-open", () => {
        callback(app, storeEvents);
    });
};

const removeButton = async (app, remove, lineStart, lineEnd) => {
    const { contentArray, file } = await createContentArray(app);
    const store = getStore(app.isMobile);
    if (remove === "true") {
        const numberOfItems = lineEnd - lineStart;
        contentArray.splice(lineStart, numberOfItems + 1);
        if (contentArray[lineStart] &&
            contentArray[lineStart].includes("^button-")) {
            contentArray.splice(lineStart, 1);
        }
        const content = contentArray.join("\n");
        await app.vault.modify(file, content);
    }
    if (lineStart === lineEnd) {
        contentArray.splice(lineStart, 1);
        const content = contentArray.join("\n");
        await app.vault.modify(file, content);
    }
    else {
        handleValueArray(remove, async (argArray) => {
            const buttons = store &&
                store.filter((item) => {
                    let exists;
                    argArray.forEach((arg) => {
                        if (item.id === `BUTTON[button-${arg}]` && item.path === file.path) {
                            exists = true;
                        }
                    });
                    return exists;
                });
            if (buttons[0]) {
                let offset = 0;
                buttons.forEach((button) => {
                    const start = button.position.start.line - offset;
                    const numLines = button.position.end.line - button.position.start.line;
                    contentArray.splice(start, numLines + 2);
                    offset += numLines + 2;
                });
                const content = contentArray.join("\n");
                await app.vault.modify(file, content);
            }
        });
    }
};

const removeSection = async (app, section) => {
    const { contentArray, file } = await createContentArray(app);
    if (section.includes("[") && section.includes("]")) {
        const args = section.match(/\[(.*)\]/);
        if (args[1]) {
            const argArray = args[1].split(/,\s?/);
            if (argArray[0]) {
                const start = parseInt(argArray[0]) - 1;
                const end = parseInt(argArray[1]);
                const numLines = end - start;
                contentArray.splice(start, numLines);
                const content = contentArray.join("\n");
                await app.vault.modify(file, content);
            }
        }
    }
};

const prependContent = async (app, insert, lineStart) => {
    const activeView = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    if (activeView) {
        const file = activeView.file;
        let content = await app.vault.read(file);
        const contentArray = content.split("\n");
        contentArray.splice(lineStart, 0, insert);
        content = contentArray.join("\n");
        await app.vault.modify(file, content);
    }
    else {
        new obsidian.Notice("There was an issue prepending content, please try again", 2000);
    }
};

const appendContent = async (app, insert, lineEnd) => {
    const activeView = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    if (activeView) {
        const file = activeView.file;
        let content = await app.vault.read(file);
        const contentArray = content.split("\n");
        let insertionPoint;
        if (contentArray[lineEnd + 1] &&
            contentArray[lineEnd + 1].includes("^button")) {
            insertionPoint = lineEnd + 2;
            insert = `\n${insert}`;
        }
        else {
            insertionPoint = lineEnd + 1;
        }
        contentArray.splice(insertionPoint, 0, `${insert}`);
        content = contentArray.join("\n");
        await app.vault.modify(file, content);
    }
    else {
        new obsidian.Notice("There was an issue appending content, please try again", 2000);
    }
};

const addContentAtLine = async (app, insert, type) => {
    const lineNumber = type.match(/(\d+)/g);
    if (lineNumber[0]) {
        const insertionPoint = parseInt(lineNumber[0]) - 1;
        const activeView = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
        if (activeView) {
            const file = activeView.file;
            let content = await app.vault.read(file);
            const contentArray = content.split("\n");
            contentArray.splice(insertionPoint, 0, `${insert}`);
            content = contentArray.join("\n");
            await app.vault.modify(file, content);
        }
    }
    else {
        new obsidian.Notice("There was an issue adding content, please try again", 2000);
    }
};

```