# Story 2.1: Config Domain Model

## Status

In Progress

## Story

**As a** developer,
**I want** the Config domain model to represent application configuration as an immutable value object,
**so that** configuration is loaded once at startup and provides validated vault structure references.

## Acceptance Criteria

**Config Model Structure:**

- 2.1.1: Create `internal/domain/config.go` with Config struct containing exactly these attributes from `docs/architecture/data-models.md#config`:
  - `VaultPath` (string) - Root directory of vault
  - `TemplatesDir` (string) - Path to templates directory
  - `SchemasDir` (string) - Path to schemas directory
  - `PropertyBankFile` (string) - Filename of property bank file within SchemasDir
  - `CacheDir` (string) - Path to index cache directory
  - `LogLevel` (string) - Logging verbosity ("debug", "info", "warn", "error")

- 2.1.2: Add JSON struct tags matching snake_case field names (e.g., `json:"vault_path"`)

- 2.1.3: Implement `NewConfig()` constructor that applies sensible defaults:
  - VaultPath: current working directory if not specified
  - TemplatesDir: `{VaultPath}/templates/` if not specified
  - SchemasDir: `{VaultPath}/schemas/` if not specified
  - PropertyBankFile: `property_bank.json` if not specified
  - CacheDir: `{VaultPath}/.lithos/cache/` if not specified
  - LogLevel: `info` if not specified

- 2.1.4: Implement helper method `PropertyBankPath() string` that returns full path: `filepath.Join(config.SchemasDir, config.PropertyBankFile)`

**Value Object Semantics:**

- 2.1.5: Config is immutable - all fields are read-only after construction (no setter methods)

- 2.1.6: Add GoDoc comments referencing `docs/architecture/data-models.md#config` and explaining value object semantics

**Unit Tests:**

- 2.1.7: Create `internal/domain/config_test.go` with tests covering:
  - Constructor with default values
  - Constructor with partial configuration (some defaults, some provided)
  - Constructor with full configuration
  - PropertyBankPath() returns correct joined path
  - JSON marshaling/unmarshaling round-trip

- 2.1.8: Run `golangci-lint run ./internal/domain` and verify zero errors or warnings

- 2.1.9: Run `go test ./internal/domain -v` and verify all tests pass

**Documentation:**

- 2.1.10: Document that Config is loaded by ConfigPort adapter (Epic 3) - domain model only defines structure

- 2.1.11: Committed with message: `feat(domain): add Config value object model`

## Tasks / Subtasks

- [ ] Task 1: Implement Config struct (AC: 2.1.1-2.1.4)
  - [ ] RED: Write failing test for NewConfig with defaults
    - [ ] Write test case in `internal/domain/config_test.go`
    - [ ] Verify test fails with expected error message
    - [ ] Run `go test ./internal/domain` and confirm failure
  - [ ] RED: Write failing test for NewConfig with partial config
    - [ ] Write test case with some fields provided, some defaulted
    - [ ] Run `go test ./internal/domain` and confirm failure
  - [ ] RED: Write failing test for PropertyBankPath() helper
    - [ ] Write test verifying path join behavior
    - [ ] Run `go test ./internal/domain` and confirm failure
  - [ ] GREEN: Implement minimal code to pass tests
    - [ ] Create `internal/domain/config.go`
    - [ ] Implement Config struct with six fields and JSON tags
    - [ ] Implement NewConfig() with default logic
    - [ ] Implement PropertyBankPath() helper
    - [ ] Run `go test ./internal/domain` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify Config struct has single responsibility (hold configuration data)
      - [ ] Verify NewConfig has single responsibility (create Config with defaults)
      - [ ] Verify PropertyBankPath has single responsibility (compute full path)
      - [ ] If NewConfig >20 lines, extract applyDefaults() helper
    - [ ] Review naming: Config (clear), NewConfig (idiomatic), PropertyBankPath (descriptive)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for Config struct explaining value object semantics
      - [ ] Add GoDoc for each field explaining purpose
      - [ ] Add GoDoc for NewConfig explaining defaults
      - [ ] Add GoDoc for PropertyBankPath explaining path construction
    - [ ] Run `golangci-lint run --fix internal/domain`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/domain` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for Config
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/domain`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 2: Enforce value object semantics (AC: 2.1.5-2.1.6)
  - [ ] RED: Write test verifying immutability (no setters exist)
    - [ ] Use reflection or type checks to verify no setter methods
    - [ ] Run `go test ./internal/domain` and confirm test passes (no setters to find)
  - [ ] Verify documentation explains immutability
  - [ ] Reference architecture docs in comments
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/domain`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)

- [ ] Task 3: Write comprehensive unit tests (AC: 2.1.7-2.1.9)
  - [ ] RED: Write failing test for JSON marshaling round-trip
    - [ ] Write test marshaling Config to JSON and back
    - [ ] Verify round-trip preserves data
    - [ ] Run `go test ./internal/domain` and confirm failure
  - [ ] GREEN: Ensure JSON tags support marshaling
    - [ ] Verify JSON tags on all fields
    - [ ] Run `go test ./internal/domain` and verify test passes
  - [ ] Run golangci-lint and fix any issues
  - [ ] Run tests and verify all pass
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/domain`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)

- [ ] Task 4: Quality gates and commit (AC: 2.1.10-2.1.11)
  - [ ] Run `go test ./internal/domain` and verify 100% pass
  - [ ] Run `golangci-lint run --fix internal/domain` and fix any issues
  - [ ] Verify test coverage is adequate (>90% for domain models)
  - [ ] Add documentation about ConfigPort loading
  - [ ] Review all GoDoc comments
  - [ ] Commit with message: `feat(domain): add Config value object model`
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/domain`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)

## Dev Notes

### Architecture References

From `docs/architecture/data-models.md#config`:

**Value Object Semantics:**

- Config is a DDD value object - immutable configuration data identified by its attributes
- Two Config instances with identical values are equivalent
- Loaded once at startup by ConfigPort adapter, never modified
- All fields are strings for serialization simplicity

**Default Value Strategy:**

- Empty config file is valid - all paths default to sensible vault-relative locations
- Enables quickstart: user can run commands with zero configuration if using standard directory structure
- Paths stored as strings, not file handles - adapters resolve paths on demand

**PropertyBankFile Design:**

- PropertyBankFile is filename only, not full path
- Always located in SchemasDir
- SchemaLoader constructs full path: `filepath.Join(config.SchemasDir, config.PropertyBankFile)`

**Validation Strategy:**

- ConfigLoader adapter validates VaultPath exists, is directory, and is readable
- Other paths validated lazily when accessed (TemplatesDir validated on first use, not at config load)
- Invalid LogLevel falls back to "info" with warning

### Implementation Guidance

**Constructor Pattern:**

```go
func NewConfig(
    vaultPath, templatesDir, schemasDir, propertyBankFile, cacheDir, logLevel string,
) Config {
    // Apply defaults for empty values
    if vaultPath == "" {
        vaultPath = "." // CWD
    }
    if templatesDir == "" {
        templatesDir = filepath.Join(vaultPath, "templates")
    }
    // ... similar for other fields

    return Config{
        VaultPath:        vaultPath,
        TemplatesDir:     templatesDir,
        SchemasDir:       schemasDir,
        PropertyBankFile: propertyBankFile,
        CacheDir:         cacheDir,
        LogLevel:         logLevel,
    }
}
```

**Helper Method Pattern:**

```go
// PropertyBankPath returns the full path to the property bank file
// by joining SchemasDir with PropertyBankFile.
func (c Config) PropertyBankPath() string {
    return filepath.Join(c.SchemasDir, c.PropertyBankFile)
}
```

### Testing Strategy

From `docs/architecture/testing-strategy.md`:

**Unit Test Coverage:**

- Constructor with all defaults
- Constructor with mix of provided/default values
- PropertyBankPath() returns correct joined path
- JSON round-trip preserves all fields
- Value equality comparison (two configs with same values are equivalent)

**No External Dependencies:**

- Config is pure domain model with no infrastructure dependencies
- Tests use only Go stdlib (no mocks needed)

### Refactoring Guidelines

**SRP Decomposition Examples:**

For this story, Config is intentionally simple (following value object pattern). SRP decomposition focuses on:

**Config:**

- Struct: Single responsibility = hold configuration data
- NewConfig constructor: Single responsibility = create Config with sensible defaults
  - If constructor grows >20 lines with complex default logic, extract `applyDefaults(cfg *Config)` helper
- PropertyBankPath helper: Single responsibility = compute full path to property bank file

**When to Decompose:**

- If NewConfig has >20 lines of default application logic, extract applyDefaults() helper
- If path construction becomes complex (>3 joins), extract helper methods
- If validation logic added, extract validateConfig() method (though Config itself stays immutable)

**Naming Standards:**

- Exported types: PascalCase (Config)
- Constructors: NewTypeName (NewConfig)
- Helper methods: descriptive action names (PropertyBankPath, not GetPath)
- Private helpers (if added): camelCase, specific action (applyDefaults, not defaults)

**Documentation Requirements:**

- Package comment at top of config.go explaining domain models
- Config struct has GoDoc explaining value object semantics and immutability
- All fields have inline comments explaining purpose
- NewConfig has GoDoc explaining default values
- PropertyBankPath has GoDoc explaining path construction

### Related Components

From `docs/architecture/components.md`:

**ConfigPort (Epic 3):**

- Loads Config from `lithos.json`, environment variables, CLI flags
- Precedence: CLI flags > env vars > config file > defaults
- Searches upward from CWD for `lithos.json`
- Implemented by ViperAdapter

**Consumers:**

- SchemaLoaderAdapter uses Config.SchemasDir and Config.PropertyBankPath()
- TemplateLoaderAdapter uses Config.TemplatesDir
- CacheAdapters use Config.CacheDir
- Logger uses Config.LogLevel

## Change Log

| Date       | Version | Description                                                              | Author             |
| ---------- | ------- | ------------------------------------------------------------------------ | ------------------ |
| 2025-10-28 | 1.0     | Story created from Epic 2 requirements                                   | Bob (Scrum Master) |
| 2025-10-28 | 1.1     | Enhanced with full TDD framework, SRP decomposition, linting checkpoints | QA Specialist      |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## Testing

**Test Design:** `docs/qa/assessments/2.1-test-design-20251029.md`

**Test Strategy Summary:**

- 12 unit tests (100% unit test coverage)
- 0 integration tests (no component interactions)
- 0 E2E tests (not user-facing)
- Priority: 10 P0 tests, 2 P1 tests
- Focus: Constructor defaults, helper methods, immutability, JSON serialization

## QA Results

**Test Design Completed:** 2025-10-29 by Quinn (Test Architect)

**Quality Assessment:** ✅ READY FOR IMPLEMENTATION

**Test Coverage Analysis:**

- Comprehensive test design covers all 11 acceptance criteria
- 12 focused unit test scenarios designed
- All critical paths have P0 test coverage
- Risk mitigation tests included for config integrity

**Reference:** See `docs/qa/assessments/2.1-test-design-20251029.md` for complete test scenarios

_Implementation validation to be completed by QA agent after development_
