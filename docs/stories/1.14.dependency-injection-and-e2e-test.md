# Story 1.14: Wire Dependency Injection and Create End-to-End Test

## Status

Draft

## Story

**As a** developer,
**I want** to wire all components in main.go using constructor-based dependency injection and create end-to-end test,
**so that** the complete application works from CLI invocation to file creation with proper initialization order.

## Acceptance Criteria

**Dependency Injection in main.go:**

- 1.14.1: Implement main() function in `cmd/lithos/main.go`:
  - Create context: `ctx := context.Background()`
  - Follow initialization order per architecture v0.6.5 (documented below)

- 1.14.2: Infrastructure layer initialization (Layer 1):
  - Create logger: `log := logger.New(os.Stdout, "info")` (default level)
  - Create config adapter: `configAdapter := config.NewViperAdapter(log)`
  - Load config: `cfg, err := configAdapter.Load(ctx)` - **fatal error if fails**
  - Update logger level from config: `log = logger.New(os.Stdout, cfg.LogLevel)`

- 1.14.3: SPI adapter initialization (Layer 2):
  - Create TemplateLoaderAdapter: `templateLoader := template.NewTemplateLoaderAdapter(cfg, log)`

- 1.14.4: Domain service initialization (Layer 3):
  - Create TemplateEngine: `templateEngine := app.NewTemplateEngine(templateLoader, cfg, log)`

- 1.14.5: API adapter initialization (Layer 4):
  - Create CobraCLIAdapter: `cliAdapter := cli.NewCobraCLIAdapter(log)`

- 1.14.6: CommandOrchestrator initialization (Layer 5):
  - Create CommandOrchestrator: `orchestrator := app.NewCommandOrchestrator(cliAdapter, templateEngine, cfg, log)`

- 1.14.7: Start application:
  - Call `err := orchestrator.Run(ctx)`
  - If error, log fatal and exit with code 1: `log.Fatal().Err(err).Msg("application failed")`

- 1.14.8: Error handling:
  - Config load failure → `log.Fatal().Err(err).Msg("failed to load configuration")`
  - Application failure → `log.Fatal().Err(err).Msg("application failed")`

**End-to-End Test:**

- 1.14.9: Create `tests/e2e/lithos_new_test.go`:
  - Test scenario: Full application flow from CLI to file creation
  - Setup:
    - Create temporary vault directory using `os.MkdirTemp`
    - Create templates/ subdirectory
    - Copy template from testdata/templates/static-template.md to temp vault
    - Set environment variable LITHOS_VAULT_PATH to temp directory
  - Execute:
    - Build lithos binary: `go build -o {tempDir}/lithos cmd/lithos/main.go`
    - Run command: `{tempDir}/lithos new static-template`
  - Verify:
    - Check file exists: `{tempDir}/static-template.md`
    - Read file content
    - Compare to expected output (verify template functions executed)
  - Cleanup:
    - Remove temporary directory

- 1.14.10: Additional test scenarios in same file:
  - Test: `lithos new basic-note` creates note with basic functions (now, toLower, toUpper)
  - Test: Error when template not found (returns exit code 1)
  - Test: `lithos version` prints version string

**Manual Testing:**

- 1.14.11: Manual test checklist (documented in story, not automated):
  - Build: `go build -o bin/lithos cmd/lithos/main.go`
  - Run: `./bin/lithos version` → prints "lithos v0.1.0"
  - Run: `./bin/lithos new static-template` (with testdata as vault) → creates note
  - Verify: File exists at expected location with rendered content
  - Run: `./bin/lithos new static-template --view` → displays content after creation
  - Run: `./bin/lithos new nonexistent` → shows error "Template 'nonexistent' not found"
  - Verify: Template functions work (now() shows current date, path functions work)
  - Verify: Config loads from lithos.json if present
  - Verify: Environment variables override config (test with LITHOS_LOG_LEVEL=debug)
  - Verify: Error messages are user-friendly (not stack traces)

- 1.14.12: All tests pass: `go test ./...` (all packages)

- 1.14.13: All linting passes: `golangci-lint run` (all code)

- 1.14.14: Committed with message: `feat: wire dependency injection in main.go and add e2e test`

## Tasks / Subtasks

- [ ] Task 1: Implement main.go Layer 1 (AC: 1.14.1-1.14.2)
  - [ ] Create cmd/lithos/main.go
  - [ ] Initialize logger with default level
  - [ ] Create and load config adapter
  - [ ] Update logger from config
  - [ ] Add fatal error handling

- [ ] Task 2: Implement main.go Layers 2-5 (AC: 1.14.3-1.14.6)
  - [ ] Create TemplateLoaderAdapter
  - [ ] Create TemplateEngine
  - [ ] Create CobraCLIAdapter
  - [ ] Create CommandOrchestrator
  - [ ] Wire all dependencies via constructors

- [ ] Task 3: Implement application startup (AC: 1.14.7-1.14.8)
  - [ ] Call orchestrator.Run()
  - [ ] Add error handling and logging
  - [ ] Verify application compiles and runs

- [ ] Task 4: Create e2e test infrastructure (AC: 1.14.9)
  - [ ] Create tests/e2e/lithos_new_test.go
  - [ ] Implement temp directory setup
  - [ ] Implement template copying
  - [ ] Implement environment variable configuration
  - [ ] Implement binary build step
  - [ ] Implement command execution
  - [ ] Implement result verification
  - [ ] Implement cleanup

- [ ] Task 5: Add additional e2e test scenarios (AC: 1.14.10)
  - [ ] Test: basic-note creation
  - [ ] Test: template not found error
  - [ ] Test: version command
  - [ ] Verify all scenarios pass

- [ ] Task 6: Manual testing (AC: 1.14.11)
  - [ ] Complete all manual test checklist items
  - [ ] Document any issues found
  - [ ] Verify all checklist items pass

- [ ] Task 7: Run quality gates (AC: 1.14.12-1.14.13)
  - [ ] Run full test suite: `go test ./...`
  - [ ] Run linting: `golangci-lint run`
  - [ ] Fix any issues

- [ ] Task 8: Commit changes (AC: 1.14.14)
  - [ ] Review all changes
  - [ ] Commit with proper message

## Dev Notes

### Architecture Alignment (v0.6.8)

From `docs/architecture/components.md#dependency-injection-pattern` (v0.6.5):

**Initialization Order:**

Dependencies are constructed in a specific order to satisfy the dependency graph:

**1. Infrastructure Layer (bottom-up):**
- Logger (zero dependencies)
- Config via ViperAdapter (depends on Logger)

**2. SPI Adapters (driven):**
- TemplateLoaderAdapter (depends on Config, Logger)

**3. Domain Services (core):**
- TemplateEngine (depends on TemplatePort, Config, Logger)

**4. API Adapters (driving):**
- CobraCLIAdapter (depends on Logger)

**5. CommandOrchestrator (application service):**
- CommandOrchestrator (depends on CLIPort, TemplateEngine, Config, Logger)

**Example main.go Structure:**

```go
func main() {
    ctx := context.Background()

    // 1. Infrastructure Layer
    log := logger.New(os.Stdout, "info")

    configAdapter := viper.NewAdapter(log)
    cfg, err := configAdapter.Load(ctx)
    if err != nil {
        log.Fatal().Err(err).Msg("failed to load configuration")
    }

    // Update logger from config
    log = logger.New(os.Stdout, cfg.LogLevel)

    // 2. SPI Adapters
    templateLoader := template.NewTemplateLoaderAdapter(cfg, log)

    // 3. Domain Services
    templateEngine := app.NewTemplateEngine(templateLoader, cfg, log)

    // 4. API Adapter
    cliAdapter := cli.NewCobraCLIAdapter(log)

    // 5. CommandOrchestrator
    orchestrator := app.NewCommandOrchestrator(
        cliAdapter,
        templateEngine,
        cfg,
        log,
    )

    // Start the application
    if err := orchestrator.Run(ctx); err != nil {
        log.Fatal().Err(err).Msg("application failed")
    }
}
```

**Design Principles:**
- **No DI Framework:** Pure Go constructors are sufficient for MVP scope
- **Explicit Dependencies:** All dependencies visible in constructor signatures
- **Fail Fast:** Infrastructure errors (config, schema loading) terminate at startup
- **Single Instantiation:** Each component instantiated once, passed by reference
- **Constructor Injection:** All dependencies provided via `New*()` functions
- **Interface Types:** Services depend on port interfaces, not concrete adapters

### End-to-End Testing

From `docs/architecture/testing-strategy.md`:

**E2E Test Organization:**
- Tests in `tests/e2e/` directory
- Build actual binary from cmd/lithos/main.go
- Execute as subprocess with real filesystem
- Verify complete user workflow end-to-end

**Test Pattern:**

```go
func TestLithosNew_StaticTemplate(t *testing.T) {
    // Setup: Create temp vault
    tempDir, err := os.MkdirTemp("", "lithos-e2e-*")
    require.NoError(t, err)
    defer os.RemoveAll(tempDir)

    templatesDir := filepath.Join(tempDir, "templates")
    require.NoError(t, os.MkdirAll(templatesDir, 0755))

    // Copy test template
    srcTemplate := filepath.Join("testdata", "templates", "static-template.md")
    dstTemplate := filepath.Join(templatesDir, "static-template.md")
    copyFile(t, srcTemplate, dstTemplate)

    // Build binary
    binaryPath := filepath.Join(tempDir, "lithos")
    cmd := exec.Command("go", "build", "-o", binaryPath, "../../cmd/lithos")
    require.NoError(t, cmd.Run())

    // Execute: lithos new static-template
    cmd = exec.Command(binaryPath, "new", "static-template")
    cmd.Env = append(os.Environ(), fmt.Sprintf("LITHOS_VAULT_PATH=%s", tempDir))
    output, err := cmd.CombinedOutput()
    require.NoError(t, err, "command output: %s", output)

    // Verify: File exists
    notePath := filepath.Join(tempDir, "static-template.md")
    require.FileExists(t, notePath)

    // Verify: Content matches expected
    content, err := os.ReadFile(notePath)
    require.NoError(t, err)

    // Verify template functions executed
    assert.Contains(t, string(content), time.Now().Format("2006-01-02"))
}
```

**Prerequisites:** Story 1.13 (CommandOrchestrator)

**Time Estimate:** 4 hours

**Architecture References:**
- Components: `docs/architecture/components.md#dependency-injection-pattern`
- Testing: `docs/architecture/testing-strategy.md`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 1 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
