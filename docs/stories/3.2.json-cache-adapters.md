# Story 3.2: Implement JSON Cache Adapters (JSONCacheWriteAdapter and JSONCacheReadAdapter)

## Status

Draft

## Story

**As a** developer,
**I want** filesystem adapters that satisfy the cache ports,
**so that** the indexer can persist notes and the query layer can read them.

## Acceptance Criteria

**JSONCacheWriteAdapter Implementation:**

- 3.2.1: Create `internal/adapters/spi/cache/json_writer.go` with JSONCacheWriteAdapter:
  - Implements CacheWriterPort interface
  - Constructor: `NewJSONCacheWriter(config Config, log Logger) *JSONCacheWriteAdapter`
  - Uses `encoding/json` for serialization
  - Uses `moby/sys/atomicwriter.WriteFile` for atomic writes (temp + rename)
  - One JSON file per note: `{Config.CacheDir}/{NoteID}.json`

- 3.2.2: Implement Persist method:
  - Create cache directory if missing using `os.MkdirAll`
  - Serialize Note to JSON with `json.Marshal`
  - Write atomically using `atomicwriter.WriteFile`
  - Wrap errors with `CacheWriteError` including note ID and path
  - Log successful writes at debug level with zerolog

- 3.2.3: Implement Delete method:
  - Remove file using `os.Remove`
  - Return nil if file doesn't exist (idempotent delete)
  - Wrap errors with `CacheDeleteError` including note ID and path
  - Log successful deletes at debug level

**JSONCacheReadAdapter Implementation:**

- 3.2.4: Create `internal/adapters/spi/cache/json_reader.go` with JSONCacheReadAdapter:
  - Implements CacheReaderPort interface
  - Constructor: `NewJSONCacheReader(config Config, log Logger) *JSONCacheReadAdapter`
  - Uses `encoding/json` for deserialization
  - Preserves unknown JSON fields (FR6)

- 3.2.5: Implement Read method:
  - Read file using `os.ReadFile`
  - Deserialize JSON with `json.Unmarshal` into Note
  - Preserve unknown fields in Frontmatter.Fields map
  - Wrap errors with `CacheReadError` including note ID and path
  - Return `ErrNotFound` if file doesn't exist

- 3.2.6: Implement List method:
  - Walk cache directory using `filepath.Walk`
  - Filter for `.json` files only
  - Deserialize each JSON file to Note
  - Collect errors but continue processing (partial results on errors)
  - Log warnings for unreadable files, return aggregated results

**Helper Functions:**

- 3.2.7: Create `internal/adapters/spi/cache/helper.go` with shared utilities:
  - `noteFilePath(cacheDir string, id NoteID) string` - Construct cache file path
  - `ensureCacheDir(cacheDir string) error` - Create cache directory if missing
  - Shared by both write and read adapters (DRY principle)

**Testing:**

- 3.2.8: Create comprehensive unit tests in `internal/adapters/spi/cache/json_writer_test.go`:
  - Test Persist success path (creates directory, writes JSON, atomic operation)
  - Test Persist with existing file (overwrites atomically)
  - Test Persist with invalid cache directory (permission denied)
  - Test Delete success path (removes file)
  - Test Delete with non-existent file (returns nil - idempotent)
  - Test Delete with permission error
  - Verify error wrapping includes note ID and path
  - Verify atomic write semantics (use temp directory)

- 3.2.9: Create comprehensive unit tests in `internal/adapters/spi/cache/json_reader_test.go`:
  - Test Read success path (deserializes valid JSON)
  - Test Read with non-existent file (returns ErrNotFound)
  - Test Read with malformed JSON (returns deserialization error)
  - Test Read preserves unknown fields in Frontmatter (FR6)
  - Test List success path (returns all notes)
  - Test List with empty cache directory (returns empty slice)
  - Test List with mixed valid/invalid files (partial results + warnings)
  - Verify error wrapping includes note ID and path

- 3.2.10: All tests pass: `go test ./internal/adapters/spi/cache`

- 3.2.11: All linting passes: `golangci-lint run ./internal/adapters/spi/cache`

- 3.2.12: Committed with message: `feat(cache): implement JSON cache adapters with atomic writes and unknown field preservation`

## Tasks / Subtasks

- [ ] Task 1: Create helper functions (AC: 3.2.7)
  - [ ] RED: Write failing test for noteFilePath
    - [ ] Write test case in `internal/adapters/spi/cache/helper_test.go`
    - [ ] Verify test fails with expected error message
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] RED: Write failing test for ensureCacheDir
    - [ ] Write test case verifying directory creation
    - [ ] Test idempotent behavior (calling twice succeeds)
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] GREEN: Create `internal/adapters/spi/cache/helper.go`
    - [ ] Implement noteFilePath using filepath.Join
    - [ ] Implement ensureCacheDir using os.MkdirAll
    - [ ] Run `go test ./internal/adapters/spi/cache` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify noteFilePath has single responsibility (construct path)
      - [ ] Verify ensureCacheDir has single responsibility (create directory)
    - [ ] Review naming: noteFilePath (clear action), ensureCacheDir (idiomatic ensure pattern)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add package comment explaining cache helpers
      - [ ] Add GoDoc for noteFilePath explaining path construction
      - [ ] Add GoDoc for ensureCacheDir explaining idempotent behavior
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/cache`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/spi/cache` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for helpers
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/cache`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 2: Implement JSONCacheWriteAdapter struct and constructor (AC: 3.2.1)
  - [ ] RED: Write failing test for NewJSONCacheWriter
    - [ ] Write test case in `internal/adapters/spi/cache/json_writer_test.go`
    - [ ] Verify interface compliance with type assertion
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] GREEN: Create `internal/adapters/spi/cache/json_writer.go`
    - [ ] Define JSONCacheWriteAdapter struct with config and log fields
    - [ ] Implement NewJSONCacheWriter constructor
    - [ ] Add interface compliance check: `var _ CacheWriterPort = (*JSONCacheWriteAdapter)(nil)`
    - [ ] Run `go test ./internal/adapters/spi/cache` and verify all tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify struct has single responsibility (cache write operations)
      - [ ] Verify constructor has single responsibility (initialization)
    - [ ] Review naming: JSONCacheWriteAdapter (clear), NewJSONCacheWriter (idiomatic)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for struct explaining atomic write guarantees
      - [ ] Add GoDoc for constructor explaining dependencies
      - [ ] Reference CacheWriterPort interface contract
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/cache`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/spi/cache` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/cache`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 3: Implement Persist method (AC: 3.2.2)
  - [ ] RED: Write failing test for Persist creates directory
    - [ ] Write test case verifying directory creation
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] RED: Write failing test for Persist serializes Note to JSON
    - [ ] Write test case verifying JSON structure
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] RED: Write failing test for Persist uses atomic write
    - [ ] Write test case verifying atomicity guarantees
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] RED: Write failing test for Persist overwrites existing file
    - [ ] Write test case with pre-existing file
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] RED: Write failing test for Persist wraps errors correctly
    - [ ] Write test case for error scenarios
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] GREEN: Implement Persist method
    - [ ] Add ensureCacheDir call
    - [ ] Add JSON serialization with json.Marshal
    - [ ] Add atomic write with atomicwriter.WriteFile
    - [ ] Add error wrapping with CacheWriteError
    - [ ] Add debug logging with zerolog
    - [ ] Run `go test ./internal/adapters/spi/cache` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract marshalNote() helper if serialization logic >10 lines
      - [ ] Extract writeAtomic() helper if write logic >10 lines
      - [ ] Extract wrapCacheError() helper for consistent error wrapping
    - [ ] Review naming: Persist (clear domain action), helper methods descriptive
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for Persist explaining atomic guarantees
      - [ ] Document all parameters and return values
      - [ ] Add inline comments for complex logic
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/cache`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/spi/cache` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for Persist
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/cache`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 4: Implement Delete method (AC: 3.2.3)
  - [ ] RED: Write failing test for Delete removes file
    - [ ] Write test case verifying file removal
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] RED: Write failing test for Delete is idempotent (non-existent file)
    - [ ] Write test case with non-existent file
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] RED: Write failing test for Delete wraps errors correctly
    - [ ] Write test case for error scenarios
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] GREEN: Implement Delete method
    - [ ] Add os.Remove call
    - [ ] Add idempotent check (return nil if os.IsNotExist)
    - [ ] Add error wrapping with CacheDeleteError
    - [ ] Add debug logging
    - [ ] Run `go test ./internal/adapters/spi/cache` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify Delete has single responsibility (remove file)
      - [ ] Extract error wrapping if logic >5 lines
    - [ ] Review naming: Delete (clear), error handling clear
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc explaining idempotent behavior
      - [ ] Document error cases
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/cache`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/spi/cache` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for Delete
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/cache`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 5: Implement JSONCacheReadAdapter struct and constructor (AC: 3.2.4)
  - [ ] RED: Write failing test for NewJSONCacheReader
    - [ ] Write test case in `internal/adapters/spi/cache/json_reader_test.go`
    - [ ] Verify interface compliance with type assertion
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] GREEN: Create `internal/adapters/spi/cache/json_reader.go`
    - [ ] Define JSONCacheReadAdapter struct with config and log fields
    - [ ] Implement NewJSONCacheReader constructor
    - [ ] Add interface compliance check: `var _ CacheReaderPort = (*JSONCacheReadAdapter)(nil)`
    - [ ] Run `go test ./internal/adapters/spi/cache` and verify all tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify struct has single responsibility (cache read operations)
      - [ ] Verify constructor has single responsibility (initialization)
    - [ ] Review naming: JSONCacheReadAdapter (clear), NewJSONCacheReader (idiomatic)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for struct explaining read semantics
      - [ ] Add GoDoc for constructor explaining dependencies
      - [ ] Reference CacheReaderPort interface contract
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/cache`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/spi/cache` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/cache`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 6: Implement Read method (AC: 3.2.5)
  - [ ] RED: Write failing test for Read deserializes JSON
    - [ ] Write test case verifying deserialization
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] RED: Write failing test for Read returns ErrNotFound for missing file
    - [ ] Write test case with non-existent file
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] RED: Write failing test for Read preserves unknown fields (FR6)
    - [ ] Write test case with unknown frontmatter fields
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] RED: Write failing test for Read wraps errors correctly
    - [ ] Write test case for error scenarios
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] GREEN: Implement Read method
    - [ ] Add noteFilePath call
    - [ ] Add file read with os.ReadFile
    - [ ] Add JSON deserialization with json.Unmarshal
    - [ ] Add ErrNotFound handling for missing files
    - [ ] Add error wrapping with CacheReadError
    - [ ] Verify unknown fields preserved in Frontmatter.Fields
    - [ ] Run `go test ./internal/adapters/spi/cache` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract unmarshalNote() helper if deserialization logic >10 lines
      - [ ] Extract readFile() helper if file reading logic >10 lines
      - [ ] Extract wrapCacheError() helper for consistent error wrapping
    - [ ] Review naming: Read (clear domain action), helper methods descriptive
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for Read explaining error cases
      - [ ] Document FR6 preservation requirement
      - [ ] Add inline comments for complex logic
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/cache`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/spi/cache` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for Read
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/cache`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 7: Implement List method (AC: 3.2.6)
  - [ ] RED: Write failing test for List returns all notes
    - [ ] Write test case with multiple cache files
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] RED: Write failing test for List returns empty slice for empty cache
    - [ ] Write test case with empty directory
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] RED: Write failing test for List handles partial failures (mixed valid/invalid)
    - [ ] Write test case with mixed valid/invalid files
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] RED: Write failing test for List filters non-JSON files
    - [ ] Write test case with mixed file types
    - [ ] Run `go test ./internal/adapters/spi/cache` and confirm failure
  - [ ] GREEN: Implement List method
    - [ ] Add filepath.Walk call
    - [ ] Add .json file filtering
    - [ ] Add per-file deserialization with error collection
    - [ ] Add warning logs for unreadable files
    - [ ] Return partial results on errors
    - [ ] Run `go test ./internal/adapters/spi/cache` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract walkCallback() helper for filepath.Walk logic
      - [ ] Extract processNote() helper if note processing >10 lines
      - [ ] Extract shouldIncludeFile() helper for filtering logic
    - [ ] Review naming: List (clear domain action), helper methods descriptive
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for List explaining partial failure handling
      - [ ] Document filtering behavior
      - [ ] Add inline comments for walk logic
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/cache`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/spi/cache` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for List
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/cache`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 8: Run quality gates (AC: 3.2.10-3.2.11)
  - [ ] Run `go test ./internal/adapters/spi/cache` and verify 100% pass
  - [ ] Run `golangci-lint run --fix internal/adapters/spi/cache`
  - [ ] Fix any linting issues
  - [ ] Verify test coverage is adequate (>85% for adapters)
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/cache`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 9: Commit changes (AC: 3.2.12)
  - [ ] Review all changes
  - [ ] Stage files: `git add internal/adapters/spi/cache/`
  - [ ] Commit with message: `feat(cache): implement JSON cache adapters with atomic writes and unknown field preservation`

## Dev Notes

### Architecture Alignment (v0.6.8)

From `docs/architecture/components.md#jsoncachewriteadapter` and `#jsoncachereadapter`:

**CQRS Pattern Implementation:**

The cache adapters implement the CQRS pattern with separate concerns:

- **JSONCacheWriteAdapter (Write Side):** Handles atomic persistence, consistency, error recovery
- **JSONCacheReadAdapter (Read Side):** Handles lazy loading, query performance, partial failure tolerance

This separation enables:

- Independent optimization strategies (write atomicity vs read caching)
- Different failure modes (write failures are hard errors, read failures return partial results)
- Interface Segregation Principle compliance

### JSONCacheWriteAdapter Implementation

From `docs/architecture/components.md#jsoncachewriteadapter`:

**Atomic Write Semantics:**

Uses `moby/sys/atomicwriter.WriteFile` for atomic writes:

1. Write to temporary file in same directory
2. Set proper permissions (0644 for files, 0755 for directories)
3. Rename temp file to target atomically
4. Guarantees all-or-nothing semantics (no partial writes)

**Implementation Pattern:**

```go
type JSONCacheWriteAdapter struct {
    config Config
    log    zerolog.Logger
}

func (a *JSONCacheWriteAdapter) Persist(ctx context.Context, note Note) error {
    // 1. Ensure cache directory exists
    if err := ensureCacheDir(a.config.CacheDir); err != nil {
        return fmt.Errorf("failed to create cache directory: %w", err)
    }

    // 2. Serialize note to JSON
    data, err := json.MarshalIndent(note, "", "  ")
    if err != nil {
        return fmt.Errorf("failed to serialize note %s: %w", note.ID, err)
    }

    // 3. Atomic write
    path := noteFilePath(a.config.CacheDir, note.ID)
    if err := atomicwriter.WriteFile(path, bytes.NewReader(data), 0644); err != nil {
        return fmt.Errorf("cache write failed for note %s at %s: %w", note.ID, path, err)
    }

    a.log.Debug().Str("note_id", string(note.ID)).Str("path", path).Msg("cache write successful")
    return nil
}
```

**Error Wrapping Strategy:**

- Include operation context ("cache write failed")
- Include resource identifiers (note ID, file path)
- Preserve error chain with `%w` for debugging
- Use structured error types from `internal/shared/errors`

### JSONCacheReadAdapter Implementation

From `docs/architecture/components.md#jsoncachereadapter`:

**Unknown Field Preservation (FR6):**

Critical requirement: Must preserve all JSON fields during deserialization.

**Implementation Strategy:**

```go
func (a *JSONCacheReadAdapter) Read(ctx context.Context, id NoteID) (Note, error) {
    path := noteFilePath(a.config.CacheDir, id)

    // 1. Read file
    data, err := os.ReadFile(path)
    if err != nil {
        if os.IsNotExist(err) {
            return Note{}, ErrNotFound
        }
        return Note{}, fmt.Errorf("cache read failed for note %s at %s: %w", id, path, err)
    }

    // 2. Deserialize with unknown field preservation
    var note Note
    if err := json.Unmarshal(data, &note); err != nil {
        return Note{}, fmt.Errorf("failed to deserialize note %s: %w", id, err)
    }

    // Note: json.Unmarshal automatically preserves unknown fields in map[string]interface{}
    // Frontmatter.Fields is map[string]interface{}, so unknown fields are preserved

    return note, nil
}
```

**Partial Failure Tolerance:**

List method handles mixed valid/invalid files gracefully:

- Logs warnings for unreadable files
- Continues processing remaining files
- Returns partial results instead of failing completely
- Aggregates errors for debugging

**Implementation Pattern:**

```go
func (a *JSONCacheReadAdapter) List(ctx context.Context) ([]Note, error) {
    var notes []Note
    var errors []error

    err := filepath.Walk(a.config.CacheDir, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        if info.IsDir() || filepath.Ext(path) != ".json" {
            return nil
        }

        // Read note (derive NoteID from filename)
        noteID := NoteID(strings.TrimSuffix(filepath.Base(path), ".json"))
        note, err := a.Read(ctx, noteID)
        if err != nil {
            a.log.Warn().Err(err).Str("path", path).Msg("failed to read cache file")
            errors = append(errors, err)
            return nil // Continue processing
        }

        notes = append(notes, note)
        return nil
    })

    if err != nil {
        return nil, fmt.Errorf("cache directory walk failed: %w", err)
    }

    return notes, nil // Return partial results even if some files failed
}
```

### Cache File Format

**JSON Structure:**

```json
{
  "ID": "contact-alice",
  "Frontmatter": {
    "FileClass": "contact",
    "Fields": {
      "fileClass": "contact",
      "title": "Alice Smith",
      "email": "alice@example.com",
      "tags": ["work", "engineering"],
      "custom_field": "preserved value"
    }
  }
}
```

**Key Points:**

- Top-level JSON object with ID and Frontmatter fields
- Frontmatter.Fields is flexible map (map[string]interface{})
- Unknown fields in Fields map are preserved during round-trip
- Pretty-printed JSON with 2-space indentation for human readability

### Helper Functions

From `docs/architecture/components.md#jsoncachewriteadapter`:

**Shared Utilities in helper.go:**

```go
// noteFilePath constructs cache file path from note ID
// Format: {cacheDir}/{noteID}.json
func noteFilePath(cacheDir string, id NoteID) string {
    return filepath.Join(cacheDir, string(id)+".json")
}

// ensureCacheDir creates cache directory if missing
// Uses os.MkdirAll for recursive creation (mkdir -p semantics)
// Permissions: 0755 (rwxr-xr-x)
func ensureCacheDir(cacheDir string) error {
    return os.MkdirAll(cacheDir, 0755)
}
```

**Design Rationale:**

- DRY principle: Shared by write and read adapters
- Single source of truth for file path construction
- Consistent directory creation logic
- OS-agnostic path handling with filepath.Join

### Thread Safety

From `docs/architecture/components.md#cachewriterport`:

**Concurrent Access Patterns:**

- Multiple readers may access cache simultaneously (QueryService, FrontmatterService)
- Writers and readers may operate concurrently (indexing + template rendering)
- Filesystem operations are naturally thread-safe (OS-level locking)

**Implementation Guarantees:**

- Atomic writes prevent partial reads (temp + rename)
- No shared mutable state in adapters (stateless beyond config/logger)
- No need for explicit locking (filesystem provides guarantees)

### Error Handling Strategy

From `docs/architecture/error-handling-strategy.md`:

**Structured Error Types:**

Define domain-specific errors in `internal/shared/errors`:

```go
type CacheWriteError struct {
    NoteID    NoteID
    Path      string
    Operation string
    Cause     error
}

type CacheReadError struct {
    NoteID    NoteID
    Path      string
    Operation string
    Cause     error
}

var ErrNotFound = errors.New("cache entry not found")
```

**Error Wrapping Examples:**

```go
// Write error
return &CacheWriteError{
    NoteID:    note.ID,
    Path:      path,
    Operation: "persist",
    Cause:     err,
}

// Read error (missing file)
if os.IsNotExist(err) {
    return Note{}, ErrNotFound
}

// Read error (other)
return Note{}, &CacheReadError{
    NoteID:    id,
    Path:      path,
    Operation: "read",
    Cause:     err,
}
```

### Logging Standards

From `docs/architecture/coding-standards.md`:

**Structured Logging with zerolog:**

```go
// Success (debug level)
a.log.Debug().
    Str("note_id", string(note.ID)).
    Str("path", path).
    Msg("cache write successful")

// Warning (partial failure)
a.log.Warn().
    Err(err).
    Str("path", path).
    Msg("failed to read cache file")

// Error (operation failed)
a.log.Error().
    Err(err).
    Str("note_id", string(id)).
    Str("operation", "persist").
    Msg("cache write failed")
```

**Logging Guidelines:**

- Debug level for successful operations
- Warn level for recoverable errors (partial failures)
- Error level for operation failures
- Include structured fields (note_id, path, operation)
- Use `Err(err)` to include error details

### Testing Strategy

From `docs/architecture/testing-strategy.md`:

**Unit Test Organization:**

- `json_writer_test.go` - Tests for JSONCacheWriteAdapter
- `json_reader_test.go` - Tests for JSONCacheReadAdapter
- `helper_test.go` - Tests for shared helper functions

**Test Coverage Requirements:**

- Success paths (happy path)
- Error paths (permission denied, malformed JSON, missing files)
- Edge cases (empty cache, idempotent operations)
- Behavioral contracts (atomic writes, unknown field preservation)

**Table-Driven Tests:**

```go
func TestPersist(t *testing.T) {
    tests := []struct {
        name      string
        note      Note
        setupFunc func(t *testing.T, cacheDir string)
        wantErr   bool
    }{
        {
            name: "success - new file",
            note: Note{ID: "test", Frontmatter: Frontmatter{}},
            wantErr: false,
        },
        {
            name: "success - overwrite existing",
            note: Note{ID: "test", Frontmatter: Frontmatter{}},
            setupFunc: func(t *testing.T, cacheDir string) {
                // Pre-create file
            },
            wantErr: false,
        },
        {
            name: "error - permission denied",
            note: Note{ID: "test", Frontmatter: Frontmatter{}},
            setupFunc: func(t *testing.T, cacheDir string) {
                // Make directory read-only
            },
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Test implementation
        })
    }
}
```

### Functional Requirements Traceability

**FR6: Preserve Unknown Fields**

- JSONCacheReadAdapter MUST preserve all JSON fields during deserialization
- Use map[string]interface{} for Frontmatter.Fields (automatic preservation)
- Test round-trip: persist note with unknown fields → read → verify fields unchanged

**FR9: Error Context**

- All errors include operation context (persist, delete, read, list)
- All errors include resource identifiers (note ID, file path)
- Preserve error chains with `%w` for debugging

### Dependencies

**Standard Library:**

- `encoding/json` - JSON serialization/deserialization
- `os` - File operations (ReadFile, Remove, Stat, MkdirAll)
- `path/filepath` - OS-agnostic path handling (Join, Walk, Ext, Base)
- `context` - Cancellation support

**Third-Party:**

- `github.com/moby/sys/atomicwriter` - Atomic file writes (temp + rename)
- `github.com/rs/zerolog` - Structured logging

**Internal:**

- `internal/domain` - Note, NoteID, Frontmatter models
- `internal/ports/spi` - CacheWriterPort, CacheReaderPort interfaces
- `internal/shared/errors` - Structured error types
- `internal/shared/logger` - Logger wrapper

### File Locations

From `docs/architecture/source-tree.md`:

**Adapter Implementations:**

- `internal/adapters/spi/cache/json_writer.go` - JSONCacheWriteAdapter
- `internal/adapters/spi/cache/json_reader.go` - JSONCacheReadAdapter
- `internal/adapters/spi/cache/helper.go` - Shared utilities

**Unit Tests:**

- `internal/adapters/spi/cache/json_writer_test.go` - Write adapter tests
- `internal/adapters/spi/cache/json_reader_test.go` - Read adapter tests
- `internal/adapters/spi/cache/helper_test.go` - Helper function tests

### Refactoring Guidelines

**SRP Decomposition for Adapters:**

**JSONCacheWriteAdapter:**

- Persist method: Extract helpers if method exceeds 20 lines
  - `marshalNote(note Note) ([]byte, error)` - Handle JSON serialization
  - `writeAtomic(path string, data []byte) error` - Handle atomic write
  - `wrapCacheError(op string, noteID NoteID, path string, err error) error` - Consistent error wrapping
- Delete method: Should remain simple (<15 lines)
  - Extract error wrapping if repeated pattern

**JSONCacheReadAdapter:**

- Read method: Extract helpers if method exceeds 20 lines
  - `unmarshalNote(data []byte) (Note, error)` - Handle JSON deserialization
  - `readFile(path string) ([]byte, error)` - Handle file reading with error translation
  - `wrapCacheError(op string, noteID NoteID, path string, err error) error` - Consistent error wrapping
- List method: Extract helpers for clarity
  - `processNote(path string) (Note, error)` - Handle single note processing
  - `shouldIncludeFile(info os.FileInfo, path string) bool` - Filter logic

**Helper Functions:**

- Keep helpers focused and simple (<10 lines each)
- Each helper should have a single clear responsibility
- Use descriptive names that explain the action

**When to Decompose:**

- If any method exceeds 20 lines, consider extraction
- If error wrapping is repeated >2 times, extract helper
- If file operations mix with business logic, separate concerns
- If testing is difficult due to complexity, decompose

**Naming Standards:**

- Adapter types: [Format][Purpose]Adapter (JSONCacheWriteAdapter)
- Constructors: New[AdapterName] (NewJSONCacheWriter)
- Private helpers: camelCase, specific action (marshalNote, writeAtomic)
- Error wrappers: wrap[ErrorType]Error (wrapCacheError)
- Boolean helpers: is, has, should prefix

**Documentation Requirements:**

- Package comment explaining cache adapter pattern
- All exported types have GoDoc comments
- Methods have GoDoc explaining behavior, parameters, errors
- Complex logic (atomic writes, error handling) has inline comments
- Reference architecture documents where relevant

### Common Pitfalls to Avoid

1. **DO NOT use non-atomic writes** - Use atomicwriter, not plain os.WriteFile
2. **DO preserve unknown fields** - Use map[string]interface{} for flexible JSON
3. **DO handle partial failures gracefully** - List should return partial results
4. **DO make Delete idempotent** - Return nil if file doesn't exist
5. **DO wrap errors with context** - Include note ID and path in all errors
6. **DO use structured logging** - Include note_id, path, operation fields
7. **DO test atomic write semantics** - Verify temp file + rename pattern

## Change Log

| Date       | Version | Description                                                                                                                                                                  | Author             |
| ---------- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------ |
| 2025-10-28 | 1.0     | Story created from Epic 3 requirements                                                                                                                                       | Bob (Scrum Master) |
| 2025-10-28 | 1.1     | Enhanced with full TDD framework, SRP decomposition (marshalNote, unmarshalNote, writeAtomic, readFile, wrapCacheError helpers), linting checkpoints, refactoring guidelines | QA Specialist      |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## Testing

**Test Design:** `docs/qa/assessments/3.2-test-design-20251029.md`

## QA Results

_To be completed by QA agent after implementation_
