# Story 1.8: Config Loading Infrastructure

## Status

Draft

## Story

**As a** developer,
**I want** to implement ConfigPort interface and ViperAdapter,
**so that** application configuration can be loaded from file, environment, and flags following hexagonal architecture.

## Acceptance Criteria

**ConfigPort Interface:**

- 1.8.1: Create `internal/ports/spi/config.go`:
  - Interface: `ConfigPort`
  - Method: `Load(ctx context.Context) (Config, error)`
  - Add documentation comments:
    - Describe port responsibility
    - Document Load() method contract
    - Reference architecture components.md

**ViperAdapter Implementation:**

- 1.8.2: Add `github.com/spf13/viper` to `go.mod`

- 1.8.3: Create `internal/adapters/spi/config/viper.go`:
  - Implements ConfigPort interface
  - Constructor: `NewViperAdapter(log zerolog.Logger) *ViperAdapter`

- 1.8.4: Implement Load() method with precedence (highest to lowest):
  1. CLI flags (not implemented yet, reserved for future stories)
  2. Environment variables (LITHOS_VAULT_PATH, LITHOS_LOG_LEVEL, etc.)
  3. Config file (`lithos.json` searched upward from CWD)
  4. Defaults from Config.DefaultConfig()

- 1.8.5: Config file search pattern:
  - Start from current working directory
  - Search upward through parent directories
  - Stop at first `lithos.json` found
  - Use that directory as VaultPath
  - If no config found, use CWD as VaultPath

- 1.8.6: Environment variable mapping:
  - `LITHOS_VAULT_PATH` → Config.VaultPath
  - `LITHOS_TEMPLATES_DIR` → Config.TemplatesDir
  - `LITHOS_SCHEMAS_DIR` → Config.SchemasDir
  - `LITHOS_PROPERTY_BANK_FILE` → Config.PropertyBankFile
  - `LITHOS_CACHE_DIR` → Config.CacheDir
  - `LITHOS_LOG_LEVEL` → Config.LogLevel

- 1.8.7: Validate VaultPath exists and is directory (return error if not)

**Testing:**

- 1.8.8: Create unit tests in `internal/adapters/spi/config/viper_test.go`:
  - Test: Defaults work when no config file
  - Test: Config file values override defaults
  - Test: Environment variables override config file
  - Test: VaultPath validation rejects non-existent paths
  - Test: Upward search finds config in parent directories

- 1.8.9: Create integration test with `testdata/vault/lithos.json`:
  - Create sample config file in testdata
  - Verify adapter loads values correctly

- 1.8.10: All tests pass: `go test ./internal/ports/spi ./internal/adapters/spi/config`

- 1.8.11: All linting passes: `golangci-lint run --fix internal/ports/spi internal/adapters/spi/config`

- 1.8.12: Committed with message: `feat: implement config loading with ConfigPort and ViperAdapter`

## Tasks / Subtasks

- [ ] Task 1: Define ConfigPort interface (AC: 1.8.1)
  - [ ] RED: Write failing test for ConfigPort contract
  - [ ] GREEN: Define ConfigPort interface in ports/spi/config.go
  - [ ] REFACTOR: Add comprehensive documentation
  - [ ] Document Load() method contract (context, error handling)
  - [ ] Reference architecture components.md

- [ ] Task 2: Add Viper dependency (AC: 1.8.2)
  - [ ] Run `go get github.com/spf13/viper@v1.21.0`
  - [ ] Verify dependency in go.mod

- [ ] Task 3: Implement ViperAdapter constructor (AC: 1.8.3)
  - [ ] RED: Write failing test for NewViperAdapter()
  - [ ] GREEN: Implement constructor with logger injection
  - [ ] REFACTOR: Initialize Viper instance in constructor

- [ ] Task 4: Implement config file search (AC: 1.8.5)
  - [ ] RED: Write failing test for upward directory search
  - [ ] GREEN: Implement searchConfigFile() helper
  - [ ] REFACTOR: Start from CWD, traverse to parent until found
  - [ ] RED: Write test for config in parent directory
  - [ ] GREEN: Verify search stops at first lithos.json
  - [ ] REFACTOR: Use CWD as VaultPath if no config found

- [ ] Task 5: Implement Load() with precedence (AC: 1.8.4)
  - [ ] RED: Write failing test for defaults
  - [ ] GREEN: Load DefaultConfig() as baseline
  - [ ] REFACTOR: Log default values used
  - [ ] RED: Write failing test for config file override
  - [ ] GREEN: Read lithos.json if found, override defaults
  - [ ] REFACTOR: Parse JSON and map to Config struct
  - [ ] RED: Write failing test for environment variable override
  - [ ] GREEN: Read LITHOS_* env vars, override config file
  - [ ] REFACTOR: Document precedence order clearly

- [ ] Task 6: Implement environment variable mapping (AC: 1.8.6)
  - [ ] Map LITHOS_VAULT_PATH to Config.VaultPath
  - [ ] Map LITHOS_TEMPLATES_DIR to Config.TemplatesDir
  - [ ] Map LITHOS_SCHEMAS_DIR to Config.SchemasDir
  - [ ] Map LITHOS_PROPERTY_BANK_FILE to Config.PropertyBankFile
  - [ ] Map LITHOS_CACHE_DIR to Config.CacheDir
  - [ ] Map LITHOS_LOG_LEVEL to Config.LogLevel
  - [ ] Use Viper's automatic env binding

- [ ] Task 7: Implement VaultPath validation (AC: 1.8.7)
  - [ ] RED: Write failing test for non-existent VaultPath
  - [ ] GREEN: Check VaultPath exists using os.Stat
  - [ ] REFACTOR: Verify VaultPath is directory, not file
  - [ ] RED: Write test for invalid VaultPath (file not dir)
  - [ ] GREEN: Return descriptive error if validation fails
  - [ ] REFACTOR: Log VaultPath used for transparency

- [ ] Task 8: Create unit tests (AC: 1.8.8)
  - [ ] Test defaults when no config file exists
  - [ ] Test config file values override defaults
  - [ ] Test environment variables override config file
  - [ ] Test VaultPath validation (exists, is directory)
  - [ ] Test upward search finds config in parent
  - [ ] Test search stops at first lithos.json found

- [ ] Task 9: Create integration test (AC: 1.8.9)
  - [ ] Create testdata/vault/lithos.json with sample config
  - [ ] Test ViperAdapter loads values correctly
  - [ ] Verify precedence order works end-to-end
  - [ ] Test search behavior with real directory structure

- [ ] Task 10: Verify tests and linting (AC: 1.8.10-1.8.11)
  - [ ] Run `go test ./internal/ports/spi` - verify all pass
  - [ ] Run `go test ./internal/adapters/spi/config` - verify all pass
  - [ ] Run `golangci-lint run --fix internal/ports/spi` - verify no warnings
  - [ ] Run `golangci-lint run --fix internal/adapters/spi/config` - verify no warnings

- [ ] Task 11: Commit changes (AC: 1.8.12)
  - [ ] Stage ConfigPort and ViperAdapter files
  - [ ] Commit with message: `feat: implement config loading with ConfigPort and ViperAdapter`

## Dev Notes

### ConfigPort Architecture

From `docs/architecture/components.md#spi-port-interfaces`:

**ConfigPort Responsibility:** Load and expose resolved configuration (vault path, directories, log level) to domain services and adapters.

**Key Interfaces:**
- `Load(ctx context.Context) (Config, error)` - Load config from `lithos.json`, env vars, and CLI flags with precedence

**Dependencies:** Implemented by ViperAdapter.

**Technology Stack:** `github.com/spf13/viper`, precedence: CLI flags > env vars > config file > defaults, searches upward from CWD for `lithos.json`.

**Note:** Config is value object (immutable). Loaded once at startup. Post-MVP: Add `Reload()` for dynamic config updates.

[Source: docs/architecture/components.md#configport]

From `docs/architecture/components.md#spi-adapters`:

**ViperAdapter Responsibility:** Implement `ConfigPort` by loading configuration from `lithos.json`, environment variables, and CLI flags with proper precedence.

**Key Interfaces:**
- `Load(ctx context.Context) (Config, error)` - Load and resolve configuration from all sources

**Dependencies:** `github.com/spf13/viper`, Go `os`, `filepath`, Logger.

**Technology Stack:** Viper configuration bindings, precedence: CLI flags > env vars > config file > defaults, searches upward from CWD for `lithos.json`, environment variable mapping (e.g., `LITHOS_VAULT_PATH`).

**Note:** Config is immutable value object - loaded once at startup. Post-MVP: Add `Reload()` for dynamic configuration updates.

[Source: docs/architecture/components.md#viperadapter]

From `docs/architecture/tech-stack.md`:

**Configuration:** `github.com/spf13/viper` v1.21.0
- Seamless Cobra integration, supports YAML/ENV/flags hierarchy
- PRD explicitly specifies
- Handles `lithos.yaml` directory traversal search
- Latest release Sep 2025

[Source: docs/architecture/tech-stack.md]

### ViperAdapter Implementation Patterns

**Upward Config Search Pattern:**
```go
func searchConfigFile() (string, error) {
    dir, err := os.Getwd()
    if err != nil {
        return "", err
    }

    for {
        configPath := filepath.Join(dir, "lithos.json")
        if _, err := os.Stat(configPath); err == nil {
            return dir, nil // Found config, return directory
        }

        parent := filepath.Dir(dir)
        if parent == dir {
            // Reached root, no config found
            return "", os.ErrNotExist
        }
        dir = parent
    }
}
```

**Load Method with Precedence:**
```go
func (a *ViperAdapter) Load(ctx context.Context) (Config, error) {
    // 1. Start with defaults
    cfg := DefaultConfig()

    // 2. Search for config file
    vaultPath, err := searchConfigFile()
    if err == nil {
        // Found config file, load it
        v := viper.New()
        v.SetConfigName("lithos")
        v.SetConfigType("json")
        v.AddConfigPath(vaultPath)

        if err := v.ReadInConfig(); err == nil {
            // Override defaults with config file values
            cfg.VaultPath = v.GetString("vault_path")
            cfg.TemplatesDir = v.GetString("templates_dir")
            // ... etc
        }
    } else {
        // No config file, use CWD as VaultPath
        cwd, _ := os.Getwd()
        cfg.VaultPath = cwd
    }

    // 3. Override with environment variables
    if val := os.Getenv("LITHOS_VAULT_PATH"); val != "" {
        cfg.VaultPath = val
    }
    // ... etc for other env vars

    // 4. Validate VaultPath
    if err := validateVaultPath(cfg.VaultPath); err != nil {
        return Config{}, err
    }

    return cfg, nil
}
```

**VaultPath Validation:**
```go
func validateVaultPath(path string) error {
    info, err := os.Stat(path)
    if err != nil {
        return fmt.Errorf("vault path does not exist: %w", err)
    }
    if !info.IsDir() {
        return fmt.Errorf("vault path is not a directory: %s", path)
    }
    return nil
}
```

**Environment Variable Mapping:**
```go
// Viper automatic env binding
v.SetEnvPrefix("LITHOS")
v.AutomaticEnv()

// Maps:
// LITHOS_VAULT_PATH → VaultPath
// LITHOS_TEMPLATES_DIR → TemplatesDir
// LITHOS_SCHEMAS_DIR → SchemasDir
// LITHOS_PROPERTY_BANK_FILE → PropertyBankFile
// LITHOS_CACHE_DIR → CacheDir
// LITHOS_LOG_LEVEL → LogLevel
```

### Configuration Precedence

**Precedence Order (highest to lowest):**
1. **CLI flags** (not implemented in Epic 1, reserved for future)
2. **Environment variables** (LITHOS_*)
3. **Config file** (lithos.json found via upward search)
4. **Defaults** (from Config.DefaultConfig())

**Example Precedence:**
```bash
# Defaults
VaultPath: "."

# Config file overrides defaults
VaultPath: "/path/to/vault" (from lithos.json)

# Environment overrides config file
LITHOS_VAULT_PATH=/different/vault (overrides lithos.json)

# CLI flags would override all (future)
--vault-path=/cli/vault (not implemented yet)
```

### Testing Standards

From `docs/architecture/testing-strategy.md`:

- Unit tests live beside code (`*_test.go`)
- Integration tests in `tests/integration/` when requiring fixtures
- Test config loading precedence order
- Test upward directory search behavior
- Test validation (VaultPath exists, is directory)
- Use testdata for sample config files

### File Locations

- Port: `internal/ports/spi/config.go`
- Adapter: `internal/adapters/spi/config/viper.go`
- Tests: `internal/adapters/spi/config/viper_test.go`
- Integration: `tests/integration/config_test.go` (if needed)
- Testdata: `testdata/vault/lithos.json`

### Implementation Notes

**Key Requirements:**

1. **Hexagonal Architecture:** ConfigPort defines contract, ViperAdapter implements
2. **Upward Search:** Search from CWD to filesystem root for lithos.json
3. **Precedence:** Env vars > config file > defaults (CLI flags reserved)
4. **Validation:** VaultPath must exist and be directory
5. **Immutability:** Config loaded once at startup, never modified

**Design Decisions:**

- **JSON Format:** lithos.json uses JSON format for MVP simplicity
- **Filename Search:** Search stops at first lithos.json found
- **VaultPath Resolution:** Directory containing lithos.json becomes VaultPath
- **Fallback:** Use CWD as VaultPath if no config file found
- **Environment Variables:** LITHOS_* prefix for all config overrides

**Error Handling:**

- Config file parse errors should be logged but not fatal (fall back to defaults)
- VaultPath validation errors are fatal (app cannot run without valid vault)
- Missing config file is not an error (use defaults + CWD)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 1 requirements | Bob (Scrum Master) |

## Dev Agent Record

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
