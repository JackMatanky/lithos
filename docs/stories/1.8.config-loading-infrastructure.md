# Story 1.8: Config Loading Infrastructure

## Status

Draft

## Story

**As a** developer,
**I want** to implement ConfigPort interface and ViperAdapter,
**so that** application configuration can be loaded from file, environment, and flags following hexagonal architecture.

## Acceptance Criteria

**ConfigPort Interface:**

- 1.8.1: Create `internal/ports/spi/config.go`:
  - Interface: `ConfigPort`
  - Method: `Load(ctx context.Context) (Config, error)`
  - Add documentation comments:
    - Describe port responsibility
    - Document Load() method contract
    - Reference architecture components.md

**ViperAdapter Implementation:**

- 1.8.2: Add `github.com/spf13/viper` to `go.mod`

- 1.8.3: Create `internal/adapters/spi/config/viper.go`:
  - Implements ConfigPort interface
  - Constructor: `NewViperAdapter(log zerolog.Logger) *ViperAdapter`

- 1.8.4: Implement Load() method with precedence (highest to lowest):
  1. CLI flags (not implemented yet, reserved for future stories)
  2. Environment variables (LITHOS_VAULT_PATH, LITHOS_LOG_LEVEL, etc.)
  3. Config file (`lithos.json` searched upward from CWD)
  4. Defaults from Config.DefaultConfig()

- 1.8.5: Config file search pattern:
  - Start from current working directory
  - Search upward through parent directories
  - Stop at first `lithos.json` found
  - Use that directory as VaultPath
  - If no config found, use CWD as VaultPath

- 1.8.6: Environment variable mapping:
  - `LITHOS_VAULT_PATH` → Config.VaultPath
  - `LITHOS_TEMPLATES_DIR` → Config.TemplatesDir
  - `LITHOS_SCHEMAS_DIR` → Config.SchemasDir
  - `LITHOS_PROPERTY_BANK_FILE` → Config.PropertyBankFile
  - `LITHOS_CACHE_DIR` → Config.CacheDir
  - `LITHOS_LOG_LEVEL` → Config.LogLevel

- 1.8.7: Validate VaultPath exists and is directory (return error if not)

**Testing:**

- 1.8.8: Create unit tests in `internal/adapters/spi/config/viper_test.go`:
  - Test: Defaults work when no config file
  - Test: Config file values override defaults
  - Test: Environment variables override config file
  - Test: VaultPath validation rejects non-existent paths
  - Test: Upward search finds config in parent directories

- 1.8.9: Create integration test with `testdata/vault/lithos.json`:
  - Create sample config file in testdata
  - Verify adapter loads values correctly

- 1.8.10: All tests pass: `go test ./internal/ports/spi ./internal/adapters/spi/config`

- 1.8.11: All linting passes: `golangci-lint run --fix internal/ports/spi internal/adapters/spi/config`

- 1.8.12: Committed with message: `feat: implement config loading with ConfigPort and ViperAdapter`

## Tasks / Subtasks

- [ ] Task 1: Define ConfigPort interface (AC: 1.8.1)
  - [ ] RED: Write failing test for ConfigPort contract
    - [ ] Write test case verifying ConfigPort interface exists
    - [ ] Verify test fails with expected compilation error
    - [ ] Run `go test ./internal/ports/spi` and confirm failure
  - [ ] GREEN: Define ConfigPort interface in ports/spi/config.go
    - [ ] Create `internal/ports/spi/config.go`
    - [ ] Define ConfigPort interface with Load() method
    - [ ] Run `go test ./internal/ports/spi` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components (interface definition):
      - [ ] Verify ConfigPort has single responsibility (define config loading contract)
      - [ ] Verify Load() method signature is clear and minimal
      - [ ] Verify no infrastructure concerns leak into interface
    - [ ] Review naming: ConfigPort (clear SPI port), Load() (idiomatic)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add package comment at top of config.go if not present
      - [ ] Add GoDoc for ConfigPort interface explaining SPI contract
      - [ ] Add GoDoc for Load() method documenting context usage, return values, error conditions
      - [ ] Reference architecture components.md for port responsibilities
    - [ ] Run `golangci-lint run --fix internal/ports/spi`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/ports/spi` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/ports/spi`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 2: Add Viper dependency (AC: 1.8.2)
  - [ ] Run `go get github.com/spf13/viper@v1.21.0`
  - [ ] Verify dependency in go.mod
  - [ ] Run `go mod tidy` to clean dependencies
  - [ ] Linting checkpoint:
    - [ ] Verify go.mod and go.sum are clean
    - [ ] No unused dependencies

- [ ] Task 3: Implement ViperAdapter constructor (AC: 1.8.3)
  - [ ] RED: Write failing test for NewViperAdapter()
    - [ ] Write test case in `internal/adapters/spi/config/viper_test.go`
    - [ ] Verify test fails with expected compilation error
    - [ ] Run `go test ./internal/adapters/spi/config` and confirm failure
  - [ ] GREEN: Implement constructor with logger injection
    - [ ] Create `internal/adapters/spi/config/viper.go`
    - [ ] Implement ViperAdapter struct with logger field
    - [ ] Implement NewViperAdapter constructor
    - [ ] Run `go test ./internal/adapters/spi/config` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify ViperAdapter struct has single responsibility (hold adapter state)
      - [ ] Verify NewViperAdapter constructor has single responsibility (create and initialize adapter)
      - [ ] Verify logger injection follows dependency inversion principle
    - [ ] Review naming: ViperAdapter (clear adapter name), NewViperAdapter (idiomatic)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add package comment at top of viper.go explaining adapter purpose
      - [ ] Add GoDoc for ViperAdapter struct
      - [ ] Add GoDoc for NewViperAdapter constructor documenting parameters
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/config`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/spi/config` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/config`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 4: Implement config file search (AC: 1.8.5)
  - [ ] RED: Write failing test for upward directory search
    - [ ] Write test case for searchConfigFile() in temp directory structure
    - [ ] Verify test fails with expected error (function not found)
    - [ ] Run `go test ./internal/adapters/spi/config` and confirm failure
  - [ ] RED: Write test for config in parent directory
    - [ ] Create test with nested directory structure
    - [ ] Place lithos.json in parent directory
    - [ ] Verify test fails (function not implemented)
  - [ ] RED: Write test for search stopping at first config
    - [ ] Create test with multiple lithos.json files at different levels
    - [ ] Verify test fails
  - [ ] GREEN: Implement searchConfigFile() helper
    - [ ] Implement basic upward traversal logic
    - [ ] Start from CWD using os.Getwd()
    - [ ] Traverse to parent directories until config found or root reached
    - [ ] Return directory path containing lithos.json
    - [ ] Run `go test ./internal/adapters/spi/config` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract getCurrentDir() helper for getting CWD with error handling
      - [ ] Extract configExistsInDir(dir string) bool for checking config file existence
      - [ ] Extract getParentDir(dir string) string for directory traversal
      - [ ] Extract isRootDir(dir string) bool for root detection
      - [ ] Verify searchConfigFile() orchestrates these helpers cleanly
    - [ ] Review naming: searchConfigFile() (clear intent), helper functions descriptive
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for searchConfigFile() explaining upward search algorithm
      - [ ] Document search stops at first lithos.json found
      - [ ] Document returns os.ErrNotExist if no config found
      - [ ] Add GoDoc for all helper functions
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/config`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/spi/config` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for searchConfigFile and helpers
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/config`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 5: Implement Load() with precedence (AC: 1.8.4)
  - [ ] RED: Write failing test for defaults
    - [ ] Write test case verifying DefaultConfig() used when no config file
    - [ ] Verify test fails (Load method not implemented)
    - [ ] Run `go test ./internal/adapters/spi/config` and confirm failure
  - [ ] RED: Write failing test for config file override
    - [ ] Write test case with lithos.json overriding defaults
    - [ ] Verify test fails
  - [ ] RED: Write failing test for environment variable override
    - [ ] Write test case with env vars overriding config file
    - [ ] Use os.Setenv in test setup
    - [ ] Verify test fails
  - [ ] GREEN: Implement Load() method
    - [ ] Load DefaultConfig() as baseline
    - [ ] Call searchConfigFile() to find config
    - [ ] Read lithos.json if found, override defaults
    - [ ] Read LITHOS_* env vars, override config file
    - [ ] Run `go test ./internal/adapters/spi/config` and verify all tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract loadDefaults() Config for loading default configuration
      - [ ] Extract loadConfigFile(dir string) (Config, error) for reading and parsing lithos.json
      - [ ] Extract parseConfigJSON(data []byte) (Config, error) for JSON unmarshaling
      - [ ] Extract loadEnvironmentVars() Config for reading env vars
      - [ ] Extract mergeConfigs(base, override Config) Config for applying precedence
      - [ ] Verify Load() orchestrates these helpers with clear precedence flow
    - [ ] Review naming: loadDefaults, loadConfigFile, loadEnvironmentVars (clear intent)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for Load() method documenting precedence order
      - [ ] Document each helper function's responsibility
      - [ ] Document error conditions and fallback behavior
      - [ ] Add inline comments explaining precedence logic
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/config`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/spi/config` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for Load and all helpers
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/config`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 6: Implement environment variable mapping (AC: 1.8.6)
  - [ ] RED: Write failing test for each env var mapping
    - [ ] Test LITHOS_VAULT_PATH override
    - [ ] Test LITHOS_TEMPLATES_DIR override
    - [ ] Test LITHOS_SCHEMAS_DIR override
    - [ ] Test LITHOS_PROPERTY_BANK_FILE override
    - [ ] Test LITHOS_CACHE_DIR override
    - [ ] Test LITHOS_LOG_LEVEL override
    - [ ] Run `go test ./internal/adapters/spi/config` and confirm failures
  - [ ] GREEN: Implement environment variable reading
    - [ ] Use Viper's SetEnvPrefix("LITHOS")
    - [ ] Use Viper's AutomaticEnv() for automatic mapping
    - [ ] Map each LITHOS_* env var to Config field
    - [ ] Run `go test ./internal/adapters/spi/config` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components (already handled in loadEnvironmentVars()):
      - [ ] Verify loadEnvironmentVars() cleanly reads all LITHOS_* vars
      - [ ] Verify no hardcoded values, uses os.Getenv consistently
      - [ ] Verify proper string-to-type conversion where needed
    - [ ] Review naming: env var names follow LITHOS_* convention
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Document all supported environment variables
      - [ ] Document precedence (env vars override config file)
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/config`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/spi/config` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/config`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 7: Implement VaultPath validation (AC: 1.8.7)
  - [ ] RED: Write failing test for non-existent VaultPath
    - [ ] Write test with invalid path
    - [ ] Verify test fails (validation not implemented)
    - [ ] Run `go test ./internal/adapters/spi/config` and confirm failure
  - [ ] RED: Write test for invalid VaultPath (file not directory)
    - [ ] Write test with regular file as VaultPath
    - [ ] Verify test fails
  - [ ] GREEN: Implement VaultPath validation
    - [ ] Check VaultPath exists using os.Stat
    - [ ] Verify VaultPath is directory using FileInfo.IsDir()
    - [ ] Return descriptive error if validation fails
    - [ ] Run `go test ./internal/adapters/spi/config` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract validateVaultPath(path string) error for validation logic
      - [ ] Extract pathExists(path string) bool helper for existence check
      - [ ] Extract isDirectory(path string) bool helper for directory check
      - [ ] Verify validateVaultPath() orchestrates these checks clearly
    - [ ] Review naming: validateVaultPath (clear intent), descriptive helpers
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for validateVaultPath() documenting checks performed
      - [ ] Document error messages returned for different failure cases
      - [ ] Document why VaultPath must exist and be directory
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/config`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/spi/config` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for validation logic
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/config`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 8: Create comprehensive unit tests (AC: 1.8.8)
  - [ ] Verify all unit tests written in previous tasks cover:
    - [ ] Test defaults when no config file exists
    - [ ] Test config file values override defaults
    - [ ] Test environment variables override config file
    - [ ] Test VaultPath validation (exists, is directory)
    - [ ] Test upward search finds config in parent
    - [ ] Test search stops at first lithos.json found
  - [ ] Run `go test ./internal/adapters/spi/config -v` and verify 100% pass
  - [ ] Verify test coverage >90%: `go test -cover ./internal/adapters/spi/config`
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/config`
    - [ ] Fix ALL test-related warnings
    - [ ] Verify test code quality

- [ ] Task 9: Create integration test (AC: 1.8.9)
  - [ ] Create `testdata/vault/lithos.json` with sample config
    - [ ] Include all config fields
    - [ ] Use realistic values
  - [ ] Create integration test in `tests/integration/config_test.go`
    - [ ] Test ViperAdapter loads values correctly from testdata
    - [ ] Verify precedence order works end-to-end
    - [ ] Test search behavior with real directory structure
  - [ ] Run `go test ./tests/integration -v` and verify pass
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix tests/integration`
    - [ ] Fix ALL warnings
    - [ ] Verify integration test quality

- [ ] Task 10: Run quality gates (AC: 1.8.10-1.8.11)
  - [ ] Run `go test ./internal/ports/spi` and verify 100% pass
  - [ ] Run `go test ./internal/adapters/spi/config` and verify 100% pass
  - [ ] Run `go test ./tests/integration` and verify integration tests pass
  - [ ] Verify test coverage adequate (>90% for adapter code)
  - [ ] Run `golangci-lint run --fix internal/ports/spi` and fix any issues
  - [ ] Run `golangci-lint run --fix internal/adapters/spi/config` and fix any issues
  - [ ] Verify zero linting warnings across all affected code
  - [ ] Linting checkpoint:
    - [ ] Final sweep: `golangci-lint run --fix internal/ports/spi internal/adapters/spi/config`
    - [ ] Verify ALL warnings resolved
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 11: Commit changes (AC: 1.8.12)
  - [ ] Review all changes for completeness
  - [ ] Stage files:
    - [ ] `git add internal/ports/spi/config.go`
    - [ ] `git add internal/adapters/spi/config/viper.go`
    - [ ] `git add internal/adapters/spi/config/viper_test.go`
    - [ ] `git add tests/integration/config_test.go`
    - [ ] `git add testdata/vault/lithos.json`
  - [ ] Commit with message: `feat: implement config loading with ConfigPort and ViperAdapter`
  - [ ] Verify commit includes all necessary files
  - [ ] Linting checkpoint:
    - [ ] Run pre-commit hooks if installed
    - [ ] Verify commit message follows conventional commits format

## Dev Notes

### QA Test Design Reference

**Test Design Document:** `docs/qa/assessments/1.8-test-design-20251028.md`

This story incorporates all 18 test scenarios identified in the QA test design:
- 12 unit tests, 5 integration tests, 1 e2e test covering ConfigPort interface and ViperAdapter implementation
- 10 P0 priority scenarios for critical config loading functionality, 6 P1 for standard features, 2 P2 for edge cases
- Test coverage ensures proper viper integration, precedence handling, and validation

**Note:** The detailed test scenarios in AC1.8.8-1.8.10 and Tasks 1-9 are derived from this QA analysis.

### ConfigPort Architecture

From `docs/architecture/components.md#spi-port-interfaces`:

**ConfigPort Responsibility:** Load and expose resolved configuration (vault path, directories, log level) to domain services and adapters.

**Key Interfaces:**
- `Load(ctx context.Context) (Config, error)` - Load config from `lithos.json`, env vars, and CLI flags with precedence

**Dependencies:** Implemented by ViperAdapter.

**Technology Stack:** `github.com/spf13/viper`, precedence: CLI flags > env vars > config file > defaults, searches upward from CWD for `lithos.json`.

**Note:** Config is value object (immutable). Loaded once at startup. Post-MVP: Add `Reload()` for dynamic config updates.

[Source: docs/architecture/components.md#configport]

From `docs/architecture/components.md#spi-adapters`:

**ViperAdapter Responsibility:** Implement `ConfigPort` by loading configuration from `lithos.json`, environment variables, and CLI flags with proper precedence.

**Key Interfaces:**
- `Load(ctx context.Context) (Config, error)` - Load and resolve configuration from all sources

**Dependencies:** `github.com/spf13/viper`, Go `os`, `filepath`, Logger.

**Technology Stack:** Viper configuration bindings, precedence: CLI flags > env vars > config file > defaults, searches upward from CWD for `lithos.json`, environment variable mapping (e.g., `LITHOS_VAULT_PATH`).

**Note:** Config is immutable value object - loaded once at startup. Post-MVP: Add `Reload()` for dynamic configuration updates.

[Source: docs/architecture/components.md#viperadapter]

From `docs/architecture/tech-stack.md`:

**Configuration:** `github.com/spf13/viper` v1.21.0
- Seamless Cobra integration, supports YAML/ENV/flags hierarchy
- PRD explicitly specifies
- Handles `lithos.yaml` directory traversal search
- Latest release Sep 2025

[Source: docs/architecture/tech-stack.md]

### ViperAdapter Implementation Patterns

**Upward Config Search Pattern:**
```go
func searchConfigFile() (string, error) {
    dir, err := os.Getwd()
    if err != nil {
        return "", err
    }

    for {
        configPath := filepath.Join(dir, "lithos.json")
        if _, err := os.Stat(configPath); err == nil {
            return dir, nil // Found config, return directory
        }

        parent := filepath.Dir(dir)
        if parent == dir {
            // Reached root, no config found
            return "", os.ErrNotExist
        }
        dir = parent
    }
}
```

**Load Method with Precedence:**
```go
func (a *ViperAdapter) Load(ctx context.Context) (Config, error) {
    // 1. Start with defaults
    cfg := DefaultConfig()

    // 2. Search for config file
    vaultPath, err := searchConfigFile()
    if err == nil {
        // Found config file, load it
        v := viper.New()
        v.SetConfigName("lithos")
        v.SetConfigType("json")
        v.AddConfigPath(vaultPath)

        if err := v.ReadInConfig(); err == nil {
            // Override defaults with config file values
            cfg.VaultPath = v.GetString("vault_path")
            cfg.TemplatesDir = v.GetString("templates_dir")
            // ... etc
        }
    } else {
        // No config file, use CWD as VaultPath
        cwd, _ := os.Getwd()
        cfg.VaultPath = cwd
    }

    // 3. Override with environment variables
    if val := os.Getenv("LITHOS_VAULT_PATH"); val != "" {
        cfg.VaultPath = val
    }
    // ... etc for other env vars

    // 4. Validate VaultPath
    if err := validateVaultPath(cfg.VaultPath); err != nil {
        return Config{}, err
    }

    return cfg, nil
}
```

**VaultPath Validation:**
```go
func validateVaultPath(path string) error {
    info, err := os.Stat(path)
    if err != nil {
        return fmt.Errorf("vault path does not exist: %w", err)
    }
    if !info.IsDir() {
        return fmt.Errorf("vault path is not a directory: %s", path)
    }
    return nil
}
```

**Environment Variable Mapping:**
```go
// Viper automatic env binding
v.SetEnvPrefix("LITHOS")
v.AutomaticEnv()

// Maps:
// LITHOS_VAULT_PATH → VaultPath
// LITHOS_TEMPLATES_DIR → TemplatesDir
// LITHOS_SCHEMAS_DIR → SchemasDir
// LITHOS_PROPERTY_BANK_FILE → PropertyBankFile
// LITHOS_CACHE_DIR → CacheDir
// LITHOS_LOG_LEVEL → LogLevel
```

### Configuration Precedence

**Precedence Order (highest to lowest):**
1. **CLI flags** (not implemented in Epic 1, reserved for future)
2. **Environment variables** (LITHOS_*)
3. **Config file** (lithos.json found via upward search)
4. **Defaults** (from Config.DefaultConfig())

**Example Precedence:**
```bash
# Defaults
VaultPath: "."

# Config file overrides defaults
VaultPath: "/path/to/vault" (from lithos.json)

# Environment overrides config file
LITHOS_VAULT_PATH=/different/vault (overrides lithos.json)

# CLI flags would override all (future)
--vault-path=/cli/vault (not implemented yet)
```

### Testing Standards

From `docs/architecture/testing-strategy.md`:

- Unit tests live beside code (`*_test.go`)
- Integration tests in `tests/integration/` when requiring fixtures
- Test config loading precedence order
- Test upward directory search behavior
- Test validation (VaultPath exists, is directory)
- Use testdata for sample config files

### File Locations

- Port: `internal/ports/spi/config.go`
- Adapter: `internal/adapters/spi/config/viper.go`
- Tests: `internal/adapters/spi/config/viper_test.go`
- Integration: `tests/integration/config_test.go` (if needed)
- Testdata: `testdata/vault/lithos.json`

### Implementation Notes

**Key Requirements:**

1. **Hexagonal Architecture:** ConfigPort defines contract, ViperAdapter implements
2. **Upward Search:** Search from CWD to filesystem root for lithos.json
3. **Precedence:** Env vars > config file > defaults (CLI flags reserved)
4. **Validation:** VaultPath must exist and be directory
5. **Immutability:** Config loaded once at startup, never modified

**Design Decisions:**

- **JSON Format:** lithos.json uses JSON format for MVP simplicity
- **Filename Search:** Search stops at first lithos.json found
- **VaultPath Resolution:** Directory containing lithos.json becomes VaultPath
- **Fallback:** Use CWD as VaultPath if no config file found
- **Environment Variables:** LITHOS_* prefix for all config overrides

**Error Handling:**

- Config file parse errors should be logged but not fatal (fall back to defaults)
- VaultPath validation errors are fatal (app cannot run without valid vault)
- Missing config file is not an error (use defaults + CWD)

### Refactoring Guidelines

**SRP Decomposition Examples:**

For this story (config loading infrastructure), functions should be decomposed into focused helpers following SRP:

**searchConfigFile() Decomposition:**
- `getCurrentDir() (string, error)` - Get current working directory with error handling
- `configExistsInDir(dir string) bool` - Check if lithos.json exists in directory
- `getParentDir(dir string) string` - Get parent directory for traversal
- `isRootDir(dir string) bool` - Detect filesystem root
- `searchConfigFile()` orchestrates these helpers for upward search

**Load() Method Decomposition:**
- `loadDefaults() Config` - Load default configuration (single responsibility: defaults)
- `loadConfigFile(dir string) (Config, error)` - Read and parse lithos.json file
- `parseConfigJSON(data []byte) (Config, error)` - Unmarshal JSON to Config struct
- `loadEnvironmentVars() Config` - Read all LITHOS_* environment variables
- `mergeConfigs(base, override Config) Config` - Apply precedence rules
- `Load()` orchestrates these helpers following precedence order

**validateVaultPath() Decomposition:**
- `pathExists(path string) bool` - Check if path exists on filesystem
- `isDirectory(path string) bool` - Verify path is directory not file
- `validateVaultPath(path string) error` - Orchestrate validation checks

**When to Decompose:**
- If any method exceeds 15 lines, consider extraction
- If a method has >2 concerns, extract helpers (e.g., Load handles defaults, file, env, validation → extract each)
- Extract pure functions (no side effects) for easier testing
- Config file reading, parsing, and validation should be separate functions

**Naming Standards:**
- Exported types: PascalCase (ConfigPort, ViperAdapter)
- Constructors: NewTypeName (NewViperAdapter)
- Private helpers: camelCase (loadDefaults, parseConfigJSON, validateVaultPath)
- Methods: PascalCase for exported (Load), camelCase for private
- Boolean helpers: is/has prefix (isDirectory, configExistsInDir)

**Documentation Requirements:**
- Package comment at top of viper.go explaining adapter purpose
- All exported types and methods have GoDoc comments
- Private helpers have GoDoc or inline comments explaining purpose
- Complex logic (precedence order, upward search) documented with inline comments
- Document error conditions and fallback behavior
- Reference architecture docs where relevant (ConfigPort responsibilities)

**Error Handling Patterns:**
- Config file not found: NOT an error, use defaults + CWD
- Config file parse error: Log warning, fall back to defaults
- VaultPath validation failure: Return error (fatal - app cannot run)
- Environment variable errors: Ignore invalid values, log warning

**Testing Decomposition:**
- Each helper function should have dedicated unit tests
- Test helpers in isolation before testing orchestrating functions
- Use table-driven tests for multiple scenarios
- Integration tests verify end-to-end precedence behavior

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 1 requirements | Bob (Scrum Master) |
| 2025-10-28 | 1.1 | Enhanced with full TDD framework, SRP decomposition, linting checkpoints | QA Specialist |

## Dev Agent Record

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
