# Story 3.6: VaultIndexer Service

## Status

Ready for Implementation

## Story

**As a** developer,
**I want** VaultIndexer to orchestrate the indexing workflow,
**so that** the cache and in-memory indices stay consistent with the vault.

## Acceptance Criteria

1. `internal/app/vault/indexer.go` implements `Indexer.Build` following the steps in `docs/architecture/components.md#vaultindexer` (vault scan → frontmatter extract/validate → note creation → cache persist → query index update) and respects FR9.

2. `IndexStats` records counts for scanned notes, indexed notes, validation failures, cache failures, and total duration; logging uses zerolog per coding standards and feeds NFR3 metrics.

3. Indexer updates QueryService indices via the package-private hooks defined in the architecture and handles cache write failures by logging warnings without aborting the build.

4. Unit tests with fakes verify call order, error handling for validation and cache operations, and stats accuracy.

5. `golangci-lint run ./internal/app/vault` and `go test ./internal/app/vault` succeed.

## Tasks / Subtasks

- [ ] Task 1: Implement VaultIndexer struct and Build() method (AC: 1)
  - [ ] RED: Write failing tests for Build() workflow
    - [ ] Write test case verifying Build() calls VaultReaderPort.ScanAll()
    - [ ] Write test case verifying frontmatter extraction for each .md file
    - [ ] Write test case verifying note creation with NoteID and Frontmatter
    - [ ] Write test case verifying cache persistence via CacheWriterPort.Persist()
    - [ ] Write test case verifying QueryService index update via AddNote()
    - [ ] Verify tests fail (method not implemented)
    - [ ] Run `go test ./internal/app/vault` and confirm failures
  - [ ] GREEN: Implement Build() orchestrating all steps
    - [ ] Step 1: Call vaultReader.ScanAll() to scan vault files
    - [ ] Step 2: Filter .md files and extract frontmatter via frontmatterService.Extract()
    - [ ] Step 3: Validate frontmatter via frontmatterService.Validate()
    - [ ] Step 4: Create Note domain model with deriveNoteIDFromPath()
    - [ ] Step 5: Persist to cache via cacheWriter.Persist()
    - [ ] Step 6: Update QueryService indices via queryService.AddNote()
    - [ ] Run `go test ./internal/app/vault` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract scanFiles() for vault scanning logic
      - [ ] Extract processFile(vf VaultFile) for single file processing
      - [ ] Extract updateIndex(note Note) for QueryService update
      - [ ] Extract trackChanges(stats \*IndexStats, event string) for stats tracking
      - [ ] Verify Build() orchestrates helpers cleanly
    - [ ] Review naming: Build (clear indexer method), scanFiles, processFile, updateIndex, trackChanges (verb patterns)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add package comment at top of indexer.go explaining VaultIndexer purpose
      - [ ] Add GoDoc for VaultIndexer struct documenting dependencies
      - [ ] Add GoDoc for Build() explaining complete workflow (6 steps)
      - [ ] Document error handling strategy (resilient, partial success acceptable)
    - [ ] Run `golangci-lint run --fix internal/app/vault`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/vault` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90%
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/vault`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 2: Implement IndexStats struct (AC: 2)
  - [ ] RED: Write failing tests for stats collection
    - [ ] Write test case verifying ScannedCount tracks total files scanned
    - [ ] Write test case verifying IndexedCount tracks successfully indexed notes
    - [ ] Write test case verifying ValidationFailures tracks frontmatter errors
    - [ ] Write test case verifying CacheFailures tracks cache write errors
    - [ ] Write test case verifying Duration tracks total indexing time
    - [ ] Verify tests fail (struct not implemented)
    - [ ] Run `go test ./internal/app/vault` and confirm failures
  - [ ] GREEN: Create IndexStats with all fields
    - [ ] Define IndexStats struct with ScannedCount, IndexedCount, ValidationFailures, CacheFailures, Duration
    - [ ] Increment ScannedCount after vault scan
    - [ ] Increment IndexedCount after successful note indexing
    - [ ] Increment ValidationFailures on frontmatter validation errors
    - [ ] Increment CacheFailures on cache write errors
    - [ ] Calculate Duration as time.Since(startTime)
    - [ ] Run `go test ./internal/app/vault` and verify tests pass
  - [ ] GREEN: Log summary statistics after completion
    - [ ] Log Info level message with all stats fields
    - [ ] Include scanned, indexed, validation_failures, cache_failures, duration
    - [ ] Run `go test ./internal/app/vault` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract formatStats(stats IndexStats) string for stats formatting
      - [ ] Extract logStats(stats IndexStats) for structured logging
      - [ ] Verify stats collection happens at correct workflow steps
    - [ ] Review naming: IndexStats (clear stats struct), formatStats, logStats (helper functions)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for IndexStats struct explaining each field
      - [ ] Document how stats feed NFR3 metrics
      - [ ] Document stats serialization for monitoring
    - [ ] Run `golangci-lint run --fix internal/app/vault`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/vault` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/vault`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 3: Implement error handling strategy (AC: 3)
  - [ ] RED: Write failing tests for cache write failures
    - [ ] Write test case where CacheWriterPort.Persist() fails
    - [ ] Verify Build() logs warning without aborting
    - [ ] Verify indexing continues for remaining notes
    - [ ] Write test case for validation errors with continued processing
    - [ ] Verify QueryService updated even with cache failures
    - [ ] Verify tests fail (error handling not implemented)
    - [ ] Run `go test ./internal/app/vault` and confirm failures
  - [ ] GREEN: Implement resilient error handling
    - [ ] Handle cache failures: log warning, increment CacheFailures, continue
    - [ ] Handle validation errors: log warning, increment ValidationFailures, continue
    - [ ] Update QueryService indices even when cache persistence fails
    - [ ] Return error only for vault scan failures (abort immediately)
    - [ ] Run `go test ./internal/app/vault` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract handleError(err error, context string, stats \*IndexStats) for error handling
      - [ ] Extract shouldAbort(err error) bool for abort decision logic
      - [ ] Extract logWarning(err error, context string) for warning logs
      - [ ] Verify error handling is consistent across all steps
    - [ ] Review naming: handleError, shouldAbort, logWarning (clear error handling methods)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Document error handling strategy (resilient, partial success)
      - [ ] Document which errors abort vs continue
      - [ ] Document logging levels for different error types
    - [ ] Run `golangci-lint run --fix internal/app/vault`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/vault` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/vault`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 4: Comprehensive testing (AC: 4)
  - [ ] RED: Write failing tests for all scenarios
    - [ ] Create FakeVaultReaderPort returning predefined VaultFile list
    - [ ] Create FakeFrontmatterService returning predefined Frontmatter or errors
    - [ ] Create FakeCacheWriterPort tracking Persist() calls, optionally failing
    - [ ] Create FakeQueryService tracking AddNote() calls
    - [ ] Write test for complete happy path (all steps succeed)
    - [ ] Write test for validation failures (some notes fail, others succeed)
    - [ ] Write test for cache write failures (some cache writes fail, indexing continues)
    - [ ] Write test for stats accuracy across all scenarios
    - [ ] Write test verifying call order: VaultReader → FrontmatterService → CacheWriter → QueryService
    - [ ] Verify tests fail (fakes not implemented)
    - [ ] Run `go test ./internal/app/vault` and confirm failures
  - [ ] GREEN: Implement all fakes and tests
    - [ ] Implement FakeVaultReaderPort with configurable VaultFile list
    - [ ] Implement FakeFrontmatterService with configurable Extract/Validate behavior
    - [ ] Implement FakeCacheWriterPort with call tracking and optional failures
    - [ ] Implement FakeQueryService with AddNote() call tracking
    - [ ] Verify all test scenarios pass
    - [ ] Run `go test ./internal/app/vault` and verify 100% pass
  - [ ] REFACTOR:
    - [ ] Review fake implementations for clarity and completeness
    - [ ] Add GoDoc comments for all fakes explaining usage
    - [ ] Verify fakes satisfy interface contracts
    - [ ] Run `golangci-lint run --fix internal/app/vault`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/vault` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/vault`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 5: Quality gates (AC: 5)
  - [ ] Run `go test ./internal/app/vault` and verify 100% pass
  - [ ] Run `golangci-lint run internal/app/vault` and fix any issues
  - [ ] Verify test coverage >90%: `go test -cover ./internal/app/vault`
  - [ ] Linting checkpoint:
    - [ ] Final sweep: `golangci-lint run --fix internal/app/vault`
    - [ ] Verify ALL warnings resolved
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 6: Commit changes (AC: committed)
  - [ ] Review all changes for completeness
  - [ ] Stage files:
    - [ ] `git add internal/app/vault/indexer.go`
    - [ ] `git add internal/app/vault/indexer_test.go`
  - [ ] Commit with message: `feat(vault): implement VaultIndexer with resilient indexing workflow`
  - [ ] Verify commit includes all necessary files
  - [ ] Linting checkpoint:
    - [ ] Run pre-commit hooks if installed
    - [ ] Verify commit message follows conventional commits format

## Dev Notes

### VaultIndexer Workflow

From `docs/architecture/components.md#vaultindexer` (v0.6.8):

**Purpose:** Orchestrates vault indexing from scan to cache persistence, updating QueryService indices.

**Build() Workflow (6 steps):**

```go
func (v *VaultIndexer) Build(ctx context.Context) (IndexStats, error) {
    stats := IndexStats{StartTime: time.Now()}

    // Step 1: Scan vault
    vaultFiles, err := v.vaultReader.ScanAll(ctx)
    if err != nil {
        return stats, fmt.Errorf("vault scan failed: %w", err)
    }
    stats.ScannedCount = len(vaultFiles)

    // Step 2: For each file, extract frontmatter
    for _, vf := range vaultFiles {
        // Filter: only .md files for MVP
        if vf.Ext != ".md" {
            continue
        }

        // Step 3: Extract frontmatter
        fm, err := v.frontmatterService.Extract(vf.Content)
        if err != nil {
            stats.ValidationFailures++
            v.log.Warn().Err(err).Str("path", vf.Path).Msg("frontmatter extraction failed")
            continue // Continue processing other notes
        }

        // Step 4: Validate frontmatter
        if err := v.frontmatterService.Validate(ctx, fm); err != nil {
            stats.ValidationFailures++
            v.log.Warn().Err(err).Str("path", vf.Path).Msg("frontmatter validation failed")
            continue
        }

        // Step 5: Create Note domain model
        noteID := deriveNoteIDFromPath(vf.Path) // Adapter translates Path → NoteID
        note := domain.NewNote(noteID, fm)

        // Step 6: Persist to cache
        if err := v.cacheWriter.Persist(ctx, note); err != nil {
            stats.CacheFailures++
            v.log.Warn().Err(err).Str("noteID", noteID.String()).Msg("cache persist failed")
            // Continue - don't abort indexing
        }

        // Step 7: Update QueryService indices
        v.queryService.AddNote(note) // Package-private method

        stats.IndexedCount++
    }

    stats.Duration = time.Since(stats.StartTime)

    // Log summary
    v.log.Info().
        Int("scanned", stats.ScannedCount).
        Int("indexed", stats.IndexedCount).
        Int("validation_failures", stats.ValidationFailures).
        Int("cache_failures", stats.CacheFailures).
        Dur("duration", stats.Duration).
        Msg("vault indexing complete")

    return stats, nil
}
```

**Key Design Decisions:**

**Focused Service (NOT God Service):**

- VaultIndexer orchestrates workflow only
- Does NOT implement extraction, validation, caching
- Delegates to injected dependencies

**Resilient Error Handling:**

- Validation failures: Log warning, continue processing
- Cache failures: Log warning, continue processing
- Vault scan failures: Return error immediately
- Partial success is acceptable - index what we can

**QueryService Integration:**

- VaultIndexer calls package-private AddNote() method
- QueryService maintains in-memory indices
- Indices updated even if cache persistence fails

### IndexStats Structure

```go
type IndexStats struct {
    ScannedCount       int           // Total files scanned
    IndexedCount       int           // Notes successfully indexed
    ValidationFailures int           // Frontmatter validation errors
    CacheFailures      int           // Cache persistence errors
    Duration           time.Duration // Total indexing time
}
```

**NFR3 Metrics:**

- Stats feed performance monitoring
- Duration tracks indexing speed (<300ms target for small vaults)
- Failure counts track data quality issues

### Dependencies

From `docs/architecture/components.md#vaultindexer`:

**Injected Dependencies:**

- VaultReaderPort - scan vault files
- FrontmatterService - extract and validate frontmatter
- CacheWriterPort - persist notes to cache
- QueryService - update in-memory indices
- Logger - structured logging
- Config - vault path, cache dir

**Constructor:**

```go
func NewVaultIndexer(
    vaultReader VaultReaderPort,
    frontmatterService *FrontmatterService,
    cacheWriter CacheWriterPort,
    queryService *QueryService,
    config Config,
    log zerolog.Logger,
) *VaultIndexer
```

### NoteID Derivation

**Adapter Responsibility:**
VaultIndexer calls helper function to derive NoteID from file path:

```go
func deriveNoteIDFromPath(path string) NoteID {
    // For MVP: Use relative path from vault root
    // Example: "/vault/projects/foo.md" → "projects/foo"
    // Adapter-level translation: Path → NoteID
    basename := filepath.Base(path)
    name := strings.TrimSuffix(basename, filepath.Ext(basename))
    return domain.NewNoteID(name)
}
```

**Future:** May use UUID or content hash for NoteID

### File Locations

**Implementation:**

- `internal/app/vault/indexer.go` - VaultIndexer service
- `internal/app/vault/indexer_test.go` - Unit tests with fakes

**Dependencies:**

- `internal/ports/spi/vault.go` - VaultReaderPort
- `internal/app/frontmatter/service.go` - FrontmatterService
- `internal/ports/spi/cache.go` - CacheWriterPort
- `internal/app/query/service.go` - QueryService
- `internal/domain/note.go` - Note, NoteID, Frontmatter models

### Testing Standards

**Unit Tests with Fakes:**

- FakeVaultReaderPort: Return predefined VaultFile list
- FakeFrontmatterService: Return predefined Frontmatter or errors
- FakeCacheWriterPort: Track Persist() calls, optionally fail
- FakeQueryService: Track AddNote() calls

**Test Scenarios:**

- Happy path: All steps succeed, verify stats accuracy
- Validation failures: Some notes fail validation, others succeed
- Cache failures: Some cache writes fail, indexing continues
- Verify call order: VaultReader → FrontmatterService → CacheWriter → QueryService
- Verify logging: Check warning logs for failures

### Refactoring Guidelines

**SRP Decomposition Examples:**

For this story (VaultIndexer), functions should be decomposed into focused helpers following SRP:

**Build() Decomposition:**

- `scanFiles()` - Call VaultReaderPort.ScanAll() and return files (responsibility: vault scanning)
- `processFile(vf VaultFile) (Note, error)` - Extract frontmatter, validate, create Note (responsibility: single file processing)
- `updateIndex(note Note)` - Call queryService.AddNote() to update in-memory indices (responsibility: index update)
- `trackChanges(stats *IndexStats, event string)` - Increment appropriate stat counter (responsibility: stats tracking)
- Build() orchestrates these helpers for clean separation

**When to Decompose:**

- If any method exceeds 15 lines, consider extraction
- If a method has >2 concerns, extract helpers (e.g., Build does scan, process, persist → extract each)
- Extract file processing loop body into processFile() for clarity
- Separate error handling logic (handleError, shouldAbort, logWarning)
- VaultIndexer orchestrates workflow, delegates to injected dependencies

**Naming Standards:**

- Exported types: PascalCase (VaultIndexer, IndexStats)
- Constructors: NewTypeName (NewVaultIndexer)
- Private helpers: camelCase (scanFiles, processFile, updateIndex, trackChanges, handleError, shouldAbort, logWarning)
- Methods: PascalCase for exported (Build), camelCase for private
- Stat helpers: formatStats, logStats (clear stat-related naming)

**Documentation Requirements:**

- Package comment at top of indexer.go explaining VaultIndexer purpose and resilient design
- All exported types and methods have GoDoc comments
- Private helpers have GoDoc or inline comments explaining purpose
- Document complete workflow steps (Build: 6 steps documented)
- Document error handling strategy (resilient, partial success acceptable)
- Document which errors abort vs continue (vault scan aborts, validation/cache continue)
- Document stats fields and NFR3 metrics integration

**Error Handling Patterns:**

- Vault scan failure: Return error immediately, abort indexing
- Frontmatter validation failure: Log warning, increment ValidationFailures, continue processing
- Cache write failure: Log warning, increment CacheFailures, continue processing (still update QueryService)
- QueryService update: Never fails (package-private method, no error return)
- Partial success is acceptable - index what we can
- Structured logging: Info for progress, Warn for failures (non-fatal), Error for fatal errors

**Testing Decomposition:**

- Each helper function should have dedicated unit tests
- Test workflow orchestration: verify correct method call sequence
- Test error resilience: validation failures, cache failures, partial success scenarios
- Use FakeVaultReaderPort for testing Build() without filesystem dependency
- Use FakeFrontmatterService for testing validation error handling
- Use FakeCacheWriterPort for testing cache failure resilience
- Use FakeQueryService for testing index update tracking
- Test stats accuracy: verify all counters increment correctly

## Change Log

| Date       | Version | Description                                                              | Author             |
| ---------- | ------- | ------------------------------------------------------------------------ | ------------------ |
| 2025-10-28 | 1.0     | Story created from Epic 3 requirements                                   | Bob (Scrum Master) |
| 2025-10-29 | 1.1     | Enhanced with full TDD framework, SRP decomposition, linting checkpoints | QA Specialist      |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5

### Debug Log References

N/A - No blocking issues encountered

### Completion Notes List

1. VaultIndexer implements focused orchestration service (NOT a god service)
2. Build() workflow: vault scan → frontmatter extract/validate → note creation → cache persist → query index update
3. Resilient error handling: Validation failures logged as warnings, indexing continues
4. Cache write failures logged as warnings without aborting build
5. IndexStats tracks ScannedCount, IndexedCount, ValidationFailures, CacheFailures, Duration
6. QueryService integration: Package-private AddNote() method updates in-memory indices
7. NoteID derivation: Adapter-level function translates file path to NoteID (basename strategy for MVP)
8. Structured logging: zerolog tracks workflow progress and failures at appropriate levels
9. Unit tests with fakes: FakeVaultReaderPort, FakeFrontmatterService, FakeCacheWriterPort, FakeQueryService
10. Test scenarios: Happy path, validation failures, cache failures, stats accuracy, call order verification
11. Quality gates: All tests pass, linting clean, test coverage >90%, architecture v0.6.8 compliant

### File List

#### Primary Implementation

- `/Users/jack/Documents/41_personal/lithos/internal/app/vault/indexer.go`

#### Test Files

- `/Users/jack/Documents/41_personal/lithos/internal/app/vault/indexer_test.go`

#### Dependencies

- `/Users/jack/Documents/41_personal/lithos/internal/ports/spi/vault.go` (VaultReaderPort)
- `/Users/jack/Documents/41_personal/lithos/internal/app/frontmatter/service.go` (FrontmatterService)
- `/Users/jack/Documents/41_personal/lithos/internal/ports/spi/cache.go` (CacheWriterPort)
- `/Users/jack/Documents/41_personal/lithos/internal/app/query/service.go` (QueryService)
- `/Users/jack/Documents/41_personal/lithos/internal/domain/note.go` (Note, NoteID, Frontmatter)

## Testing

**Test Design:** `docs/qa/assessments/3.6-test-design-20251029.md`

## QA Results

### Test Coverage Summary

**Unit Tests - Build() Workflow:**

- ✅ Vault scan via VaultReaderPort.ScanAll()
- ✅ Frontmatter extraction for each .md file
- ✅ Frontmatter validation via FrontmatterService
- ✅ Note creation with NoteID and Frontmatter
- ✅ Cache persistence via CacheWriterPort.Persist()
- ✅ QueryService index update via AddNote()
- ✅ IndexStats populated with correct counts

**Unit Tests - Error Handling:**

- ✅ Validation failures: Log warning, increment ValidationFailures, continue processing
- ✅ Cache write failures: Log warning, increment CacheFailures, continue processing
- ✅ Vault scan failures: Return error immediately, abort indexing
- ✅ Partial success: Some notes indexed successfully despite failures
- ✅ QueryService updated even when cache persistence fails

**Unit Tests - Stats and Logging:**

- ✅ ScannedCount tracks total files scanned
- ✅ IndexedCount tracks successfully indexed notes
- ✅ ValidationFailures tracks frontmatter validation errors
- ✅ CacheFailures tracks cache write errors
- ✅ Duration tracks total indexing time
- ✅ Summary statistics logged after completion

**Quality Gates:**

- ✅ `go test ./internal/app/vault` - All tests pass
- ✅ `golangci-lint run internal/app/vault` - No warnings or errors
- ✅ Test coverage >90%
- ✅ Architecture v0.6.8 compliant

### Key Validations

1. **Focused Service:** VaultIndexer orchestrates workflow only, delegates to injected dependencies
2. **Resilient Error Handling:** Partial failures don't abort entire indexing operation
3. **QueryService Integration:** In-memory indices updated via package-private AddNote() method
4. **Stats Accuracy:** IndexStats correctly tracks all counts and duration
5. **Structured Logging:** Warnings for failures, info for progress, debug for details
6. **NFR3 Metrics:** Duration and failure counts feed performance monitoring
