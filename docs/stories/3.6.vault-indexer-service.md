# Story 3.6: VaultIndexer Service

## Status

Draft

## Story

**As a** developer,
**I want** VaultIndexer to orchestrate the indexing workflow,
**so that** the cache and in-memory indices stay consistent with the vault.

## Acceptance Criteria

1. `internal/app/vault/indexer.go` implements `Indexer.Build` following the steps in `docs/architecture/components.md#vaultindexer` (vault scan → frontmatter extract/validate → note creation → cache persist → query index update) and respects FR9.

2. `IndexStats` records counts for scanned notes, indexed notes, validation failures, cache failures, and total duration; logging uses zerolog per coding standards and feeds NFR3 metrics.

3. Indexer updates QueryService indices via the package-private hooks defined in the architecture and handles cache write failures by logging warnings without aborting the build.

4. Unit tests with fakes verify call order, error handling for validation and cache operations, and stats accuracy.

5. `golangci-lint run ./internal/app/vault` and `go test ./internal/app/vault` succeed.

## Tasks / Subtasks

- [ ] Task 1: Implement VaultIndexer struct and Build() method (AC: 1)
  - [ ] RED: Write failing tests for Build() workflow
  - [ ] RED: Test vault scanning step
  - [ ] RED: Test frontmatter extraction/validation step
  - [ ] RED: Test note creation step
  - [ ] RED: Test cache persistence step
  - [ ] RED: Test query index update step
  - [ ] GREEN: Implement Build() orchestrating all steps
  - [ ] GREEN: Integrate VaultReaderPort, FrontmatterService, CacheWriterPort, QueryService
  - [ ] REFACTOR: Add structured logging at each step

- [ ] Task 2: Implement IndexStats struct (AC: 2)
  - [ ] RED: Write failing tests for stats collection
  - [ ] GREEN: Create IndexStats with fields: ScannedCount, IndexedCount, ValidationFailures, CacheFailures, Duration
  - [ ] GREEN: Increment stats at appropriate workflow steps
  - [ ] GREEN: Log summary statistics after completion
  - [ ] REFACTOR: Add stats serialization for metrics (NFR3)

- [ ] Task 3: Implement error handling strategy (AC: 3)
  - [ ] RED: Write failing tests for cache write failures
  - [ ] GREEN: Log warnings for cache failures without aborting
  - [ ] GREEN: Continue indexing remaining notes on validation errors
  - [ ] GREEN: Update QueryService indices even with partial failures
  - [ ] REFACTOR: Ensure resilient error handling

- [ ] Task 4: Comprehensive testing (AC: 4)
  - [ ] Create fakes: FakeVaultReaderPort, FakeFrontmatterService, FakeCacheWriterPort, FakeQueryService
  - [ ] Test complete happy path (all steps succeed)
  - [ ] Test validation failures (continue processing)
  - [ ] Test cache write failures (log warning, continue)
  - [ ] Test stats accuracy across scenarios
  - [ ] Verify call order and dependencies

- [ ] Task 5: Quality gates (AC: 5)
  - [ ] Run `golangci-lint run --fix internal/app/vault`
  - [ ] Run `go test ./internal/app/vault` - verify 100% pass
  - [ ] Verify test coverage >90%

## Dev Notes

### VaultIndexer Workflow

From `docs/architecture/components.md#vaultindexer` (v0.6.8):

**Purpose:** Orchestrates vault indexing from scan to cache persistence, updating QueryService indices.

**Build() Workflow (6 steps):**

```go
func (v *VaultIndexer) Build(ctx context.Context) (IndexStats, error) {
    stats := IndexStats{StartTime: time.Now()}

    // Step 1: Scan vault
    vaultFiles, err := v.vaultReader.ScanAll(ctx)
    if err != nil {
        return stats, fmt.Errorf("vault scan failed: %w", err)
    }
    stats.ScannedCount = len(vaultFiles)

    // Step 2: For each file, extract frontmatter
    for _, vf := range vaultFiles {
        // Filter: only .md files for MVP
        if vf.Ext != ".md" {
            continue
        }

        // Step 3: Extract frontmatter
        fm, err := v.frontmatterService.Extract(vf.Content)
        if err != nil {
            stats.ValidationFailures++
            v.log.Warn().Err(err).Str("path", vf.Path).Msg("frontmatter extraction failed")
            continue // Continue processing other notes
        }

        // Step 4: Validate frontmatter
        if err := v.frontmatterService.Validate(ctx, fm); err != nil {
            stats.ValidationFailures++
            v.log.Warn().Err(err).Str("path", vf.Path).Msg("frontmatter validation failed")
            continue
        }

        // Step 5: Create Note domain model
        noteID := deriveNoteIDFromPath(vf.Path) // Adapter translates Path → NoteID
        note := domain.NewNote(noteID, fm)

        // Step 6: Persist to cache
        if err := v.cacheWriter.Persist(ctx, note); err != nil {
            stats.CacheFailures++
            v.log.Warn().Err(err).Str("noteID", noteID.String()).Msg("cache persist failed")
            // Continue - don't abort indexing
        }

        // Step 7: Update QueryService indices
        v.queryService.AddNote(note) // Package-private method

        stats.IndexedCount++
    }

    stats.Duration = time.Since(stats.StartTime)

    // Log summary
    v.log.Info().
        Int("scanned", stats.ScannedCount).
        Int("indexed", stats.IndexedCount).
        Int("validation_failures", stats.ValidationFailures).
        Int("cache_failures", stats.CacheFailures).
        Dur("duration", stats.Duration).
        Msg("vault indexing complete")

    return stats, nil
}
```

**Key Design Decisions:**

**Focused Service (NOT God Service):**
- VaultIndexer orchestrates workflow only
- Does NOT implement extraction, validation, caching
- Delegates to injected dependencies

**Resilient Error Handling:**
- Validation failures: Log warning, continue processing
- Cache failures: Log warning, continue processing
- Vault scan failures: Return error immediately
- Partial success is acceptable - index what we can

**QueryService Integration:**
- VaultIndexer calls package-private AddNote() method
- QueryService maintains in-memory indices
- Indices updated even if cache persistence fails

### IndexStats Structure

```go
type IndexStats struct {
    ScannedCount       int           // Total files scanned
    IndexedCount       int           // Notes successfully indexed
    ValidationFailures int           // Frontmatter validation errors
    CacheFailures      int           // Cache persistence errors
    Duration           time.Duration // Total indexing time
}
```

**NFR3 Metrics:**
- Stats feed performance monitoring
- Duration tracks indexing speed (<300ms target for small vaults)
- Failure counts track data quality issues

### Dependencies

From `docs/architecture/components.md#vaultindexer`:

**Injected Dependencies:**
- VaultReaderPort - scan vault files
- FrontmatterService - extract and validate frontmatter
- CacheWriterPort - persist notes to cache
- QueryService - update in-memory indices
- Logger - structured logging
- Config - vault path, cache dir

**Constructor:**
```go
func NewVaultIndexer(
    vaultReader VaultReaderPort,
    frontmatterService *FrontmatterService,
    cacheWriter CacheWriterPort,
    queryService *QueryService,
    config Config,
    log zerolog.Logger,
) *VaultIndexer
```

### NoteID Derivation

**Adapter Responsibility:**
VaultIndexer calls helper function to derive NoteID from file path:

```go
func deriveNoteIDFromPath(path string) NoteID {
    // For MVP: Use relative path from vault root
    // Example: "/vault/projects/foo.md" → "projects/foo"
    // Adapter-level translation: Path → NoteID
    basename := filepath.Base(path)
    name := strings.TrimSuffix(basename, filepath.Ext(basename))
    return domain.NewNoteID(name)
}
```

**Future:** May use UUID or content hash for NoteID

### File Locations

**Implementation:**
- `internal/app/vault/indexer.go` - VaultIndexer service
- `internal/app/vault/indexer_test.go` - Unit tests with fakes

**Dependencies:**
- `internal/ports/spi/vault.go` - VaultReaderPort
- `internal/app/frontmatter/service.go` - FrontmatterService
- `internal/ports/spi/cache.go` - CacheWriterPort
- `internal/app/query/service.go` - QueryService
- `internal/domain/note.go` - Note, NoteID, Frontmatter models

### Testing Standards

**Unit Tests with Fakes:**
- FakeVaultReaderPort: Return predefined VaultFile list
- FakeFrontmatterService: Return predefined Frontmatter or errors
- FakeCacheWriterPort: Track Persist() calls, optionally fail
- FakeQueryService: Track AddNote() calls

**Test Scenarios:**
- Happy path: All steps succeed, verify stats accuracy
- Validation failures: Some notes fail validation, others succeed
- Cache failures: Some cache writes fail, indexing continues
- Verify call order: VaultReader → FrontmatterService → CacheWriter → QueryService
- Verify logging: Check warning logs for failures

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 3 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
