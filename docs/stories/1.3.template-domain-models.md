# Story 1.3: Implement Template Domain Models (TemplateID, Template)

## Status

Done

## Story

**As a** developer,
**I want** to implement TemplateID and Template domain models in template.go,
**so that** templates are represented as pure domain data without infrastructure concerns.

## Acceptance Criteria

**TemplateID Implementation:**

- 1.3.1: Create `internal/domain/template.go` with TemplateID:
  - Type: `type TemplateID string`
  - Constructor: `NewTemplateID(value string) TemplateID`
  - Method: `String() string` for logging/debugging

**Template Implementation:**

- 1.3.2: Add Template to `internal/domain/template.go`:
  - Field: `ID TemplateID`
  - Field: `Content string` (raw template text)
  - Constructor: `NewTemplate(id TemplateID, content string) Template`
  - NO FilePath field (infrastructure concern)
  - NO Parsed field (caching concern)

**Testing:**

- 1.3.3: Create unit tests in `internal/domain/template_test.go`:
  - Test TemplateID: NewTemplateID creates valid instance, String() returns value, can be used as map key
  - Test Template: NewTemplate constructs with ID and Content, no filesystem dependencies, Template can store Go template syntax in Content

- 1.3.4: All tests pass: `go test ./internal/domain`

- 1.3.5: All linting passes: `golangci-lint run --fix internal/domain`

- 1.3.6: Committed with message: `feat(domain): implement Template domain models (TemplateID, Template)`

## Tasks / Subtasks

- [x] Task 1: Implement TemplateID model (AC: 1.3.1)
  - [x] RED: Write failing test for NewTemplateID constructor
    - [x] Write test case in `internal/domain/template_test.go`
    - [x] Verify test fails with expected error message
    - [x] Run `go test ./internal/domain` and confirm failure
  - [x] RED: Write failing test for String() method
    - [x] Write test case verifying String() returns underlying value
    - [x] Run `go test ./internal/domain` and confirm failure
  - [x] RED: Write failing test for using TemplateID as map key
    - [x] Create test using TemplateID as map[TemplateID]string key
    - [x] Verify compilation and test behavior
    - [x] Run `go test ./internal/domain` and confirm failure
  - [x] GREEN: Implement minimal code to pass tests
    - [x] Implement `type TemplateID string`
    - [x] Implement `NewTemplateID(value string) TemplateID` constructor
    - [x] Implement `String() string` method
    - [x] Run `go test ./internal/domain` and verify all tests pass
    - [x] Verify no other tests broken
  - [x] REFACTOR:
    - [x] Decompose into SRP components (minimal - already simple types):
      - [x] Verify TemplateID type has single responsibility (opaque identifier for template name)
      - [x] Verify constructor has single responsibility (creation)
      - [x] Verify String() method has single responsibility (string conversion)
    - [x] Review naming: type TemplateID (clear), NewTemplateID (idiomatic), String() (standard Go interface)
    - [x] Add comprehensive GoDoc comments:
      - [x] Add package comment at top of template.go if not present
      - [x] Add GoDoc for TemplateID type explaining template name concept
      - [x] Add GoDoc for NewTemplateID constructor
      - [x] Add GoDoc for String() method
    - [x] Run `golangci-lint run --fix internal/domain`
    - [x] Fix ALL linter warnings without using nolint
    - [x] Run `go test ./internal/domain` to verify refactoring didn't break tests
    - [x] Verify test coverage >90% for TemplateID
  - [x] Linting checkpoint:
    - [x] Run `golangci-lint run --fix internal/domain`
    - [x] Fix ALL warnings (no nolint unless absolutely necessary)
    - [x] Document any unavoidable nolint with clear justification

- [x] Task 2: Implement Template model (AC: 1.3.2)
  - [x] RED: Write failing test for NewTemplate constructor
    - [x] Write test case in `internal/domain/template_test.go`
    - [x] Verify test fails with expected error message
    - [x] Run `go test ./internal/domain` and confirm failure
  - [x] RED: Write failing test for Template with Go template syntax
    - [x] Write test storing complex template syntax in Content field
    - [x] Verify template syntax preserved correctly
    - [x] Run `go test ./internal/domain` and confirm failure
  - [x] RED: Write failing test for no FilePath field
    - [x] Write test verifying Template struct has no FilePath field
    - [x] Use reflection or type checks to verify structure
    - [x] Run `go test ./internal/domain` and confirm failure
  - [x] RED: Write failing test for no Parsed field
    - [x] Write test verifying Template struct has no Parsed field
    - [x] Use reflection or type checks to verify structure
    - [x] Run `go test ./internal/domain` and confirm failure
  - [x] GREEN: Implement minimal code to pass tests
    - [x] Implement Template struct with ID and Content fields ONLY
    - [x] Implement `NewTemplate(id, content) Template` constructor
    - [x] Run `go test ./internal/domain` and verify all tests pass
    - [x] Verify no other tests broken
  - [x] REFACTOR:
    - [x] Decompose into SRP components:
      - [x] Verify Template struct has single responsibility (hold template data)
      - [x] Verify NewTemplate constructor has single responsibility (create Template)
      - [x] Verify NO infrastructure concerns (paths, timestamps, parse trees)
    - [x] Review naming:
      - [x] Template (clear domain aggregate)
      - [x] ID field (clear identifier)
      - [x] Content field (clear: raw template text)
      - [x] NewTemplate (idiomatic constructor)
    - [x] Add comprehensive GoDoc comments:
      - [x] Add GoDoc for Template struct explaining pure data structure pattern
      - [x] Add GoDoc for ID field (template name for identification and composition)
      - [x] Add GoDoc for Content field (raw template text with Go text/template syntax)
      - [x] Add GoDoc for NewTemplate constructor
      - [x] Add comment explaining why FilePath and Parsed are NOT included (architecture alignment)
    - [x] Run `golangci-lint run --fix internal/domain`
    - [x] Fix ALL linter warnings without using nolint
    - [x] Run `go test ./internal/domain` to verify refactoring didn't break tests
    - [x] Verify test coverage >90% for Template
  - [x] Linting checkpoint:
    - [x] Run `golangci-lint run --fix internal/domain`
    - [x] Fix ALL warnings (no nolint unless absolutely necessary)
    - [x] Document any unavoidable nolint with clear justification

- [x] Task 3: Run quality gates (AC: 1.3.4-1.3.5)
  - [x] Run `go test ./internal/domain` and verify 100% pass
  - [x] Run `golangci-lint run --fix internal/domain` and fix any issues
  - [x] Verify test coverage is adequate (>90% for domain models)
  - [x] Linting checkpoint:
    - [x] Run `golangci-lint run --fix internal/domain`
    - [x] Fix ALL warnings (no nolint unless absolutely necessary)
    - [x] Document any unavoidable nolint with clear justification

- [x] Task 4: Commit changes (AC: 1.3.6)
  - [x] Review all changes
  - [x] Stage files: `git add internal/domain/template.go internal/domain/template_test.go`
  - [x] Commit with message: `feat(domain): implement Template domain models (TemplateID, Template)`

## Dev Notes

### TemplateID Model

From `docs/architecture/data-models.md#templateid` (v0.5.6):

**Purpose:** Template name used for identification and composition. Represents the intrinsic domain concept of "template name" required by Go's `text/template` composition system.

**Type:** String wrapper representing template name (e.g., "contact-header", "daily-note").

**Key Usage:**

- Used in template composition syntax: `{{template "contact-header"}}`
- Used in template references: `{{template "name"}}` and `{{block "name"}}`
- TemplateLoader adapter derives TemplateID from filename basename
- Used as map keys in template registries

**Design Decisions:**

- **Name as domain concept:** Unlike NoteID (truly opaque), TemplateID represents template name—an intrinsic domain requirement for Go's `text/template` composition system (NOT a layer violation)
- **Basename convention:** By convention, TemplateID matches file basename without path/extension (e.g., `templates/contact-header.md` → `"contact-header"`)
- **Storage agnostic within constraint:** Templates could come from database, API, or filesystem, but all need a name for `{{template}}` references
- **Simple identifier type:** Just a string wrapper, not a DDD value object

**Implementation:**

```go
type TemplateID string

func NewTemplateID(value string) TemplateID {
    return TemplateID(value)
}

func (id TemplateID) String() string {
    return string(id)
}
```

### Template Model

From `docs/architecture/data-models.md#template` (v0.5.6):

**Purpose:** Represents an executable template for note generation. Pure data structure containing template identity and content.

**Fields:**

- `ID TemplateID` - Template name for identification and composition
- `Content string` - Raw template text with Go `text/template` syntax and Lithos functions

**Relationships:**

- May reference other Templates via `{{template "name"}}` directive (resolved by Go's `text/template`)
- Loaded by TemplateLoader adapter from files in Config.TemplatesDir
- TemplateLoader uses FileMetadata (SPI adapter) to track filesystem paths (TemplateID ↔ Path mapping)
- Executed by TemplateEngine service with injected function map and data context

**Design Decisions:**

- **Pure data structure:** Just ID + Content (NO behavior, NO cached parse trees)
- **NO Parsed field:** Caching concern removed - all parsing/execution logic in TemplateEngine service
- **NO FilePath field:** Infrastructure concern - TemplateLoader uses FileMetadata for path mapping
- **Single model for MVP (YAGNI):** One Template definition for both discovery and execution
- **Content loaded by adapters:** TemplateLoader reads file content and populates Template model
- **Composition via Go stdlib:** Template composition handled by Go's `text/template` via `{{define}}`/`{{template}}` directives

**Implementation:**

```go
type Template struct {
    ID      TemplateID
    Content string
}

func NewTemplate(id TemplateID, content string) Template {
    return Template{
        ID:      id,
        Content: content,
    }
}
```

### TemplateID vs NoteID Distinction

**Important Conceptual Difference:**

**NoteID:**

- **Truly opaque** - domain doesn't care about note naming or storage IDs
- **Infrastructure mapping** - adapters translate NoteID ↔ filesystem paths completely
- **No domain meaning** - just an identifier with no business logic significance

**TemplateID:**

- **Domain concept** - template name IS meaningful for composition logic
- **Required by Go text/template** - `{{template "name"}}` requires names to work
- **Basename convention** - pragmatic choice, but name itself is domain knowledge
- **Not a layer violation** - naming is intrinsic to template composition requirements

### Infrastructure Mapping

**FileMetadata (SPI Adapter - Story 1.9):**

- TemplateLoader uses FileMetadata to map TemplateID ↔ filesystem paths
- FileMetadata has Path, Basename, Folder, Ext, ModTime, Size fields
- Domain never sees FileMetadata - keeps infrastructure concerns isolated
- Template model stays pure (no file paths, no timestamps)

**Adapter Responsibility:**

- TemplateLoader scans Config.TemplatesDir (default: `templates/`)
- Derives TemplateID from file basename (removes path and extension)
- Creates FileMetadata for each template file
- Reads file content
- Constructs Template(ID, Content) and returns to domain

### Testing Standards

From `docs/architecture/testing-strategy.md` and `docs/architecture/coding-standards.md`:

**Unit Test Requirements:**

- Tests live in `internal/domain/template_test.go`
- Use table-driven tests for multiple cases
- Test constructors, methods, and edge cases
- Verify type safety (TemplateID as map key)
- Test Content can store Go template syntax
- Verify NO filesystem dependencies (no Path/FilePath fields)
- Verify NO caching fields (no Parsed field)

**TDD Workflow:**

- RED: Write failing test first
- GREEN: Implement minimum code to pass
- REFACTOR: Improve code quality while tests pass

**Quality Gates:**

- All tests pass: `go test ./internal/domain`
- No linting errors: `golangci-lint run --fix internal/domain`
- Test coverage >90% for domain models

### QA Test Design Reference

**Test Design Document:** `docs/qa/assessments/1.3-test-design-20251028.md`

This story incorporates all 11 unit test scenarios identified in the QA test design:

- UNIT-001 through UNIT-011 covering TemplateID and Template models
- All scenarios are P0 priority due to critical domain model importance
- Test coverage ensures >90% with table-driven Go tests using testify/assert

**Note:** The detailed test scenarios in AC1.3.3 and Tasks 1-2 are derived from this QA analysis.

### File Locations

From `docs/architecture/source-tree.md`:

**Implementation:**

- `internal/domain/template.go` - TemplateID and Template models
- `internal/domain/template_test.go` - Unit tests for models

**Related Infrastructure (NOT in this story):**

- `internal/adapters/spi/file_dto.go` - FileMetadata model (Story 1.9)
- `internal/ports/spi/template.go` - TemplatePort interface (Story 1.9)
- `internal/adapters/spi/template/loader.go` - TemplateLoader adapter (Story 1.9)
- `internal/app/template/service.go` - TemplateEngine service (Story 1.10)

### Refactoring Guidelines

**SRP Decomposition Examples:**

For this story, models are intentionally simple (following anemic domain model pattern). SRP decomposition focuses on:

**TemplateID:**

- Type definition: Single responsibility = represent template identifier
- Constructor: Single responsibility = create TemplateID from string
- String() method: Single responsibility = convert to string for logging

**Template:**

- Struct: Single responsibility = hold template data
- NewTemplate constructor: Single responsibility = create Template from parts
- NO behavior methods: Pure data structure, operations handled by TemplateEngine service

**When to Decompose:**

- If any method exceeds 15 lines, consider extraction
- If constructor has >2 initialization concerns, extract helpers
- Models should remain anemic - no business logic in domain models for MVP

**Naming Standards:**

- Exported types: PascalCase (TemplateID, Template)
- Constructors: NewTypeName (NewTemplateID, NewTemplate)
- Methods: PascalCase for exported, match Go conventions (String())
- Fields: PascalCase for exported (ID, Content)

**Documentation Requirements:**

- Package comment at top of template.go explaining domain models
- All exported types have GoDoc comments
- Constructors have GoDoc explaining parameters and return values
- Methods have GoDoc explaining behavior
- Complex design decisions documented inline (e.g., why no FilePath field)

### Common Pitfalls to Avoid

1. **DO NOT add FilePath field** - This is infrastructure concern (handled by FileMetadata in adapters)
2. **DO NOT add Parsed field** - This is caching concern (handled by TemplateEngine service)
3. **DO NOT add filesystem operations** - Template is pure data, adapters handle I/O
4. **DO NOT confuse with NoteID opacity** - TemplateID has domain meaning (composition names)
5. **DO keep it simple** - Just ID + Content, nothing more

### Example Template Content

Templates contain Go `text/template` syntax with Lithos functions:

```markdown
---
fileClass: contact
name: { { prompt "name" "Contact Name" "" } }
email: { { prompt "email" "Email Address" "" } }
created: { { now "2006-01-02" } }
---

# {{ .name }}

**Email:** {{ .email }}
**Created:** {{ .created }}

## Notes

{{ template "contact-footer" }}
```

This content is stored as a string in Template.Content field. TemplateEngine service handles parsing and execution.

## Change Log

| Date       | Version | Description                                                               | Author                     |
| ---------- | ------- | ------------------------------------------------------------------------- | -------------------------- |
| 2025-10-28 | 1.0     | Story created from Epic 1 requirements                                    | Bob (Scrum Master)         |
| 2025-10-28 | 1.1     | Enhanced with full TDD framework, SRP decomposition, linting checkpoints  | QA Specialist              |
| 2025-10-28 | 1.2     | Implemented TemplateID and Template domain models with 100% test coverage | Full Stack Developer (dev) |

## Dev Agent Record

### Agent Model Used

Full Stack Developer (dev) agent - Expert Senior Software Engineer & Implementation Specialist

### Debug Log References

- `go test -mod=readonly ./internal/domain` - Multiple runs to verify RED/GREEN/REFACTOR cycles
- `golangci-lint run --fix internal/domain` - Multiple runs to fix linting issues (goconst, godoclint, decorder, intrange)
- `go test -mod=readonly -cover ./internal/domain` - Coverage verification (100% achieved)

### Completion Notes List

- Implemented TemplateID model with TDD: RED (failing tests) → GREEN (minimal implementation) → REFACTOR (GoDoc, linting)
- Implemented Template model with comprehensive tests including reflection-based field validation
- Ensured pure domain models with no infrastructure concerns (no FilePath, no Parsed fields)
- Achieved 100% test coverage and zero linting issues
- Followed coding standards and source tree structure
- Added comprehensive GoDoc comments explaining domain concepts and architecture decisions

### File List

- **New Files:**
  - `internal/domain/template.go` - TemplateID and Template domain models
  - `internal/domain/template_test.go` - Unit tests for domain models

- **Modified Files:**
  - None

- **Deleted Files:**
  - None

## QA Results

### Review Date: 2025-10-29

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

The implementation follows clean architecture principles perfectly. Domain models are pure data structures with no infrastructure concerns, adhering to the anemic domain model pattern. GoDoc comments are comprehensive and explain both purpose and design decisions. Code structure follows SRP with clear separation of concerns between TemplateID and Template types.

### Refactoring Performed

No refactoring was necessary - the implementation was already optimal. The code demonstrates excellent adherence to Go idioms and project standards.

### Compliance Check

- Coding Standards: ✓ All standards met (GoDoc, naming conventions, error handling not applicable)
- Project Structure: ✓ Files placed correctly in internal/domain/
- Testing Strategy: ✓ 100% unit test coverage, table-driven tests, co-located test files
- All ACs Met: ✓ All 6 acceptance criteria fully implemented and verified

### Improvements Checklist

- [x] Verified comprehensive GoDoc comments on all exported types and methods
- [x] Confirmed no infrastructure concerns in domain models (no FilePath/Parsed fields)
- [x] Validated type safety with TemplateID as map key
- [x] Ensured Content field can store complex Go template syntax

### Security Review

No security concerns. Pure domain models with no external dependencies, input validation, or data exposure risks.

### Performance Considerations

Excellent performance characteristics. Simple data structures with no allocations in hot paths. TemplateID string wrapper has negligible overhead.

### Files Modified During Review

None - implementation was already production-ready.

### Gate Status

Gate: PASS → docs/qa/gates/1.3-template-domain-models.yml

### Recommended Status

Ready for Done
