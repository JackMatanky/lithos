# Story 1.3: Implement Template Domain Models (TemplateID, Template)

## Status

Draft

## Story

**As a** developer,
**I want** to implement TemplateID and Template domain models in template.go,
**so that** templates are represented as pure domain data without infrastructure concerns.

## Acceptance Criteria

**TemplateID Implementation:**

- 1.3.1: Create `internal/domain/template.go` with TemplateID:
  - Type: `type TemplateID string`
  - Constructor: `NewTemplateID(value string) TemplateID`
  - Method: `String() string` for logging/debugging

**Template Implementation:**

- 1.3.2: Add Template to `internal/domain/template.go`:
  - Field: `ID TemplateID`
  - Field: `Content string` (raw template text)
  - Constructor: `NewTemplate(id TemplateID, content string) Template`
  - NO FilePath field (infrastructure concern)
  - NO Parsed field (caching concern)

**Testing:**

- 1.3.3: Create unit tests in `internal/domain/template_test.go`:
  - Test TemplateID: NewTemplateID creates valid instance, String() returns value, can be used as map key
  - Test Template: NewTemplate constructs with ID and Content, no filesystem dependencies, Template can store Go template syntax in Content

- 1.3.4: All tests pass: `go test ./internal/domain`

- 1.3.5: All linting passes: `golangci-lint run --fix internal/domain`

- 1.3.6: Committed with message: `feat(domain): implement Template domain models (TemplateID, Template)`

## Tasks / Subtasks

- [ ] Task 1: Implement TemplateID model (AC: 1.3.1)
  - [ ] RED: Write failing test for NewTemplateID constructor
    - [ ] Write test case in `internal/domain/template_test.go`
    - [ ] Verify test fails with expected error message
    - [ ] Run `go test ./internal/domain` and confirm failure
  - [ ] RED: Write failing test for String() method
    - [ ] Write test case verifying String() returns underlying value
    - [ ] Run `go test ./internal/domain` and confirm failure
  - [ ] RED: Write failing test for using TemplateID as map key
    - [ ] Create test using TemplateID as map[TemplateID]string key
    - [ ] Verify compilation and test behavior
    - [ ] Run `go test ./internal/domain` and confirm failure
  - [ ] GREEN: Implement minimal code to pass tests
    - [ ] Implement `type TemplateID string`
    - [ ] Implement `NewTemplateID(value string) TemplateID` constructor
    - [ ] Implement `String() string` method
    - [ ] Run `go test ./internal/domain` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components (minimal - already simple types):
      - [ ] Verify TemplateID type has single responsibility (opaque identifier for template name)
      - [ ] Verify constructor has single responsibility (creation)
      - [ ] Verify String() method has single responsibility (string conversion)
    - [ ] Review naming: type TemplateID (clear), NewTemplateID (idiomatic), String() (standard Go interface)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add package comment at top of template.go if not present
      - [ ] Add GoDoc for TemplateID type explaining template name concept
      - [ ] Add GoDoc for NewTemplateID constructor
      - [ ] Add GoDoc for String() method
    - [ ] Run `golangci-lint run --fix internal/domain`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/domain` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for TemplateID
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/domain`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 2: Implement Template model (AC: 1.3.2)
  - [ ] RED: Write failing test for NewTemplate constructor
    - [ ] Write test case in `internal/domain/template_test.go`
    - [ ] Verify test fails with expected error message
    - [ ] Run `go test ./internal/domain` and confirm failure
  - [ ] RED: Write failing test for Template with Go template syntax
    - [ ] Write test storing complex template syntax in Content field
    - [ ] Verify template syntax preserved correctly
    - [ ] Run `go test ./internal/domain` and confirm failure
  - [ ] RED: Write failing test for no FilePath field
    - [ ] Write test verifying Template struct has no FilePath field
    - [ ] Use reflection or type checks to verify structure
    - [ ] Run `go test ./internal/domain` and confirm failure
  - [ ] RED: Write failing test for no Parsed field
    - [ ] Write test verifying Template struct has no Parsed field
    - [ ] Use reflection or type checks to verify structure
    - [ ] Run `go test ./internal/domain` and confirm failure
  - [ ] GREEN: Implement minimal code to pass tests
    - [ ] Implement Template struct with ID and Content fields ONLY
    - [ ] Implement `NewTemplate(id, content) Template` constructor
    - [ ] Run `go test ./internal/domain` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify Template struct has single responsibility (hold template data)
      - [ ] Verify NewTemplate constructor has single responsibility (create Template)
      - [ ] Verify NO infrastructure concerns (paths, timestamps, parse trees)
    - [ ] Review naming:
      - [ ] Template (clear domain aggregate)
      - [ ] ID field (clear identifier)
      - [ ] Content field (clear: raw template text)
      - [ ] NewTemplate (idiomatic constructor)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for Template struct explaining pure data structure pattern
      - [ ] Add GoDoc for ID field (template name for identification and composition)
      - [ ] Add GoDoc for Content field (raw template text with Go text/template syntax)
      - [ ] Add GoDoc for NewTemplate constructor
      - [ ] Add comment explaining why FilePath and Parsed are NOT included (architecture alignment)
    - [ ] Run `golangci-lint run --fix internal/domain`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/domain` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for Template
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/domain`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 3: Run quality gates (AC: 1.3.4-1.3.5)
  - [ ] Run `go test ./internal/domain` and verify 100% pass
  - [ ] Run `golangci-lint run --fix internal/domain` and fix any issues
  - [ ] Verify test coverage is adequate (>90% for domain models)
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/domain`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 4: Commit changes (AC: 1.3.6)
  - [ ] Review all changes
  - [ ] Stage files: `git add internal/domain/template.go internal/domain/template_test.go`
  - [ ] Commit with message: `feat(domain): implement Template domain models (TemplateID, Template)`

## Dev Notes

### TemplateID Model

From `docs/architecture/data-models.md#templateid` (v0.5.6):

**Purpose:** Template name used for identification and composition. Represents the intrinsic domain concept of "template name" required by Go's `text/template` composition system.

**Type:** String wrapper representing template name (e.g., "contact-header", "daily-note").

**Key Usage:**

- Used in template composition syntax: `{{template "contact-header"}}`
- Used in template references: `{{template "name"}}` and `{{block "name"}}`
- TemplateLoader adapter derives TemplateID from filename basename
- Used as map keys in template registries

**Design Decisions:**

- **Name as domain concept:** Unlike NoteID (truly opaque), TemplateID represents template name—an intrinsic domain requirement for Go's `text/template` composition system (NOT a layer violation)
- **Basename convention:** By convention, TemplateID matches file basename without path/extension (e.g., `templates/contact-header.md` → `"contact-header"`)
- **Storage agnostic within constraint:** Templates could come from database, API, or filesystem, but all need a name for `{{template}}` references
- **Simple identifier type:** Just a string wrapper, not a DDD value object

**Implementation:**

```go
type TemplateID string

func NewTemplateID(value string) TemplateID {
    return TemplateID(value)
}

func (id TemplateID) String() string {
    return string(id)
}
```

### Template Model

From `docs/architecture/data-models.md#template` (v0.5.6):

**Purpose:** Represents an executable template for note generation. Pure data structure containing template identity and content.

**Fields:**

- `ID TemplateID` - Template name for identification and composition
- `Content string` - Raw template text with Go `text/template` syntax and Lithos functions

**Relationships:**

- May reference other Templates via `{{template "name"}}` directive (resolved by Go's `text/template`)
- Loaded by TemplateLoader adapter from files in Config.TemplatesDir
- TemplateLoader uses FileMetadata (SPI adapter) to track filesystem paths (TemplateID ↔ Path mapping)
- Executed by TemplateEngine service with injected function map and data context

**Design Decisions:**

- **Pure data structure:** Just ID + Content (NO behavior, NO cached parse trees)
- **NO Parsed field:** Caching concern removed - all parsing/execution logic in TemplateEngine service
- **NO FilePath field:** Infrastructure concern - TemplateLoader uses FileMetadata for path mapping
- **Single model for MVP (YAGNI):** One Template definition for both discovery and execution
- **Content loaded by adapters:** TemplateLoader reads file content and populates Template model
- **Composition via Go stdlib:** Template composition handled by Go's `text/template` via `{{define}}`/`{{template}}` directives

**Implementation:**

```go
type Template struct {
    ID      TemplateID
    Content string
}

func NewTemplate(id TemplateID, content string) Template {
    return Template{
        ID:      id,
        Content: content,
    }
}
```

### TemplateID vs NoteID Distinction

**Important Conceptual Difference:**

**NoteID:**

- **Truly opaque** - domain doesn't care about note naming or storage IDs
- **Infrastructure mapping** - adapters translate NoteID ↔ filesystem paths completely
- **No domain meaning** - just an identifier with no business logic significance

**TemplateID:**

- **Domain concept** - template name IS meaningful for composition logic
- **Required by Go text/template** - `{{template "name"}}` requires names to work
- **Basename convention** - pragmatic choice, but name itself is domain knowledge
- **Not a layer violation** - naming is intrinsic to template composition requirements

### Infrastructure Mapping

**FileMetadata (SPI Adapter - Story 1.9):**

- TemplateLoader uses FileMetadata to map TemplateID ↔ filesystem paths
- FileMetadata has Path, Basename, Folder, Ext, ModTime, Size fields
- Domain never sees FileMetadata - keeps infrastructure concerns isolated
- Template model stays pure (no file paths, no timestamps)

**Adapter Responsibility:**

- TemplateLoader scans Config.TemplatesDir (default: `templates/`)
- Derives TemplateID from file basename (removes path and extension)
- Creates FileMetadata for each template file
- Reads file content
- Constructs Template(ID, Content) and returns to domain

### Testing Standards

From `docs/architecture/testing-strategy.md` and `docs/architecture/coding-standards.md`:

**Unit Test Requirements:**

- Tests live in `internal/domain/template_test.go`
- Use table-driven tests for multiple cases
- Test constructors, methods, and edge cases
- Verify type safety (TemplateID as map key)
- Test Content can store Go template syntax
- Verify NO filesystem dependencies (no Path/FilePath fields)
- Verify NO caching fields (no Parsed field)

**TDD Workflow:**

- RED: Write failing test first
- GREEN: Implement minimum code to pass
- REFACTOR: Improve code quality while tests pass

**Quality Gates:**

- All tests pass: `go test ./internal/domain`
- No linting errors: `golangci-lint run --fix internal/domain`
- Test coverage >90% for domain models

### File Locations

From `docs/architecture/source-tree.md`:

**Implementation:**

- `internal/domain/template.go` - TemplateID and Template models
- `internal/domain/template_test.go` - Unit tests for models

**Related Infrastructure (NOT in this story):**

- `internal/adapters/spi/file_dto.go` - FileMetadata model (Story 1.9)
- `internal/ports/spi/template.go` - TemplatePort interface (Story 1.9)
- `internal/adapters/spi/template/loader.go` - TemplateLoader adapter (Story 1.9)
- `internal/app/template/service.go` - TemplateEngine service (Story 1.10)

### Refactoring Guidelines

**SRP Decomposition Examples:**

For this story, models are intentionally simple (following anemic domain model pattern). SRP decomposition focuses on:

**TemplateID:**

- Type definition: Single responsibility = represent template identifier
- Constructor: Single responsibility = create TemplateID from string
- String() method: Single responsibility = convert to string for logging

**Template:**

- Struct: Single responsibility = hold template data
- NewTemplate constructor: Single responsibility = create Template from parts
- NO behavior methods: Pure data structure, operations handled by TemplateEngine service

**When to Decompose:**

- If any method exceeds 15 lines, consider extraction
- If constructor has >2 initialization concerns, extract helpers
- Models should remain anemic - no business logic in domain models for MVP

**Naming Standards:**

- Exported types: PascalCase (TemplateID, Template)
- Constructors: NewTypeName (NewTemplateID, NewTemplate)
- Methods: PascalCase for exported, match Go conventions (String())
- Fields: PascalCase for exported (ID, Content)

**Documentation Requirements:**

- Package comment at top of template.go explaining domain models
- All exported types have GoDoc comments
- Constructors have GoDoc explaining parameters and return values
- Methods have GoDoc explaining behavior
- Complex design decisions documented inline (e.g., why no FilePath field)

### Common Pitfalls to Avoid

1. **DO NOT add FilePath field** - This is infrastructure concern (handled by FileMetadata in adapters)
2. **DO NOT add Parsed field** - This is caching concern (handled by TemplateEngine service)
3. **DO NOT add filesystem operations** - Template is pure data, adapters handle I/O
4. **DO NOT confuse with NoteID opacity** - TemplateID has domain meaning (composition names)
5. **DO keep it simple** - Just ID + Content, nothing more

### Example Template Content

Templates contain Go `text/template` syntax with Lithos functions:

```markdown
---
fileClass: contact
name: { { prompt "name" "Contact Name" "" } }
email: { { prompt "email" "Email Address" "" } }
created: { { now "2006-01-02" } }
---

# {{ .name }}

**Email:** {{ .email }}
**Created:** {{ .created }}

## Notes

{{ template "contact-footer" }}
```

This content is stored as a string in Template.Content field. TemplateEngine service handles parsing and execution.

## Change Log

| Date       | Version | Description                                                              | Author             |
| ---------- | ------- | ------------------------------------------------------------------------ | ------------------ |
| 2025-10-28 | 1.0     | Story created from Epic 1 requirements                                   | Bob (Scrum Master) |
| 2025-10-28 | 1.1     | Enhanced with full TDD framework, SRP decomposition, linting checkpoints | QA Specialist      |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
