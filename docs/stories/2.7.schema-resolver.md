# Story 2.7: SchemaResolver Service

## Status

Draft

## Story

**As a** developer,
**I want** SchemaResolver to resolve inheritance and `$ref` substitution,
**so that** downstream consumers receive flattened schemas.

## Acceptance Criteria

**SchemaResolver Service Structure:**

- 2.7.1: Create `internal/app/schema/resolver.go` with SchemaResolver service per `docs/architecture/components.md#schemaresolver`

- 2.7.2: SchemaResolver has no dependencies (pure domain logic)

- 2.7.3: SchemaResolver is instantiated internally by SchemaEngine (not injected in main.go)

**Resolve Method:**

- 2.7.4: Implement `Resolve(ctx context.Context, schemas []Schema, bank PropertyBank) ([]Schema, error)` that:
  - Resolves all schemas using inheritance resolution algorithm
  - Preserves original schemas (no mutation)
  - Returns resolved copies with flattened properties
  - Populates ResolvedProperties field to satisfy FR5 and FR9

**Inheritance Resolution Algorithm:**

- 2.7.5: Build dependency graph mapping each schema to its Extends parent

- 2.7.6: Detect circular inheritance chains using depth-first search

- 2.7.7: Return informative error on circular dependency with full cycle path

- 2.7.8: Perform topological sort to order schemas (parents resolve before children)

- 2.7.9: For each schema in topological order:
  - Get parent's resolved properties (or empty list if root schema)
  - Apply Excludes (remove properties by name from parent list)
  - Merge child properties (override parent properties with same name)
  - Store as resolved properties in new Schema copy

**Property Merge Semantics:**

- 2.7.10: Child property with matching Name completely replaces parent property (no attribute-level merge)

- 2.7.11: Properties from parent not excluded or overridden are inherited

- 2.7.12: Resolved properties list is final property set for schema

**$ref Substitution:**

- 2.7.13: During property resolution, detect properties with $ref references

- 2.7.14: Substitute $ref with PropertyBank definition (simple replacement)

- 2.7.15: Return error if $ref target not found in PropertyBank

**Immutability:**

- 2.7.16: Original schemas passed to Resolve() are never mutated

- 2.7.17: Resolved schemas are new copies with ResolvedProperties populated

- 2.7.18: Original Extends/Excludes/Properties remain unchanged in resolved schemas

**Error Handling:**

- 2.7.19: Circular dependency error includes full cycle path: "circular inheritance: A → B → C → A"

- 2.7.20: Missing $ref error includes schema name, property name, and missing $ref target

- 2.7.21: All errors use SchemaError types per `docs/architecture/error-handling-strategy.md`

**GoDoc and Architecture References:**

- 2.7.22: Add comprehensive GoDoc referencing `docs/architecture/components.md#schemaresolver`

- 2.7.23: Document algorithm steps (graph build, cycle detection, topological sort, resolution)

- 2.7.24: Document property merge semantics (complete override, not attribute merge)

**Unit Tests:**

- 2.7.25: Create `internal/app/schema/resolver_test.go` with tests covering:
  - Single root schema (no inheritance)
  - Two-level inheritance (child extends parent)
  - Multi-level inheritance (grandchild → child → parent)
  - Excludes removes parent properties correctly
  - Child property overrides parent property with same name
  - Circular dependency detection with error path
  - Missing $ref target error
  - $ref substitution success
  - Original schemas remain unchanged (immutability)

- 2.7.26: Run `golangci-lint run ./internal/app/schema` and verify zero errors

- 2.7.27: Run `go test ./internal/app/schema -v` and verify all tests pass

**Documentation:**

- 2.7.28: Committed with message: `feat(schema): add SchemaResolver service with inheritance and $ref resolution`

## Tasks / Subtasks

- [ ] Task 1: Create SchemaResolver structure (AC: 2.7.1-2.7.3)
  - [ ] Create `resolver.go` in schema service package
  - [ ] Define SchemaResolver struct
  - [ ] Implement NewSchemaResolver() constructor (no dependencies)
  - [ ] Add comprehensive GoDoc

- [ ] Task 2: Implement Resolve method signature (AC: 2.7.4)
  - [ ] Define Resolve() signature
  - [ ] Plan implementation structure
  - [ ] Add method documentation

- [ ] Task 3: Implement dependency graph building (AC: 2.7.5)
  - [ ] Build map of schema name to Extends parent
  - [ ] Prepare for topological sort

- [ ] Task 4: Implement circular dependency detection (AC: 2.7.6-2.7.7)
  - [ ] Implement depth-first search for cycle detection
  - [ ] Track visited nodes and current path
  - [ ] Generate informative cycle error with full path

- [ ] Task 5: Implement topological sort (AC: 2.7.8)
  - [ ] Sort schemas so parents resolve before children
  - [ ] Handle schemas with no parent (roots)
  - [ ] Return sorted order

- [ ] Task 6: Implement schema resolution loop (AC: 2.7.9)
  - [ ] Loop through schemas in topological order
  - [ ] Get parent's resolved properties
  - [ ] Apply Excludes
  - [ ] Merge child properties
  - [ ] Create resolved schema copy

- [ ] Task 7: Implement property merge semantics (AC: 2.7.10-2.7.12)
  - [ ] Implement property override by name
  - [ ] Implement property inheritance (keep non-overridden parent properties)
  - [ ] Build final resolved properties list

- [ ] Task 8: Implement $ref substitution (AC: 2.7.13-2.7.15)
  - [ ] Detect properties with $ref references
  - [ ] Look up target in PropertyBank
  - [ ] Substitute $ref with property definition
  - [ ] Return error on missing target

- [ ] Task 9: Ensure immutability (AC: 2.7.16-2.7.18)
  - [ ] Verify original schemas not mutated
  - [ ] Create new schema copies for resolved output
  - [ ] Preserve original fields in resolved copies

- [ ] Task 10: Implement error handling (AC: 2.7.19-2.7.21)
  - [ ] Create informative circular dependency error
  - [ ] Create informative missing $ref error
  - [ ] Use SchemaError types

- [ ] Task 11: Add comprehensive documentation (AC: 2.7.22-2.7.24)
  - [ ] Document algorithm steps
  - [ ] Document property merge semantics
  - [ ] Reference architecture docs
  - [ ] Add code examples in comments

- [ ] Task 12: Write unit tests (AC: 2.7.25)
  - [ ] Create resolver_test.go
  - [ ] Test root schema (no inheritance)
  - [ ] Test two-level inheritance
  - [ ] Test multi-level inheritance
  - [ ] Test Excludes behavior
  - [ ] Test property override
  - [ ] Test circular dependency detection
  - [ ] Test missing $ref error
  - [ ] Test $ref substitution
  - [ ] Test immutability

- [ ] Task 13: Run linting and tests (AC: 2.7.26-2.7.27)
  - [ ] Run golangci-lint and fix any issues
  - [ ] Run tests and verify all pass
  - [ ] Verify test coverage is comprehensive

- [ ] Task 14: Commit changes (AC: 2.7.28)
  - [ ] Review all code and documentation
  - [ ] Commit with proper message

## Dev Notes

### Architecture References

From `docs/architecture/components.md#schemaresolver`:

**Resolution Algorithm:**

1. **Build Dependency Graph:** Map each schema to its Extends parent
2. **Detect Cycles:** DFS to find circular inheritance chains (Schema A extends B extends A)
3. **Topological Sort:** Order schemas so parents resolve before children
4. **Resolve Inheritance:** For each schema in order:
   - Get parent's resolved properties (or empty if root schema)
   - Apply Excludes (remove properties by name)
   - Merge child properties (override parent properties with same name)
   - Store as resolved properties
5. **Substitute $ref:** Replace all `{$ref: "#/properties/name"}` with PropertyBank.Properties[name]

**Property Override Semantics:**

- If child Property.Name matches parent Property.Name, child completely replaces parent
- This is explicit override, not attribute-level merge
- Properties not overridden or excluded are inherited from parent

**Eager Resolution:**
From `docs/architecture/data-models.md#schema`:

- Inheritance chains resolved during application initialization
- Fail-fast on circular dependencies
- Validator never sees unresolved schemas
- Performance: O(n\*d) where n=schemas, d=depth, acceptable for MVP (<100 schemas expected)

### Implementation Guidance

**Cycle Detection with DFS:**

```go
func (r *SchemaResolver) detectCycles(
    schemas []Schema,
    graph map[string]string, // schema name → parent name
) error {
    visited := make(map[string]bool)
    recStack := make(map[string]bool) // Recursion stack for current path

    var dfs func(name string, path []string) error
    dfs = func(name string, path []string) error {
        visited[name] = true
        recStack[name] = true
        path = append(path, name)

        if parent, hasParent := graph[name]; hasParent {
            if recStack[parent] {
                // Cycle detected - build cycle path
                return fmt.Errorf("circular inheritance: %s → %s",
                    strings.Join(path, " → "), parent)
            }
            if !visited[parent] {
                if err := dfs(parent, path); err != nil {
                    return err
                }
            }
        }

        recStack[name] = false
        return nil
    }

    for _, schema := range schemas {
        if !visited[schema.Name] {
            if err := dfs(schema.Name, []string{}); err != nil {
                return err
            }
        }
    }

    return nil
}
```

**Topological Sort:**

```go
func (r *SchemaResolver) topologicalSort(
    schemas []Schema,
    graph map[string]string,
) []Schema {
    sorted := []Schema{}
    visited := make(map[string]bool)
    schemaMap := buildSchemaMap(schemas)

    var visit func(name string)
    visit = func(name string) {
        if visited[name] {
            return
        }

        visited[name] = true

        // Visit parent first (if exists)
        if parent, hasParent := graph[name]; hasParent {
            visit(parent)
        }

        // Add current schema after parent
        sorted = append(sorted, schemaMap[name])
    }

    for _, schema := range schemas {
        visit(schema.Name)
    }

    return sorted
}
```

**Property Resolution:**

```go
func (r *SchemaResolver) resolveProperties(
    schema Schema,
    parentProps []Property,
    excludes []string,
) []Property {
    // 1. Start with parent properties
    resolved := make([]Property, 0, len(parentProps)+len(schema.Properties))

    // 2. Apply Excludes
    excludeSet := make(map[string]bool)
    for _, name := range excludes {
        excludeSet[name] = true
    }

    for _, prop := range parentProps {
        if !excludeSet[prop.Name] {
            resolved = append(resolved, prop)
        }
    }

    // 3. Merge child properties (override by name)
    for _, childProp := range schema.Properties {
        // Remove parent property with same name
        resolved = removeProperty(resolved, childProp.Name)
        // Add child property
        resolved = append(resolved, childProp)
    }

    return resolved
}
```

### Testing Strategy

From `docs/architecture/testing-strategy.md`:

**Test Coverage:**

- Root schema (no parent)
- Simple inheritance (one level)
- Multi-level inheritance (grandparent → parent → child)
- Excludes removes parent properties
- Child property overrides parent property
- Circular dependency detection
- Missing $ref error
- $ref substitution success
- Immutability (originals unchanged)

**Multi-Level Inheritance Test:**

```go
func TestSchemaResolver_MultiLevelInheritance(t *testing.T) {
    resolver := NewSchemaResolver()

    // Grandparent
    grandparent := Schema{
        Name: "note",
        Properties: []Property{
            {Name: "title", Required: true},
            {Name: "tags", Required: false},
        },
    }

    // Parent extends grandparent, adds property
    parent := Schema{
        Name: "base-note",
        Extends: "note",
        Properties: []Property{
            {Name: "created", Required: true},
        },
    }

    // Child extends parent, overrides title, excludes tags
    child := Schema{
        Name: "meeting-note",
        Extends: "base-note",
        Excludes: []string{"tags"},
        Properties: []Property{
            {Name: "title", Required: false}, // Override
            {Name: "attendees", Required: true},
        },
    }

    schemas := []Schema{grandparent, parent, child}
    resolved, err := resolver.Resolve(context.Background(), schemas, PropertyBank{})

    require.NoError(t, err)

    // Find resolved child
    var resolvedChild Schema
    for _, s := range resolved {
        if s.Name == "meeting-note" {
            resolvedChild = s
            break
        }
    }

    // Verify resolved properties
    assert.Len(t, resolvedChild.ResolvedProperties, 3) // title, created, attendees
    // tags excluded
    assert.True(t, hasProperty(resolvedChild, "title"))
    assert.True(t, hasProperty(resolvedChild, "created"))
    assert.True(t, hasProperty(resolvedChild, "attendees"))
    assert.False(t, hasProperty(resolvedChild, "tags"))

    // Verify title is overridden (Required: false from child)
    titleProp := getProperty(resolvedChild, "title")
    assert.False(t, titleProp.Required)
}
```

### Refactoring Guidelines

**SRP Decomposition Examples:**

For this story, SchemaResolver resolves inheritance. SRP decomposition focuses on:

**SchemaResolver:**

- Resolve() method: Single responsibility = orchestrate resolution
  - Extract buildGraph() for dependency graph building
  - Extract detectCycles() for circular dependency detection (>20 lines)
  - Extract topologicalSort() for ordering schemas (>20 lines)
  - Extract resolveSchema() for single schema resolution
- resolveProperties() helper: Single responsibility = merge parent/child properties
  - Extract applyExcludes() if exclude logic >10 lines
  - Extract mergeProperties() if merge logic >10 lines
- substituteRefs() helper: Single responsibility = replace $ref with definitions

**When to Decompose:**

- If any method exceeds 15 lines, consider extraction
- If constructor has >2 initialization concerns, extract helpers
- If validation logic mixes with business logic, extract validators

**Naming Standards:**

- Exported types: PascalCase
- Constructors: NewTypeName
- Private helpers: camelCase, specific action verbs
- Methods: PascalCase for exported, match Go conventions
- Boolean helpers (if added): is, has, can prefix

**Documentation Requirements:**

- Package comment at top of file explaining domain models/services
- All exported types have GoDoc comments
- Constructors have GoDoc explaining parameters and return values
- Methods have GoDoc explaining behavior
- Complex logic has inline comments for clarity

### Related Components

From `docs/architecture/components.md`:

**SchemaEngine (Story 2.8):**

- Instantiates SchemaResolver internally
- Calls Resolve() after SchemaValidator succeeds
- Uses resolved schemas to populate SchemaRegistry

**SchemaValidator (Story 2.6):**

- Runs BEFORE SchemaResolver
- Ensures all schemas are structurally valid
- SchemaResolver assumes valid input

**FrontmatterService (Epic 3):**

- Uses resolved schemas for validation
- Never sees unresolved schemas (Extends/Excludes handled)
- Works with flattened property lists

## Change Log

| Date       | Version | Description                                                              | Author             |
| ---------- | ------- | ------------------------------------------------------------------------ | ------------------ |
| 2025-10-28 | 1.0     | Story created from Epic 2 requirements                                   | Bob (Scrum Master) |
| 2025-10-28 | 1.1     | Enhanced with full TDD framework, SRP decomposition, linting checkpoints | QA Specialist      |
| 2025-10-28 | 1.0     | Story created from Epic 2 requirements                                   | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## Testing

**Test Design:** `docs/qa/assessments/2.7-test-design-20251029.md`

## QA Results

_To be completed by QA agent after implementation_
