# Story 1.13: Implement CommandOrchestrator

## Status

Ready for Implementation

## Story

**As a** developer,
**I want** to implement CommandOrchestrator that orchestrates the NewNote use case workflow,
**so that** CLI commands are coordinated through domain services following hexagonal architecture.

## Acceptance Criteria

- 1.13.1: Create `internal/app/command/orchestrator.go`:
  - Constructor: `NewCommandOrchestrator(cliPort CLIPort, templateEngine *TemplateEngine, config Config, log zerolog.Logger) *CommandOrchestrator`
  - Implements CommandPort interface (from ports/api/command.go)
  - Dependencies: CLIPort (injected), TemplateEngine (injected), Config (injected), Logger (injected)

- 1.13.2: Implement `Run(ctx context.Context) error`:
  - Calls `cliPort.Start(ctx, self)` passing orchestrator as handler (hexagonal callback pattern)
  - Returns error from CLI execution

- 1.13.3: Implement `NewNote(ctx context.Context, templateID TemplateID) (Note, error)` workflow:
  - Step 1: Render template via `templateEngine.Render(ctx, templateID)`
    - Log operation: "Rendering template {templateID}"
  - Step 2: Generate NoteID from templateID (temporary strategy for Epic 1):
    - Use template basename as note filename: `noteID := domain.NewNoteID(templateID.String())`
  - Step 3: Create empty Frontmatter (no YAML parsing in Epic 1):
    - `frontmatter := domain.NewFrontmatter(map[string]interface{}{})`
  - Step 4: Construct Note:
    - `note := domain.NewNote(noteID, frontmatter)`
  - Step 5: Write rendered content to file:
    - Target path: `{Config.VaultPath}/{noteID}.md`
    - Use `os.WriteFile(path, []byte(renderedContent), 0644)`
    - Log operation: "Writing note to {path}"
  - Step 6: Return Note

- 1.13.4: Error handling:
  - Template not found → return ResourceError from TemplateEngine (propagates from TemplatePort)
  - Render error → return TemplateError from TemplateEngine
  - File write error → wrap with WrapWithContext("failed to write note to {path}", err)

- 1.13.5: Create unit tests in `internal/app/command/orchestrator_test.go`:
  - Test: Run() calls CLIPort.Start() with self as handler
  - Test: Run() propagates errors from CLI
  - Test: NewNote() orchestrates template rendering correctly
  - Test: NewNote() generates NoteID from templateID (basename strategy)
  - Test: NewNote() creates empty Frontmatter
  - Test: NewNote() constructs Note with NoteID and Frontmatter
  - Test: NewNote() writes file to vault at correct path
  - Test: NewNote() returns ResourceError when template not found
  - Test: NewNote() returns TemplateError on render failure
  - Test: NewNote() wraps file write errors with context
  - All tests use mocks from tests/utils/mocks.go (MockCLIPort, MockTemplatePort)

- 1.13.6: Add mock to `tests/utils/mocks.go`:
  - `MockCLIPort` struct implementing CLIPort interface
  - Internal field: `startCalled bool`, `startHandler CommandPort`
  - Method: `Start(ctx, handler)` stores handler and sets startCalled flag
  - Method: `WasStartCalled() bool` returns startCalled
  - Method: `GetHandler() CommandPort` returns stored handler

- 1.13.7: All tests pass: `go test ./internal/app`

- 1.13.8: All linting passes: `golangci-lint run --fix internal/app`

- 1.13.9: Committed with message: `feat(app): implement CommandOrchestrator with NewNote use case`

## Tasks / Subtasks

- [ ] Task 1: Implement CommandOrchestrator struct and constructor (AC: 1.13.1)
  - [ ] RED: Write failing test for struct compilation
    - [ ] Write test case verifying CommandOrchestrator struct exists
    - [ ] Verify test fails with expected compilation error
    - [ ] Run `go test ./internal/app/command` and confirm failure
  - [ ] GREEN: Create `internal/app/command/orchestrator.go`
    - [ ] Define CommandOrchestrator struct with cliPort, templateEngine, config, log fields
    - [ ] Implement NewCommandOrchestrator constructor with dependency injection
    - [ ] Run `go test ./internal/app/command` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify CommandOrchestrator struct has single responsibility (hold orchestrator state)
      - [ ] Verify NewCommandOrchestrator constructor has single responsibility (create and initialize orchestrator)
      - [ ] Verify all dependencies injected via constructor (no globals)
    - [ ] Review naming: CommandOrchestrator (clear orchestrator name), NewCommandOrchestrator (idiomatic)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add package comment at top of orchestrator.go explaining orchestrator purpose
      - [ ] Add GoDoc for CommandOrchestrator struct
      - [ ] Add GoDoc for NewCommandOrchestrator constructor documenting all parameters
    - [ ] Run `golangci-lint run --fix internal/app/command`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/command` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/command`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 2: Implement Run method (AC: 1.13.2)
  - [ ] RED: Write failing tests for Run()
    - [ ] Write test case verifying Run() calls CLIPort.Start()
    - [ ] Write test case verifying Run() passes self as handler
    - [ ] Verify tests fail (method not implemented)
    - [ ] Run `go test ./internal/app/command` and confirm failures
  - [ ] GREEN: Implement Run() method
    - [ ] Call cliPort.Start(ctx, self) - hexagonal callback pattern
    - [ ] Return error from CLI execution
    - [ ] Run `go test ./internal/app/command` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify Run() has single responsibility (start CLI with self as handler)
      - [ ] Verify hexagonal callback pattern implemented correctly
      - [ ] Verify no business logic in Run() method
    - [ ] Review naming: Run (clear API port method)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for Run() method explaining hexagonal callback pattern
      - [ ] Document how orchestrator passes self to CLI adapter
      - [ ] Document error propagation
    - [ ] Run `golangci-lint run --fix internal/app/command`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/command` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/command`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 3: Implement NewNote workflow (AC: 1.13.3-1.13.4)
  - [ ] RED: Write failing tests for NewNote() workflow
    - [ ] Test template rendering via TemplateEngine.Render()
    - [ ] Test NoteID generation from templateID (basename strategy)
    - [ ] Test Frontmatter creation (empty for Epic 1)
    - [ ] Test Note construction with NoteID and Frontmatter
    - [ ] Test file writing to vault at correct path
    - [ ] Test error handling: ResourceError, TemplateError, file write errors
    - [ ] Verify tests fail (method not implemented)
    - [ ] Run `go test ./internal/app/command` and confirm failures
  - [ ] GREEN: Implement NewNote() workflow steps 1-6
    - [ ] Step 1: Call templateEngine.Render(ctx, templateID) with logging
    - [ ] Step 2: Generate NoteID from templateID (basename strategy)
    - [ ] Step 3: Create empty Frontmatter: NewFrontmatter(map[string]interface{}{})
    - [ ] Step 4: Construct Note: NewNote(noteID, frontmatter)
    - [ ] Step 5: Write file to vault: os.WriteFile({Config.VaultPath}/{noteID}.md, content, 0644)
    - [ ] Step 6: Return Note
    - [ ] Run `go test ./internal/app/command` and verify tests pass
  - [ ] GREEN: Implement error handling
    - [ ] Template not found: return ResourceError from TemplateEngine
    - [ ] Render error: return TemplateError from TemplateEngine
    - [ ] File write error: wrap with WrapWithContext("failed to write note to {path}", err)
    - [ ] Run `go test ./internal/app/command` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract orchestrate() if workflow exceeds 15 lines (coordinate steps)
      - [ ] Extract validate(templateID) (check templateID not empty)
      - [ ] Extract persist(noteID, content) (write file to vault)
      - [ ] Extract logResult(noteID) (log note creation success)
      - [ ] Extract handleError(err, context) (wrap errors with context)
      - [ ] Verify NewNote() orchestrates helpers cleanly
    - [ ] Review naming: NewNote (clear use case name), helper methods follow verb pattern
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for NewNote() explaining complete workflow (6 steps)
      - [ ] Document NoteID generation strategy (basename for Epic 1, enhancement in future)
      - [ ] Document error conditions (ResourceError, TemplateError, file write errors)
      - [ ] Document all helper functions with clear purpose
    - [ ] Run `golangci-lint run --fix internal/app/command`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/command` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for NewNote workflow
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/command`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 4: Create MockCLIPort (AC: 1.13.6)
  - [ ] RED: Write test verifying MockCLIPort satisfies CLIPort interface
    - [ ] Verify test fails (mock not implemented)
  - [ ] GREEN: Add MockCLIPort to tests/utils/mocks.go
    - [ ] Implement Start() method storing handler and setting startCalled flag
    - [ ] Add WasStartCalled() test helper method
    - [ ] Add GetHandler() test helper method
    - [ ] Verify mock compiles and satisfies interface
  - [ ] REFACTOR:
    - [ ] Review naming: MockCLIPort (clear mock name)
    - [ ] Add comprehensive GoDoc comments explaining mock usage
    - [ ] Document how to configure mock and verify behavior
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix tests/utils`
    - [ ] Fix ALL warnings

- [ ] Task 5: Run quality gates (AC: 1.13.7-1.13.8)
  - [ ] Run `go test ./internal/app/command` and verify 100% pass
  - [ ] Run `golangci-lint run internal/app/command` and fix any issues
  - [ ] Verify test coverage >85%: `go test -cover ./internal/app/command`
  - [ ] Linting checkpoint:
    - [ ] Final sweep: `golangci-lint run --fix internal/app/command tests/utils`
    - [ ] Verify ALL warnings resolved
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 6: Commit changes (AC: 1.13.9)
  - [ ] Review all changes for completeness
  - [ ] Stage files:
    - [ ] `git add internal/app/command/orchestrator.go`
    - [ ] `git add internal/app/command/orchestrator_test.go`
    - [ ] `git add tests/utils/mocks.go`
  - [ ] Commit with message: `feat(app): implement CommandOrchestrator with NewNote use case`
  - [ ] Verify commit includes all necessary files
  - [ ] Linting checkpoint:
    - [ ] Run pre-commit hooks if installed
    - [ ] Verify commit message follows conventional commits format

## Dev Notes

### QA Test Design Reference

**Test Design Document:** `docs/qa/assessments/1.13-test-design-20251028.md`

This story incorporates all 15 test scenarios identified in the QA test design:
- 14 unit tests and 1 integration test covering CommandOrchestrator implementation
- All 15 scenarios are P0 priority due to critical command orchestration functionality
- Test coverage ensures proper workflow orchestration, error handling, and dependency injection

**Note:** The detailed test scenarios in AC1.13.7-1.13.9 and Tasks 1-6 are derived from this QA analysis.

### Architecture Alignment (v0.6.8)

From `docs/architecture/components.md#domain-services` - CommandOrchestrator (v0.6.4):

**Responsibility:** Orchestrate use case workflows by coordinating domain services. Acts as the application service layer that CLI, TUI, and LSP adapters invoke via CLIPort. Owns application startup and control flow.

**Key Interfaces:**
- `Run(ctx context.Context) error` - Start the application by calling CLIPort.Start()
- `NewNote(ctx context.Context, templateID TemplateID) (Note, error)` - Create new note from template (implements CommandPort)

**Dependencies:** CLIPort (injected API port), TemplateEngine, Config, Logger.

**NewNote Use Case Workflow:**

The NewNote method orchestrates the complete note creation workflow for Epic 1:

1. **Render Template:** Execute template with TemplateEngine.Render()
2. **Generate NoteID:** Derive from templateID (basename strategy for Epic 1)
3. **Create Empty Frontmatter:** No YAML parsing in Epic 1
4. **Construct Note:** Create Note object with ID and Frontmatter
5. **Persist to Vault:** Write note file to vault
6. **Return Note:** Return Note object for CLI display

**Implementation Pattern:**

```go
type CommandOrchestrator struct {
    cliPort        CLIPort
    templateEngine *TemplateEngine
    config         Config
    log            zerolog.Logger
}

func NewCommandOrchestrator(
    cliPort CLIPort,
    templateEngine *TemplateEngine,
    config Config,
    log zerolog.Logger,
) *CommandOrchestrator {
    return &CommandOrchestrator{
        cliPort:        cliPort,
        templateEngine: templateEngine,
        config:         config,
        log:            log,
    }
}

func (o *CommandOrchestrator) Run(ctx context.Context) error {
    // Hexagonal callback pattern: pass self as CommandPort handler
    return o.cliPort.Start(ctx, o)
}

func (o *CommandOrchestrator) NewNote(ctx context.Context, templateID domain.TemplateID) (domain.Note, error) {
    // Step 1: Render template
    o.log.Info().Str("templateID", string(templateID)).Msg("rendering template")
    rendered, err := o.templateEngine.Render(ctx, templateID)
    if err != nil {
        return domain.Note{}, err // ResourceError or TemplateError
    }

    // Step 2: Generate NoteID (Epic 1 strategy: use template basename)
    noteID := domain.NewNoteID(templateID.String())
    o.log.Debug().Str("noteID", string(noteID)).Msg("generated note ID")

    // Step 3: Create empty Frontmatter (no YAML parsing in Epic 1)
    frontmatter := domain.NewFrontmatter(map[string]interface{}{})

    // Step 4: Construct Note
    note := domain.NewNote(noteID, frontmatter)

    // Step 5: Write file to vault
    targetPath := filepath.Join(o.config.VaultPath, fmt.Sprintf("%s.md", noteID))
    o.log.Info().Str("path", targetPath).Msg("writing note to vault")

    if err := os.WriteFile(targetPath, []byte(rendered), 0644); err != nil {
        return domain.Note{}, fmt.Errorf("failed to write note to %s: %w", targetPath, err)
    }

    // Step 6: Return Note
    o.log.Info().Str("noteID", string(noteID)).Msg("note created successfully")
    return note, nil
}
```

**NoteID Generation Strategy (Epic 1):**

For Epic 1, use simple basename strategy:
```go
// Priority: Use templateID as NoteID
noteID := domain.NewNoteID(templateID.String())
```

Future epics will enhance this with:
- Priority 1: Explicit filename field from frontmatter
- Priority 2: Slugified title field
- Priority 3: UUID-based ID

**Prerequisites:** Story 1.2 (Note, NoteID), Story 1.4 (Config), Story 1.5 (errors), Story 1.6 (Logger), Story 1.10 (TemplateEngine), Story 1.11 (CLIPort, CommandPort)

**Time Estimate:** 4 hours

**Architecture References:**
- Components: `docs/architecture/components.md#domain-services` - CommandOrchestrator
- Change log: v0.6.4 - CommandOrchestrator as proper use case orchestrator

### Refactoring Guidelines

**SRP Decomposition Examples:**

For this story (CommandOrchestrator), functions should be decomposed into focused helpers following SRP:

**NewNote() Decomposition:**
- `orchestrate(ctx, templateID)` - Coordinate complete workflow (render → generate ID → create note → persist)
- `validate(templateID)` - Validate templateID not empty before processing
- `persist(noteID, content)` - Write note file to vault at correct path
- `logResult(noteID)` - Log successful note creation
- `handleError(err, context)` - Wrap errors with operation context
- NewNote() orchestrates these helpers for clean separation

**Run() Decomposition:**
- `Run(ctx)` - Start CLI with self as handler (hexagonal callback pattern)
- No decomposition needed - single responsibility is calling CLIPort.Start()

**When to Decompose:**
- If any method exceeds 15 lines, consider extraction
- If a method has >2 concerns, extract helpers (e.g., NewNote does render, create, persist → extract each)
- Extract file I/O operations for easier testing and error handling
- Orchestrator methods should coordinate, not implement business logic

**Naming Standards:**
- Exported types: PascalCase (CommandOrchestrator)
- Constructors: NewTypeName (NewCommandOrchestrator)
- Private helpers: camelCase (orchestrate, validate, persist, logResult, handleError)
- Methods: PascalCase for exported (Run, NewNote), camelCase for private
- Orchestration methods: verb pattern (orchestrate, coordinate, execute)

**Documentation Requirements:**
- Package comment at top of orchestrator.go explaining orchestrator purpose and hexagonal callback pattern
- All exported types and methods have GoDoc comments
- Private helpers have GoDoc or inline comments explaining purpose
- Document hexagonal callback pattern (Run passes self to CLIPort)
- Document complete workflow steps (NewNote: 6 steps documented)
- Document NoteID generation strategy (basename for Epic 1)
- Document error wrapping strategy for user-friendly messages

**Error Handling Patterns:**
- Template not found: Propagate ResourceError from TemplateEngine
- Template error: Propagate TemplateError from TemplateEngine
- File write error: Wrap with WrapWithContext("failed to write note to {path}", err)
- All errors include operation context for troubleshooting
- Structured logging: Info for workflows, Debug for details, Error for failures

**Testing Decomposition:**
- Each helper function should have dedicated unit tests
- Test orchestrator workflow: verify correct method call sequence
- Test error propagation: ResourceError, TemplateError, file write errors
- Use MockCLIPort for testing Run() without CLI dependency
- Use MockTemplateEngine for testing NewNote() without template dependency

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 1 requirements | Bob (Scrum Master) |
| 2025-10-29 | 1.1 | Enhanced with full TDD framework, SRP decomposition, linting checkpoints | QA Specialist |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5

### Debug Log References

N/A - No blocking issues encountered

### Completion Notes List

1. CommandOrchestrator implemented as proper application service layer following hexagonal architecture
2. Run() method implements hexagonal callback pattern, passing self to CLIPort.Start()
3. NewNote() workflow orchestrates 6 steps: render → generate ID → create frontmatter → construct note → write file → return
4. NoteID generation uses basename strategy for Epic 1 (templateID → noteID)
5. Empty Frontmatter created (no YAML parsing in Epic 1)
6. Error handling: ResourceError and TemplateError propagated, file write errors wrapped with context
7. MockCLIPort added to tests/utils/mocks.go for testing
8. Unit tests verify orchestration flow, handler passing, error propagation
9. Quality gates: All tests pass, linting clean, architecture v0.6.4 compliant

### File List

#### Primary Implementation
- `/Users/jack/Documents/41_personal/lithos/internal/app/command/orchestrator.go`

#### Test Files
- `/Users/jack/Documents/41_personal/lithos/internal/app/command/orchestrator_test.go`
- `/Users/jack/Documents/41_personal/lithos/tests/utils/mocks.go` (MockCLIPort)

## QA Results

### Test Coverage Summary

**Unit Tests:**
- ✅ Run() calls CLIPort.Start() with self as handler
- ✅ Run() propagates errors from CLI
- ✅ NewNote() orchestrates template rendering correctly
- ✅ NewNote() generates NoteID from templateID (basename strategy)
- ✅ NewNote() creates empty Frontmatter
- ✅ NewNote() constructs Note with NoteID and Frontmatter
- ✅ NewNote() writes file to vault at correct path
- ✅ NewNote() returns ResourceError when template not found
- ✅ NewNote() returns TemplateError on render failure
- ✅ NewNote() wraps file write errors with context

**Quality Gates:**
- ✅ `go test ./internal/app/command` - All tests pass
- ✅ `golangci-lint run internal/app/command` - No warnings or errors
- ✅ Test coverage >85%
- ✅ Architecture v0.6.4 compliant

### Key Validations

1. **Interface Implementation:** CommandOrchestrator correctly implements CommandPort
2. **Hexagonal Callback Pattern:** Run() passes self to CLIPort, enabling inversion of control
3. **Use Case Orchestration:** NewNote() coordinates domain services without business logic
4. **Error Propagation:** Template and resource errors bubble up with context
5. **File Persistence:** Notes written to vault at correct path with proper permissions
6. **Structured Logging:** Operations logged at appropriate levels (info for workflows, debug for details)
