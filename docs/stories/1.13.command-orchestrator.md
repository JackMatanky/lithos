# Story 1.13: Implement CommandOrchestrator

## Status

Draft

## Story

**As a** developer,
**I want** to implement CommandOrchestrator that orchestrates the NewNote use case workflow,
**so that** CLI commands are coordinated through domain services following hexagonal architecture.

## Acceptance Criteria

- 1.13.1: Create `internal/app/command/orchestrator.go`:
  - Constructor: `NewCommandOrchestrator(cliPort CLIPort, templateEngine *TemplateEngine, config Config, log zerolog.Logger) *CommandOrchestrator`
  - Implements CommandPort interface (from ports/api/command.go)
  - Dependencies: CLIPort (injected), TemplateEngine (injected), Config (injected), Logger (injected)

- 1.13.2: Implement `Run(ctx context.Context) error`:
  - Calls `cliPort.Start(ctx, self)` passing orchestrator as handler (hexagonal callback pattern)
  - Returns error from CLI execution

- 1.13.3: Implement `NewNote(ctx context.Context, templateID TemplateID) (Note, error)` workflow:
  - Step 1: Render template via `templateEngine.Render(ctx, templateID)`
    - Log operation: "Rendering template {templateID}"
  - Step 2: Generate NoteID from templateID (temporary strategy for Epic 1):
    - Use template basename as note filename: `noteID := domain.NewNoteID(templateID.String())`
  - Step 3: Create empty Frontmatter (no YAML parsing in Epic 1):
    - `frontmatter := domain.NewFrontmatter(map[string]interface{}{})`
  - Step 4: Construct Note:
    - `note := domain.NewNote(noteID, frontmatter)`
  - Step 5: Write rendered content to file:
    - Target path: `{Config.VaultPath}/{noteID}.md`
    - Use `os.WriteFile(path, []byte(renderedContent), 0644)`
    - Log operation: "Writing note to {path}"
  - Step 6: Return Note

- 1.13.4: Error handling:
  - Template not found → return ResourceError from TemplateEngine (propagates from TemplatePort)
  - Render error → return TemplateError from TemplateEngine
  - File write error → wrap with WrapWithContext("failed to write note to {path}", err)

- 1.13.5: Create unit tests in `internal/app/command/orchestrator_test.go`:
  - Test: Run() calls CLIPort.Start() with self as handler
  - Test: Run() propagates errors from CLI
  - Test: NewNote() orchestrates template rendering correctly
  - Test: NewNote() generates NoteID from templateID (basename strategy)
  - Test: NewNote() creates empty Frontmatter
  - Test: NewNote() constructs Note with NoteID and Frontmatter
  - Test: NewNote() writes file to vault at correct path
  - Test: NewNote() returns ResourceError when template not found
  - Test: NewNote() returns TemplateError on render failure
  - Test: NewNote() wraps file write errors with context
  - All tests use mocks from tests/utils/mocks.go (MockCLIPort, MockTemplatePort)

- 1.13.6: Add mock to `tests/utils/mocks.go`:
  - `MockCLIPort` struct implementing CLIPort interface
  - Internal field: `startCalled bool`, `startHandler CommandPort`
  - Method: `Start(ctx, handler)` stores handler and sets startCalled flag
  - Method: `WasStartCalled() bool` returns startCalled
  - Method: `GetHandler() CommandPort` returns stored handler

- 1.13.7: All tests pass: `go test ./internal/app`

- 1.13.8: All linting passes: `golangci-lint run --fix internal/app`

- 1.13.9: Committed with message: `feat(app): implement CommandOrchestrator with NewNote use case`

## Tasks / Subtasks

- [ ] Task 1: Implement CommandOrchestrator struct and constructor (AC: 1.13.1)
  - [ ] Create `internal/app/command/orchestrator.go`
  - [ ] Define CommandOrchestrator struct
  - [ ] Implement NewCommandOrchestrator constructor
  - [ ] Verify struct compiles

- [ ] Task 2: Implement Run method (AC: 1.13.2)
  - [ ] RED: Write failing test for Run() calling CLIPort.Start()
  - [ ] RED: Write failing test for Run() passing self as handler
  - [ ] GREEN: Implement Run() method
  - [ ] GREEN: Verify tests pass
  - [ ] REFACTOR: Review code

- [ ] Task 3: Implement NewNote workflow (AC: 1.13.3-1.13.4)
  - [ ] RED: Write failing test for template rendering
  - [ ] RED: Write failing test for NoteID generation
  - [ ] RED: Write failing test for Frontmatter creation
  - [ ] RED: Write failing test for Note construction
  - [ ] RED: Write failing test for file writing
  - [ ] RED: Write failing tests for error handling
  - [ ] GREEN: Implement NewNote() workflow steps 1-6
  - [ ] GREEN: Implement error handling
  - [ ] GREEN: Verify all tests pass
  - [ ] REFACTOR: Extract helpers if needed

- [ ] Task 4: Create MockCLIPort (AC: 1.13.6)
  - [ ] Add MockCLIPort to tests/utils/mocks.go
  - [ ] Implement Start() storing handler
  - [ ] Implement test helper methods
  - [ ] Verify mock satisfies interface

- [ ] Task 5: Run quality gates (AC: 1.13.7-1.13.8)
  - [ ] Run all tests and verify 100% pass
  - [ ] Run golangci-lint and fix issues
  - [ ] Verify test coverage >85%

- [ ] Task 6: Commit changes (AC: 1.13.9)
  - [ ] Review all changes
  - [ ] Commit with proper message

## Dev Notes

### Architecture Alignment (v0.6.8)

From `docs/architecture/components.md#domain-services` - CommandOrchestrator (v0.6.4):

**Responsibility:** Orchestrate use case workflows by coordinating domain services. Acts as the application service layer that CLI, TUI, and LSP adapters invoke via CLIPort. Owns application startup and control flow.

**Key Interfaces:**
- `Run(ctx context.Context) error` - Start the application by calling CLIPort.Start()
- `NewNote(ctx context.Context, templateID TemplateID) (Note, error)` - Create new note from template (implements CommandPort)

**Dependencies:** CLIPort (injected API port), TemplateEngine, Config, Logger.

**NewNote Use Case Workflow:**

The NewNote method orchestrates the complete note creation workflow for Epic 1:

1. **Render Template:** Execute template with TemplateEngine.Render()
2. **Generate NoteID:** Derive from templateID (basename strategy for Epic 1)
3. **Create Empty Frontmatter:** No YAML parsing in Epic 1
4. **Construct Note:** Create Note object with ID and Frontmatter
5. **Persist to Vault:** Write note file to vault
6. **Return Note:** Return Note object for CLI display

**Implementation Pattern:**

```go
type CommandOrchestrator struct {
    cliPort        CLIPort
    templateEngine *TemplateEngine
    config         Config
    log            zerolog.Logger
}

func NewCommandOrchestrator(
    cliPort CLIPort,
    templateEngine *TemplateEngine,
    config Config,
    log zerolog.Logger,
) *CommandOrchestrator {
    return &CommandOrchestrator{
        cliPort:        cliPort,
        templateEngine: templateEngine,
        config:         config,
        log:            log,
    }
}

func (o *CommandOrchestrator) Run(ctx context.Context) error {
    // Hexagonal callback pattern: pass self as CommandPort handler
    return o.cliPort.Start(ctx, o)
}

func (o *CommandOrchestrator) NewNote(ctx context.Context, templateID domain.TemplateID) (domain.Note, error) {
    // Step 1: Render template
    o.log.Info().Str("templateID", string(templateID)).Msg("rendering template")
    rendered, err := o.templateEngine.Render(ctx, templateID)
    if err != nil {
        return domain.Note{}, err // ResourceError or TemplateError
    }

    // Step 2: Generate NoteID (Epic 1 strategy: use template basename)
    noteID := domain.NewNoteID(templateID.String())
    o.log.Debug().Str("noteID", string(noteID)).Msg("generated note ID")

    // Step 3: Create empty Frontmatter (no YAML parsing in Epic 1)
    frontmatter := domain.NewFrontmatter(map[string]interface{}{})

    // Step 4: Construct Note
    note := domain.NewNote(noteID, frontmatter)

    // Step 5: Write file to vault
    targetPath := filepath.Join(o.config.VaultPath, fmt.Sprintf("%s.md", noteID))
    o.log.Info().Str("path", targetPath).Msg("writing note to vault")

    if err := os.WriteFile(targetPath, []byte(rendered), 0644); err != nil {
        return domain.Note{}, fmt.Errorf("failed to write note to %s: %w", targetPath, err)
    }

    // Step 6: Return Note
    o.log.Info().Str("noteID", string(noteID)).Msg("note created successfully")
    return note, nil
}
```

**NoteID Generation Strategy (Epic 1):**

For Epic 1, use simple basename strategy:
```go
// Priority: Use templateID as NoteID
noteID := domain.NewNoteID(templateID.String())
```

Future epics will enhance this with:
- Priority 1: Explicit filename field from frontmatter
- Priority 2: Slugified title field
- Priority 3: UUID-based ID

**Prerequisites:** Story 1.2 (Note, NoteID), Story 1.4 (Config), Story 1.5 (errors), Story 1.6 (Logger), Story 1.10 (TemplateEngine), Story 1.11 (CLIPort, CommandPort)

**Time Estimate:** 4 hours

**Architecture References:**
- Components: `docs/architecture/components.md#domain-services` - CommandOrchestrator
- Change log: v0.6.4 - CommandOrchestrator as proper use case orchestrator

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 1 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
