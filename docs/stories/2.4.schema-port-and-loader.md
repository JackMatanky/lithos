# Story 2.4: SchemaPort Interface & Loader Adapter

## Status

Draft

## Story

**As a** developer,
**I want** the SchemaPort SPI and filesystem loader adapter,
**so that** schemas and the property bank load through the documented boundary.

## Acceptance Criteria

**SchemaPort Interface:**

- 2.4.1: Create `internal/ports/spi/schema.go` with SchemaPort interface per `docs/architecture/components.md#schemaport`:
  - `Load(ctx context.Context) ([]Schema, PropertyBank, error)` - Load all schemas and property bank with full resolution

- 2.4.2: Add comprehensive GoDoc referencing architecture section and FR5/FR9 from `docs/prd/requirements.md`

- 2.4.3: Document that Load() returns raw schemas and property bank (no inheritance resolution - that's SchemaResolver's job)

**SchemaLoaderAdapter Structure:**

- 2.4.4: Create `internal/adapters/spi/schema/loader.go` with SchemaLoaderAdapter implementing SchemaPort

- 2.4.5: SchemaLoaderAdapter depends on Config and Logger (constructor injection)

**Property Bank Loading:**

- 2.4.6: Implement property bank loading that:
  - Resolves file path using `config.PropertyBankPath()` (joins SchemasDir + PropertyBankFile)
  - Loads property bank BEFORE schemas (required for `$ref` resolution)
  - Returns error if property bank file missing or malformed
  - Preserves unknown JSON fields (FR6 requirement)

- 2.4.7: Property bank loaded exactly once per Load() call

**Schema Loading:**

- 2.4.8: Implement schema loading that:
  - Scans `config.SchemasDir` for all `*.json` files (excluding property_bank.json)
  - Loads each schema file and unmarshals to Schema struct
  - Preserves unknown JSON fields in schemas (FR6 requirement)
  - Returns raw schemas (Extends/Excludes/Properties as-is from JSON)

- 2.4.9: Detect duplicate schema names and return error with all duplicates listed

**Error Handling:**

- 2.4.10: Wrap errors with SchemaError or ResourceError with file path context per `docs/architecture/error-handling-strategy.md`

- 2.4.11: Include remediation hints in error messages:
  - Missing property bank: "Create schemas/property_bank.json or configure PropertyBankFile"
  - Malformed JSON: "Check JSON syntax in {file_path}"
  - Duplicate names: "Schema names must be unique: {duplicates}"

- 2.4.12: Log loading progress at debug level (property bank loaded, N schemas found, loading complete)

**JSON Format:**

- 2.4.13: Use JSON format for schemas (not YAML) per architecture decision in `docs/architecture/data-models.md#propertybank`

- 2.4.14: Use Go stdlib `encoding/json` for unmarshalling

**Unit Tests:**

- 2.4.15: Create `internal/ports/spi/schema_test.go` with interface documentation tests (GoDoc examples)

- 2.4.16: Create `internal/adapters/spi/schema/loader_test.go` with tests covering:
  - Successful load: property bank + multiple schemas
  - Missing property bank file error
  - Malformed property bank JSON error
  - Malformed schema JSON error (one file invalid)
  - Duplicate schema names error
  - Empty schemas directory (no *.json files) - returns empty slice, not error
  - Property bank loaded exactly once (not per schema)

- 2.4.17: Create test fixtures in `testdata/schemas/`:
  - `property_bank.json` - Valid property bank with 2-3 properties
  - `base-note.json` - Valid root schema (no Extends)
  - `meeting-note.json` - Valid schema extending base-note
  - `invalid.json` - Malformed JSON for error testing
  - `duplicate/` subdirectory with duplicate schema name for testing

- 2.4.18: Run `golangci-lint run ./internal/ports/spi ./internal/adapters/spi/schema` and verify zero errors

- 2.4.19: Run `go test ./internal/ports/spi ./internal/adapters/spi/schema -v` and verify all tests pass

**Documentation:**

- 2.4.20: Committed with message: `feat(schema): add SchemaPort interface and filesystem loader adapter`

## Tasks / Subtasks

- [ ] Task 1: Create SchemaPort interface (AC: 2.4.1-2.4.3)
  - [ ] Create `internal/ports/spi/schema.go`
  - [ ] Define SchemaPort interface with Load() method
  - [ ] Add comprehensive GoDoc with architecture references
  - [ ] Document that Load() returns raw schemas (no resolution)

- [ ] Task 2: Create SchemaLoaderAdapter structure (AC: 2.4.4-2.4.5)
  - [ ] Create `internal/adapters/spi/schema/` directory
  - [ ] Create `loader.go` with SchemaLoaderAdapter struct
  - [ ] Add Config and Logger dependencies
  - [ ] Implement NewSchemaLoaderAdapter() constructor

- [ ] Task 3: Implement property bank loading (AC: 2.4.6-2.4.7)
  - [ ] Resolve property bank path using config.PropertyBankPath()
  - [ ] Load and unmarshal property bank JSON
  - [ ] Handle missing file error
  - [ ] Handle malformed JSON error
  - [ ] Preserve unknown JSON fields
  - [ ] Add debug logging

- [ ] Task 4: Implement schema loading (AC: 2.4.8-2.4.9)
  - [ ] Scan config.SchemasDir for *.json files
  - [ ] Filter out property_bank.json
  - [ ] Load and unmarshal each schema
  - [ ] Detect duplicate schema names
  - [ ] Preserve unknown JSON fields
  - [ ] Add debug logging

- [ ] Task 5: Implement error handling (AC: 2.4.10-2.4.12)
  - [ ] Wrap errors with SchemaError/ResourceError
  - [ ] Add file path context to errors
  - [ ] Include remediation hints
  - [ ] Add progress logging at debug level

- [ ] Task 6: Verify JSON format usage (AC: 2.4.13-2.4.14)
  - [ ] Confirm using encoding/json
  - [ ] Confirm not using YAML
  - [ ] Document JSON format decision

- [ ] Task 7: Create test fixtures (AC: 2.4.17)
  - [ ] Create `testdata/schemas/` directory
  - [ ] Create valid property_bank.json
  - [ ] Create valid schema JSONs (base-note, meeting-note)
  - [ ] Create invalid.json for error testing
  - [ ] Create duplicate/ subdirectory with duplicate name

- [ ] Task 8: Write unit tests (AC: 2.4.15-2.4.16)
  - [ ] Create port interface tests
  - [ ] Create adapter tests for successful load
  - [ ] Test missing property bank error
  - [ ] Test malformed JSON errors
  - [ ] Test duplicate names error
  - [ ] Test empty directory handling
  - [ ] Test property bank loaded once

- [ ] Task 9: Run linting and tests (AC: 2.4.18-2.4.19)
  - [ ] Run golangci-lint and fix any issues
  - [ ] Run tests and verify all pass
  - [ ] Verify test coverage is comprehensive

- [ ] Task 10: Commit changes (AC: 2.4.20)
  - [ ] Review all code and documentation
  - [ ] Commit with proper message

## Dev Notes

### Architecture References

From `docs/architecture/components.md#schemaport`:

**SchemaPort Responsibility:**
- Load all schemas and property bank definitions from storage
- Return raw schemas (Extends/Excludes/Properties as-is from JSON)
- SchemaResolver handles inheritance resolution (separate concern)
- Fail fast at startup on loading errors

**Loading Order:**
1. Load property bank first (required for `$ref` resolution)
2. Scan schemas directory for `*.json` files
3. Load and unmarshal each schema
4. Detect duplicate names
5. Return raw schemas + property bank

**JSON Format Decision:**
From `docs/architecture/data-models.md#propertybank`:
- JSON format for schemas (not YAML)
- Simpler unmarshaling than YAML
- Frontmatter remains YAML (Obsidian convention)
- Schema definitions prioritize Go stdlib integration

### Implementation Guidance

**Adapter Constructor:**
```go
type SchemaLoaderAdapter struct {
    config Config
    log    Logger
}

func NewSchemaLoaderAdapter(config Config, log Logger) *SchemaLoaderAdapter {
    return &SchemaLoaderAdapter{
        config: config,
        log:    log,
    }
}
```

**Load() Implementation Pattern:**
```go
func (a *SchemaLoaderAdapter) Load(ctx context.Context) ([]Schema, PropertyBank, error) {
    // 1. Load property bank first
    bankPath := a.config.PropertyBankPath()
    a.log.Debug().Str("path", bankPath).Msg("loading property bank")

    bank, err := a.loadPropertyBank(bankPath)
    if err != nil {
        return nil, PropertyBank{}, fmt.Errorf("failed to load property bank: %w", err)
    }

    // 2. Scan and load schemas
    a.log.Debug().Str("dir", a.config.SchemasDir).Msg("scanning schemas directory")

    schemas, err := a.loadSchemas(a.config.SchemasDir)
    if err != nil {
        return nil, PropertyBank{}, fmt.Errorf("failed to load schemas: %w", err)
    }

    // 3. Detect duplicates
    if err := a.checkDuplicates(schemas); err != nil {
        return nil, PropertyBank{}, err
    }

    a.log.Debug().Int("count", len(schemas)).Msg("schema loading complete")

    return schemas, bank, nil
}
```

**Property Bank Loading:**
```go
func (a *SchemaLoaderAdapter) loadPropertyBank(path string) (PropertyBank, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        if os.IsNotExist(err) {
            return PropertyBank{}, &ResourceError{
                Resource:    "property bank",
                Operation:   "load",
                Target:      path,
                Cause:       err,
                Remediation: "Create schemas/property_bank.json or configure PropertyBankFile",
            }
        }
        return PropertyBank{}, err
    }

    var bank PropertyBank
    if err := json.Unmarshal(data, &bank); err != nil {
        return PropertyBank{}, &SchemaError{
            Message:     "malformed property bank JSON",
            SchemaName:  path,
            Cause:       err,
            Remediation: "Check JSON syntax in " + path,
        }
    }

    return bank, nil
}
```

**Schema Loading Pattern:**
```go
func (a *SchemaLoaderAdapter) loadSchemas(dir string) ([]Schema, error) {
    var schemas []Schema

    err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
        if err != nil || info.IsDir() {
            return err
        }

        // Skip property bank file
        if filepath.Base(path) == a.config.PropertyBankFile {
            return nil
        }

        // Only process .json files
        if filepath.Ext(path) != ".json" {
            return nil
        }

        schema, err := a.loadSchema(path)
        if err != nil {
            return err
        }

        schemas = append(schemas, schema)
        return nil
    })

    return schemas, err
}
```

### Testing Strategy

From `docs/architecture/testing-strategy.md`:

**Unit Test Coverage:**
- Successful load path (property bank + multiple schemas)
- Error paths (missing files, malformed JSON, duplicates)
- Edge cases (empty directory, property bank loaded once)
- Fixture-based testing with real JSON files

**Test Fixtures Structure:**
```
testdata/schemas/
├── property_bank.json          # Valid property bank
├── base-note.json              # Root schema
├── meeting-note.json           # Schema with Extends
├── invalid.json                # Malformed JSON
└── duplicate/
    └── meeting-note.json       # Duplicate name for testing
```

**Example Test:**
```go
func TestSchemaLoaderAdapter_Load_Success(t *testing.T) {
    cfg := Config{
        SchemasDir:       "testdata/schemas",
        PropertyBankFile: "property_bank.json",
    }
    log := logger.NewTest()
    loader := NewSchemaLoaderAdapter(cfg, log)

    schemas, bank, err := loader.Load(context.Background())

    require.NoError(t, err)
    assert.NotEmpty(t, bank.Properties)
    assert.Len(t, schemas, 2) // base-note + meeting-note
}
```

### Refactoring Guidelines

**SRP Decomposition Examples:**

For this story, SchemaLoaderAdapter loads schemas from filesystem. SRP decomposition focuses on:

**SchemaLoaderAdapter:**
- Load() method: Single responsibility = orchestrate loading
  - Extract loadPropertyBank() for property bank loading (separate concern)
  - Extract loadSchemas() for schema file scanning (separate concern)
  - Extract loadSchema() for single schema loading
- loadPropertyBank(): Single responsibility = load and parse property bank file
- loadSchemas(): Single responsibility = scan directory and load all schemas
  - Extract checkDuplicates() if duplicate detection >10 lines

**When to Decompose:**
- If any method exceeds 15 lines, consider extraction
- If constructor has >2 initialization concerns, extract helpers
- If validation logic mixes with business logic, extract validators

**Naming Standards:**
- Exported types: PascalCase
- Constructors: NewTypeName
- Private helpers: camelCase, specific action verbs
- Methods: PascalCase for exported, match Go conventions
- Boolean helpers (if added): is, has, can prefix

**Documentation Requirements:**
- Package comment at top of file explaining domain models/services
- All exported types have GoDoc comments
- Constructors have GoDoc explaining parameters and return values
- Methods have GoDoc explaining behavior
- Complex logic has inline comments for clarity

### Related Components

From `docs/architecture/components.md`:

**SchemaEngine (Story 2.8):**
- Calls SchemaPort.Load() to get raw schemas and property bank
- Passes results to SchemaValidator and SchemaResolver
- Coordinates full schema loading pipeline

**SchemaResolver (Story 2.7):**
- Receives raw schemas from SchemaPort.Load()
- Resolves inheritance (Extends/Excludes)
- Substitutes `$ref` using PropertyBank
- Returns flattened schemas

**SchemaValidator (Story 2.6):**
- Validates raw schemas from SchemaPort.Load()
- Checks structural integrity and cross-schema references
- Runs before SchemaResolver

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 2 requirements | Bob (Scrum Master) |
| 2025-10-28 | 1.1 | Enhanced with full TDD framework, SRP decomposition, linting checkpoints | QA Specialist |
| 2025-10-28 | 1.0 | Story created from Epic 2 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## Testing

**Test Design:** `docs/qa/assessments/2.4-test-design-20251029.md`

## QA Results

_To be completed by QA agent after implementation_
