# Story 5.4: TemplateEngine Interactive Helpers

## Status

Draft

## Story

**As a** developer,
**I want** TemplateEngine to expose interactive helper functions,
**so that** templates can call `prompt`, `suggester`, and path utilities during rendering.

## Acceptance Criteria

**Helper Function Registration:**

- 5.5.1: Modify `internal/app/template/service.go` to register helper functions in `buildFuncMap()`:
  - Interactive functions: `prompt`, `suggester`
  - Time functions: `now`
  - Path functions: `path`, `folder`, `basename`, `extension`, `join`, `vaultPath`
  - All functions match `docs/architecture/components.md#templateengine` exactly

**Interactive Helper Functions:**

- 5.5.2: Implement `prompt` template function:
  - Signature: `prompt(name, label, default string) string`
  - Delegates to PromptPort.Prompt() with PromptConfig
  - Returns user input or default value
  - Handles errors by returning error in template execution
  - Example: `{{prompt "title" "Enter title" "Untitled"}}`

- 5.5.3: Implement `suggester` template function:
  - Signature: `suggester(name, label string, options []string) string`
  - Delegates to PromptPort.Suggester() with SuggesterConfig
  - Returns selected option
  - Handles errors by returning error in template execution
  - Example: `{{suggester "type" "Select type" (list "note" "task" "contact")}}`

**Time Helper Functions:**

- 5.5.4: Implement `now` template function:
  - Signature: `now(format string) string`
  - Uses Go time layout format (e.g., "2006-01-02")
  - Returns current timestamp formatted
  - Example: `{{now "2006-01-02"}}` returns "2025-10-28"

**Path Helper Functions:**

- 5.5.5: Implement `path` template function:
  - Signature: `path() string`
  - Returns target file path for note being created
  - Path determined by template rendering context
  - Example: `{{path}}` returns "/vault/notes/my-note.md"

- 5.5.6: Implement `folder` template function:
  - Signature: `folder(path string) string`
  - Returns parent directory of path
  - Uses `filepath.Dir()`
  - Example: `{{folder (path)}}` returns "/vault/notes"

- 5.5.7: Implement `basename` template function:
  - Signature: `basename(path string) string`
  - Returns filename without extension
  - Uses custom logic (not filepath.Base)
  - Example: `{{basename (path)}}` returns "my-note"

- 5.5.8: Implement `extension` template function:
  - Signature: `extension(path string) string`
  - Returns file extension including dot
  - Uses `filepath.Ext()`
  - Example: `{{extension (path)}}` returns ".md"

- 5.5.9: Implement `join` template function:
  - Signature: `join(parts ...string) string`
  - Joins path segments using OS-appropriate separator
  - Uses `filepath.Join()`
  - Example: `{{join (vaultPath) "notes" "my-note.md"}}`

- 5.5.10: Implement `vaultPath` template function:
  - Signature: `vaultPath() string`
  - Returns absolute vault root path from Config
  - Example: `{{vaultPath}}` returns "/Users/user/vault"

**Dependency Injection Pattern:**

- 5.5.11: Use closure pattern for helper functions:
  - Wrap PromptPort, QueryService, Config in closures
  - Inject dependencies through TemplateEngine constructor
  - No direct port access from template functions
  - Functions capture dependencies from TemplateEngine context

**Error Handling:**

- 5.5.12: Implement error handling per `docs/architecture/error-handling-strategy.md`:
  - Interactive errors bubble up to template execution
  - Template rendering fails on prompt/suggester errors
  - Error messages include remediation guidance
  - Path errors return empty string with logged warning

**Standard Library Restrictions:**

- 5.5.13: Verify only approved stdlib packages exposed:
  - `strings` - string manipulation (toLower, toUpper, etc.)
  - `path/filepath` - path operations
  - `time` - date/time formatting
  - Document any additions in architecture

**Unit Tests:**

- 5.5.14: Create `internal/app/template/helpers_test.go` with tests for:
  - Successful prompt with default value
  - Successful suggester with options
  - Now function with various formats
  - Path function returns correct path
  - Folder function extracts directory
  - Basename function extracts filename
  - Extension function extracts extension
  - Join function combines paths correctly
  - VaultPath function returns config value
  - Error propagation from PromptPort
  - Non-interactive mode handling

**Integration Tests:**

- 5.5.15: Create `tests/integration/template_helpers_test.go` with tests for:
  - Full template rendering with interactive prompts
  - Path context handling during rendering
  - Multiple prompts in single template
  - Error recovery and messaging

**Quality Gates:**

- 5.5.16: Run `golangci-lint run ./internal/app/template` - all checks pass

- 5.5.17: Run `go test ./internal/app/template` - all tests pass with >80% coverage

- 5.5.18: Run `go test ./tests/integration` - integration tests pass

- 5.5.19: Verify FR3 requirements satisfied (template functions documented)

- 5.5.20: Committed with message: `feat: add interactive and path helper functions to TemplateEngine`

## Tasks / Subtasks

- [ ] Task 1: TDD - Write failing tests for interactive helpers (AC: 5.5.14)
  - [ ] RED: Write failing test for prompt function
    - [ ] Create test file `internal/app/template/helpers_test.go`
    - [ ] Write test case for prompt() with mock PromptPort
    - [ ] Verify test fails with "undefined: prompt"
    - [ ] Run `go test ./internal/app/template` and confirm failure
  - [ ] RED: Write failing test for suggester function
    - [ ] Write test case for suggester() with mock PromptPort
    - [ ] Run tests and confirm failure
  - [ ] RED: Write failing test for error propagation
    - [ ] Write test verifying PromptPort errors propagate
    - [ ] Run tests and confirm failure
  - [ ] GREEN: Implement interactive helper functions
    - [ ] Add PromptPort field to TemplateEngine
    - [ ] Implement `registerFunction(name, fn)` helper - Single responsibility: register one function
    - [ ] Implement `executeFunction(fn)` wrapper - Single responsibility: execute with error handling
    - [ ] Implement prompt() function using closure pattern
    - [ ] Implement suggester() function using closure pattern
    - [ ] Register functions in buildFuncMap()
    - [ ] Run `go test ./internal/app/template` and verify tests pass
  - [ ] REFACTOR: Decompose into SRP components
    - [ ] Extract `registerFunction(name string, fn interface{})` - Single responsibility: add function to map
    - [ ] Extract `executeFunction(fn func() (string, error)) string` - Single responsibility: execute with error handling
    - [ ] Verify buildFuncMap() orchestrates, helpers do specific tasks
    - [ ] Add comprehensive GoDoc for all helper methods
    - [ ] Add inline comments explaining closure pattern
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run tests to verify refactoring success
    - [ ] Verify test coverage >80%
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 2: TDD - Implement time helper functions (AC: 5.5.4, 5.5.14)
  - [ ] RED: Write failing test for now function
    - [ ] Write test with standard format "2006-01-02"
    - [ ] Write test with custom format
    - [ ] Run tests and confirm failure
  - [ ] GREEN: Implement now function
    - [ ] Implement now() using time.Now()
    - [ ] Register function in buildFuncMap()
    - [ ] Run tests and verify they pass
  - [ ] REFACTOR: Review implementation
    - [ ] Verify now() has single responsibility (format current time)
    - [ ] Add GoDoc explaining time layout format
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Run tests to verify success
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 3: TDD - Implement path helper functions (AC: 5.5.5-5.5.10, 5.5.14)
  - [ ] RED: Write failing tests for path helpers
    - [ ] Write test for path() returns context path
    - [ ] Write test for folder() extracts directory
    - [ ] Write test for basename() extracts name
    - [ ] Write test for extension() extracts ext
    - [ ] Write test for join() combines paths
    - [ ] Write test for vaultPath() returns config
    - [ ] Run tests and confirm failures
  - [ ] GREEN: Implement path helper functions
    - [ ] Add path context to template execution
    - [ ] Implement `buildQuery(field, value)` helper - Single responsibility: construct query map
    - [ ] Implement path() function using closure
    - [ ] Implement folder() using filepath.Dir
    - [ ] Implement basename() (custom logic)
    - [ ] Implement extension() using filepath.Ext
    - [ ] Implement join() using filepath.Join
    - [ ] Implement vaultPath() using Config
    - [ ] Register functions in buildFuncMap()
    - [ ] Run tests and verify they pass
  - [ ] REFACTOR: Decompose into SRP components
    - [ ] Extract `buildQuery(field string, value any) map[string]any` - Single responsibility: construct query filter
    - [ ] Verify each path helper has single responsibility
    - [ ] Add GoDoc for all path functions
    - [ ] Add inline comments for custom logic (basename extraction)
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL linter warnings
    - [ ] Run tests to verify refactoring
    - [ ] Verify test coverage >80%
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 4: Implement error handling (AC: 5.5.12)
  - [ ] Handle interactive errors in template execution
  - [ ] Handle path errors with logging
  - [ ] Add remediation guidance to errors
  - [ ] Verify error propagation to caller
  - [ ] Run tests to verify error handling

- [ ] Task 5: TDD - Write failing integration tests (AC: 5.5.15)
  - [ ] RED: Write failing test for full template rendering
    - [ ] Create `tests/integration/template_helpers_test.go`
    - [ ] Write test for template with prompts
    - [ ] Write test for path context handling
    - [ ] Write test for multiple prompts
    - [ ] Run tests and confirm failures
  - [ ] GREEN: Verify integration tests pass
    - [ ] Fix any integration failures
    - [ ] Verify full rendering workflow
    - [ ] Run tests and verify they pass

- [ ] Task 6: Verify stdlib restrictions (AC: 5.5.13)
  - [ ] Audit all exposed stdlib packages
  - [ ] Verify against approved list
  - [ ] Document any additions in architecture

- [ ] Task 7: Quality verification (AC: 5.5.16-5.5.19)
  - [ ] Run golangci-lint on template package
  - [ ] Run unit tests with coverage report
  - [ ] Run integration tests
  - [ ] Verify >80% code coverage
  - [ ] Verify FR3 requirements satisfied
  - [ ] Fix any linting or test failures

- [ ] Task 8: Commit changes (AC: 5.5.20)
  - [ ] Review all changes
  - [ ] Verify tests pass
  - [ ] Commit with full and proper conventional commit style message

## Dev Notes

### TemplateEngine Architecture

From `docs/architecture/components.md#templateengine`:

**Responsibility:** Execute template rendering for `lithos new`/`find`, wiring together interactive prompts, lookups, and frontmatter validation. Pure domain service orchestrating template execution with custom function map for user interaction and file path control.

**Key Interfaces:**

- `Render(ctx context.Context, templateID TemplateID) (string, error)` - Render template to markdown string
- `Load(ctx context.Context, templateID TemplateID) (Template, error)` - Load template via TemplateLoader port

**Dependencies:** TemplateLoader (port), InteractivePort, QueryService, FrontmatterService, Config, Logger.

**Technology Stack:** Go `text/template`, custom function map with user interaction and file control functions, closures wrapping port calls for dependency injection, zerolog for instrumentation.

### Custom Template Functions

From `docs/architecture/components.md#templateengine`:

**User Interaction Functions:**

- `prompt(name, label, default)` - Text input prompt via InteractivePort
- `suggester(name, label, options)` - Selection from list via InteractivePort
- `now(format)` - Current timestamp with Go time layout format

**Vault Query Functions:** (Future stories)

- `lookup(basename)` - Find note by basename via QueryService
- `query(filter)` - Query notes by criteria via QueryService
- `fileClass(noteID)` - Get note's fileClass field

**File Path Control Functions:**

- `path()` - Returns the target file path for the note being created
- `folder(path)` - Returns parent directory of path
- `basename(path)` - Returns filename without extension
- `extension(path)` - Returns file extension
- `join(parts...)` - Joins path segments using OS-appropriate separator
- `vaultPath()` - Returns absolute vault root path from Config

### File Path Function Examples

From `docs/architecture/components.md#templateengine`:

```go
// Template can control its own save location
{{- $targetPath := join (vaultPath) "contacts" (printf "%s.md" (prompt "filename" "Filename" "")) -}}
// Sets target path for CommandOrchestrator to use when saving

// Or derive from frontmatter fields
{{- $slug := lower (replace (prompt "title" "Title" "") " " "-") -}}
{{- $targetPath := join (vaultPath) "notes" (printf "%s.md" $slug) -}}

// Access current path context (during rendering)
{{- $currentFolder := folder (path) -}}
{{- $currentName := basename (path) -}}
```

**Note:** The `path()` function returns the target path being constructed during rendering. Templates set this implicitly through frontmatter or explicitly via `$targetPath` variable. CommandOrchestrator uses the resolved path to save the note.

### Closure Pattern for Dependency Injection

**Why Closures:**

Template functions need access to ports and services, but Go's `text/template` expects functions with specific signatures. Closures allow us to capture dependencies while exposing clean template APIs:

```go
func (e *TemplateEngine) buildFuncMap() template.FuncMap {
    return template.FuncMap{
        // Closure captures e.promptPort
        "prompt": func(name, label, defaultVal string) (string, error) {
            cfg := PromptConfig{
                Name:    name,
                Label:   label,
                Default: defaultVal,
            }
            return e.promptPort.Prompt(e.ctx, cfg)
        },

        // Closure captures e.config
        "vaultPath": func() string {
            return e.config.VaultPath
        },

        // Closure captures e.pathContext
        "path": func() string {
            return e.pathContext.targetPath
        },
    }
}
```

**Benefits:**

- Clean template API (no dependency passing)
- Type-safe dependency injection
- Testable with mock ports
- No global state

### Error Handling Strategy

From `docs/architecture/error-handling-strategy.md`:

**Template Function Errors:**

Template functions can return errors, which Go's `text/template` will propagate to the template execution caller:

```go
"prompt": func(name, label, defaultVal string) (string, error) {
    result, err := e.promptPort.Prompt(e.ctx, cfg)
    if err != nil {
        // Error bubbles up to template.Execute()
        return "", fmt.Errorf("prompt %s failed: %w", name, err)
    }
    return result, nil
}
```

**Path Function Errors:**

Path functions that can't fail should return empty string and log warnings:

```go
"basename": func(path string) string {
    if path == "" {
        e.log.Warn().Msg("basename called with empty path")
        return ""
    }
    // Extract basename logic
}
```

### Standard Library Restrictions

From `docs/architecture/components.md#templateengine`:

**Approved Stdlib Packages:**

- `strings` - string manipulation (toLower, toUpper, replace, etc.)
- `path/filepath` - path operations (Dir, Ext, Join, Base)
- `time` - date/time formatting (Now, Format)

**Why Restricted:**

- Security: Limit template capabilities
- Portability: Only cross-platform packages
- Maintainability: Clear surface area
- Documentation: Explicit function catalog

**Adding Functions:**
Any new stdlib exposure must be documented in `docs/architecture/components.md#templateengine` with rationale.

### Testing Strategy

From `docs/architecture/testing-strategy.md`:

**Unit Test Structure:**

Test each helper function in isolation with mock ports:

```go
func TestPromptHelper(t *testing.T) {
    mockPort := &MockPromptPort{
        PromptFunc: func(ctx context.Context, cfg PromptConfig) (string, error) {
            return "test-value", nil
        },
    }

    engine := NewTemplateEngine(mockPort, ...)
    funcMap := engine.buildFuncMap()

    promptFunc := funcMap["prompt"].(func(string, string, string) (string, error))
    result, err := promptFunc("name", "label", "default")

    assert.NoError(t, err)
    assert.Equal(t, "test-value", result)
}
```

**Integration Test Structure:**

Test full template rendering with all helper functions:

```go
func TestTemplateWithInteractiveHelpers(t *testing.T) {
    // Setup mock ports that return predictable values
    mockPrompt := &MockPromptPort{...}

    // Create test template
    tmpl := `
---
title: {{prompt "title" "Enter title" "Default Title"}}
created: {{now "2006-01-02"}}
---
# {{.title}}
Path: {{path}}
Folder: {{folder (path)}}
`

    // Render template
    engine := NewTemplateEngine(mockPrompt, ...)
    result, err := engine.Render(ctx, templateID)

    // Verify output
    assert.NoError(t, err)
    assert.Contains(t, result, "title: Default Title")
    assert.Contains(t, result, "created: 2025-10-28")
}
```

### Path Context Handling

**Path Context Structure:**

Template execution needs path context to support path functions:

```go
type pathContext struct {
    targetPath string  // Where note will be saved
}

type TemplateEngine struct {
    // ... other fields
    pathContext *pathContext
}

func (e *TemplateEngine) Render(ctx context.Context, templateID TemplateID) (string, error) {
    // Initialize path context
    e.pathContext = &pathContext{
        targetPath: e.deriveTargetPath(templateID),
    }

    // Build function map (closures capture pathContext)
    funcMap := e.buildFuncMap()

    // Execute template
    tmpl, err := template.New("").Funcs(funcMap).Parse(content)
    // ...
}
```

**Path Derivation:**

Initial path can come from:

1. Template metadata (if template specifies location)
2. Default location based on template type
3. Modified by template during rendering (via `$targetPath` variable)

### FR3 Reference

From `docs/prd/requirements.md#fr3`:

**FR3: Template System**

- Go text/template engine with custom functions
- Interactive functions: prompt, suggester
- Time functions: now
- Path functions: path, folder, basename, extension, join, vaultPath
- Query functions: lookup, query (future)
- Functions must be documented in architecture

### Refactoring Guidelines

**SRP Decomposition for Template Helpers:**

The buildFuncMap() method orchestrates function registration, delegating specific responsibilities to focused helpers:

**Extract These Helpers:**

1. **registerFunction(name string, fn interface{})**
   - Single responsibility: Add one function to the function map
   - Takes function name and implementation
   - Returns nothing (side effect on map)
   - Why extract: Reduces duplication in buildFuncMap()

2. **executeFunction(fn func() (string, error)) string**
   - Single responsibility: Execute function with error handling
   - Wraps function execution with logging
   - Converts errors to empty string with warning
   - Why extract: Common error handling pattern

3. **buildQuery(field string, value any) map[string]any**
   - Single responsibility: Construct query filter map
   - Takes field and value, returns map suitable for QueryService
   - Used by query() helper
   - Why extract: Query construction is distinct from execution

**When to Decompose:**

- If buildFuncMap() exceeds 50 lines, extract registerFunction()
- If error handling is duplicated >2 times, extract executeFunction()
- If query construction logic is >5 lines, extract buildQuery()

**Naming Standards:**

- Helpers: camelCase, verb-object pattern (registerFunction, executeFunction, buildQuery)
- Template functions: lowercase (prompt, suggester, now, path, etc.)
- Exported types: PascalCase (TemplateEngine)

**Documentation Requirements:**

- Package comment explaining template services
- GoDoc for TemplateEngine explaining rendering workflow
- GoDoc for buildFuncMap() listing all available functions
- Inline comments for closure pattern usage
- Comments on helpers explaining single responsibility

### TDD Workflow

1. **Write failing test** for specific helper function
2. **Implement** function using closure pattern
3. **Register** function in buildFuncMap()
5. **Verify** test passes
5. **Refactor** while keeping tests green
6. **Repeat** for next function

Test order:

1. Interactive helpers (most complex)
2. Time helpers (simple)
3. Path helpers (medium complexity)
5. Integration tests (full workflow)

### Dependency Injection

From `docs/architecture/components.md#dependency-injection-pattern`:

**TemplateEngine Constructor:**

```go
func NewTemplateEngine(
    loader TemplatePort,
    prompter PromptPort,
    query QueryService,
    frontmatter FrontmatterService,
    cfg Config,
    log Logger,
) *TemplateEngine {
    return &TemplateEngine{
        loader:      loader,
        promptPort:  prompter,
        query:       query,
        frontmatter: frontmatter,
        config:      cfg,
        log:         log,
    }
}
```

All dependencies injected via constructor, captured in closures for template functions.

## Change Log

| Date       | Version | Description                                               | Author             |
| ---------- | ------- | --------------------------------------------------------- | ------------------ |
| 2025-10-28 | 1.0     | Story created from Epic 5 requirements                    | Bob (Scrum Master) |
| 2025-10-28 | 1.1     | Applied quality fixes: TDD, SRP, linting, GoDoc, coverage | QA Specialist      |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
