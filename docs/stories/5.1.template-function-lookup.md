# Story 5.1: TemplateEngine Lookup Helpers

## Status

Draft

## Story

**As a** template author,
**I want** TemplateEngine helpers for schema-aware lookups,
**so that** templates can query indexed notes directly through documented functions.

## Acceptance Criteria

**Template Function Registration:**

- 5.1.1: Verify `internal/app/template/service.go` registers `lookup`, `query`, and `fileClass` helpers in the TemplateEngine function map
- 5.1.2: Verify helpers are closures that capture QueryService and Config dependencies via TemplateEngine struct
- 5.1.3: Verify function map is passed to Go's `text/template.New().Funcs()` during template parsing
- 5.1.4: Document function signatures in `TemplateEngine.buildFunctionMap()` method

**lookup() Function:**

- 5.1.5: Implement `lookup(basename string) (Note, error)` helper that:
  - Delegates to `QueryService.ByPath(ctx, basename)`
  - Returns first matching note if found
  - Returns zero Note and non-nil error if not found
  - Returns error if multiple notes match (ambiguous basename)

- 5.1.6: Verify lookup returns immutable copy of Note (not reference to internal index)
- 5.1.7: Add unit tests for:
  - Successful lookup with exact basename match
  - Empty result when basename not found
  - Error when basename matches multiple files
  - Error propagation from QueryService

**query() Function:**

- 5.1.8: Implement `query(filter map[string]any) ([]Note, error)` helper that:
  - Extracts field name and value from filter map
  - Delegates to `QueryService.ByFrontmatter(ctx, field, value)` for each filter
  - Returns slice of matching notes (empty slice if no matches)
  - Supports common frontmatter queries (fileClass, tags, etc.)

- 5.1.9: Verify query returns immutable copies of Notes (not references to internal index)
- 5.1.10: Add unit tests for:
  - Single field filter (e.g., `{fileClass: "contact"}`)
  - Multiple results for broad filter
  - Empty results for non-matching filter
  - Error propagation from QueryService

**fileClass() Function:**

- 5.1.11: Implement `fileClass(noteID string) (string, error)` helper that:
  - Delegates to `QueryService.ByID(ctx, NoteID(noteID))`
  - Extracts frontmatter.Fields["fileClass"] from returned Note
  - Returns fileClass value as string
  - Returns error if note not found or fileClass field missing

- 5.1.12: Verify fileClass returns string type suitable for template conditionals
- 5.1.13: Add unit tests for:
  - Successful fileClass extraction
  - Error when NoteID not found
  - Error when fileClass field missing from frontmatter
  - Empty string for notes without fileClass

**Testing:**

- 5.1.14: Create unit tests in `internal/app/template/service_test.go`:
  - Test lookup: single match, not found, multiple matches, errors
  - Test query: single filter, multiple results, empty results, errors
  - Test fileClass: success, not found, missing field
  - Test immutability: mutate returned Note, verify index unchanged

- 5.1.15: All tests pass: `go test ./internal/app/template`

- 5.1.16: All linting passes: `golangci-lint run --fix internal/app/template`

- 5.1.17: Committed with message: `feat(template): add lookup, query, fileClass helpers for schema-aware template functions`

## Tasks / Subtasks

- [ ] Task 1: Implement lookup() helper (AC: 5.1.1-5.1.7)
  - [ ] RED: Write failing test for lookup success case
    - [ ] Write test case in `internal/app/template/service_test.go`
    - [ ] Create FakeQueryService returning single note
    - [ ] Verify test fails with expected error message
    - [ ] Run `go test ./internal/app/template` and confirm failure
  - [ ] RED: Write failing test for lookup not found
    - [ ] Write test case with empty QueryService result
    - [ ] Verify error message contains "not found"
    - [ ] Run `go test ./internal/app/template` and confirm failure
  - [ ] RED: Write failing test for lookup ambiguous match
    - [ ] Write test case with multiple QueryService results
    - [ ] Verify error message contains "ambiguous"
    - [ ] Run `go test ./internal/app/template` and confirm failure
  - [ ] GREEN: Implement minimal code to pass tests
    - [ ] Implement `makeLookupFunc()` returning closure over QueryService
    - [ ] Delegate to `QueryService.ByPath(ctx, basename)`
    - [ ] Handle single match, not found, multiple matches
    - [ ] Run `go test ./internal/app/template` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract registerFunction() if function map building grows >15 lines
      - [ ] Extract executeFunction() if lookup logic grows >15 lines
      - [ ] Verify makeLookupFunc has single responsibility (create closure)
      - [ ] Verify lookup closure has single responsibility (delegate to QueryService)
    - [ ] Review naming: makeLookupFunc (clear factory), lookup (clear purpose)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for makeLookupFunc explaining closure pattern
      - [ ] Add inline comment for defensive copy requirement
      - [ ] Document error cases in comments
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/template` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for lookup function
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 2: Implement query() helper (AC: 5.1.8-5.1.10)
  - [ ] RED: Write failing test for query single filter
    - [ ] Write test case in `internal/app/template/service_test.go`
    - [ ] Create FakeQueryService returning multiple notes
    - [ ] Verify test fails with expected error message
    - [ ] Run `go test ./internal/app/template` and confirm failure
  - [ ] RED: Write failing test for query empty results
    - [ ] Write test case with no matching notes
    - [ ] Verify empty slice returned (not error)
    - [ ] Run `go test ./internal/app/template` and confirm failure
  - [ ] RED: Write failing test for query error propagation
    - [ ] Write test case with QueryService error
    - [ ] Verify error propagates correctly
    - [ ] Run `go test ./internal/app/template` and confirm failure
  - [ ] GREEN: Implement minimal code to pass tests
    - [ ] Implement `makeQueryFunc()` returning closure over QueryService
    - [ ] Extract field/value from filter map
    - [ ] Delegate to `QueryService.ByFrontmatter(ctx, field, value)`
    - [ ] Run `go test ./internal/app/template` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract buildQuery() if filter parsing grows >10 lines
      - [ ] Verify makeQueryFunc has single responsibility (create closure)
      - [ ] Verify query closure has single responsibility (delegate to QueryService)
    - [ ] Review naming: makeQueryFunc (clear factory), query (clear purpose)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for makeQueryFunc explaining closure pattern
      - [ ] Document filter map format in comments
      - [ ] Document defensive copy requirement
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/template` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for query function
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 3: Implement fileClass() helper (AC: 5.1.11-5.1.13)
  - [ ] RED: Write failing test for fileClass success
    - [ ] Write test case in `internal/app/template/service_test.go`
    - [ ] Create FakeQueryService returning note with fileClass
    - [ ] Verify test fails with expected error message
    - [ ] Run `go test ./internal/app/template` and confirm failure
  - [ ] RED: Write failing test for fileClass not found
    - [ ] Write test case with QueryService returning not found error
    - [ ] Verify error propagates correctly
    - [ ] Run `go test ./internal/app/template` and confirm failure
  - [ ] RED: Write failing test for fileClass missing field
    - [ ] Write test case with note missing fileClass in frontmatter
    - [ ] Verify error message indicates missing field
    - [ ] Run `go test ./internal/app/template` and confirm failure
  - [ ] GREEN: Implement minimal code to pass tests
    - [ ] Implement `makeFileClassFunc()` returning closure over QueryService
    - [ ] Delegate to `QueryService.ByID(ctx, noteID)`
    - [ ] Extract fileClass from frontmatter.Fields
    - [ ] Run `go test ./internal/app/template` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify makeFileClassFunc has single responsibility (create closure)
      - [ ] Verify fileClass closure has single responsibility (extract fileClass from note)
      - [ ] Consider: If field extraction grows complex, extract extractFileClass()
    - [ ] Review naming: makeFileClassFunc (clear factory), fileClass (clear purpose)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for makeFileClassFunc explaining closure pattern
      - [ ] Document return value format (string for template conditionals)
      - [ ] Document error cases
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/template` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for fileClass function
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 4: Implement immutability tests (AC: 5.1.14)
  - [ ] Write test mutating returned Note from lookup
    - [ ] Return note from lookup, mutate fields
    - [ ] Call lookup again, verify original unchanged
    - [ ] Confirms defensive copy working
  - [ ] Write test mutating returned Notes from query
    - [ ] Return notes from query, mutate first note
    - [ ] Call query again, verify original unchanged
    - [ ] Confirms defensive copy working

- [ ] Task 5: Run quality gates (AC: 5.1.15-5.1.16)
  - [ ] Run `go test ./internal/app/template` and verify 100% pass
  - [ ] Run `golangci-lint run --fix internal/app/template` and fix any issues
  - [ ] Verify test coverage is adequate (>90% for template helpers)
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 6: Commit changes (AC: 5.1.17)
  - [ ] Review all changes
  - [ ] Stage files: `git add internal/app/template/service.go internal/app/template/service_test.go`
  - [ ] Commit with message: `feat(template): add lookup, query, fileClass helpers for schema-aware template functions`

## Dev Notes

### Architecture Alignment (v0.6.8)

From `docs/architecture/components.md#templateengine`:

**Custom Template Functions:**

The TemplateEngine provides a function map injected into Go's `text/template` for interactive prompts, vault queries, and file path control.

**Vault Query Functions:**
- `lookup(basename)` - Find note by basename via QueryService
- `query(filter)` - Query notes by criteria via QueryService
- `fileClass(noteID)` - Get note's fileClass field

**Template Function Implementation Pattern:**

```go
// TemplateEngine struct holds dependencies
type TemplateEngine struct {
    templateLoader TemplatePort
    interactive    InteractivePort
    queryService   QueryService
    frontmatter    FrontmatterService
    config         Config
    log            Logger
}

// buildFunctionMap creates closures over dependencies
func (e *TemplateEngine) buildFunctionMap(ctx context.Context) template.FuncMap {
    return template.FuncMap{
        "lookup":    e.makeLookupFunc(ctx),
        "query":     e.makeQueryFunc(ctx),
        "fileClass": e.makeFileClassFunc(ctx),
        "prompt":    e.makePromptFunc(ctx),
        "suggester": e.makeSuggesterFunc(ctx),
        "now":       e.makeNowFunc(),
        // ... file path functions
    }
}

// makeLookupFunc returns closure over QueryService
func (e *TemplateEngine) makeLookupFunc(ctx context.Context) func(string) (Note, error) {
    return func(basename string) (Note, error) {
        notes, err := e.queryService.ByPath(ctx, basename)
        if err != nil {
            return Note{}, fmt.Errorf("lookup failed: %w", err)
        }
        if len(notes) == 0 {
            return Note{}, fmt.Errorf("note not found: %s", basename)
        }
        if len(notes) > 1 {
            return Note{}, fmt.Errorf("ambiguous basename %s: found %d matches", basename, len(notes))
        }
        // Return defensive copy
        return notes[0].Clone(), nil
    }
}
```

### QueryService Integration

From `docs/architecture/components.md#queryservice`:

**Key Interfaces:**

- `ByID(ctx context.Context, id NoteID) (Note, error)` - Retrieve note by NoteID
- `ByPath(ctx context.Context, path string) ([]Note, error)` - Find notes by path (returns single note if file path, multiple if directory path)
- `ByFileClass(ctx context.Context, fileClass string) ([]Note, error)` - Find all notes with matching fileClass (convenience for common frontmatter query)
- `ByFrontmatter(ctx context.Context, field string, value any) ([]Note, error)` - Generic frontmatter field query

**Dependencies:** CacheReader (port), Logger.

**Technology Stack:** In-memory indices backed by Go maps with `sync.RWMutex` for concurrent safety, multiple specialized indices (by ID, path, fileClass, frontmatter fields) for fast lookups, indices populated directly by VaultIndexer after cache write.

### Template Usage Examples

```go
// Template using lookup to find contact by basename
{{- $contact := lookup "john-doe" -}}
Contact: {{$contact.Frontmatter.Fields.title}}

// Template using query to find all notes with fileClass "contact"
{{- $contacts := query (dict "fileClass" "contact") -}}
{{- range $contacts -}}
- {{.Frontmatter.Fields.title}}
{{- end -}}

// Template using fileClass to check note type
{{- $class := fileClass .ID -}}
{{- if eq $class "contact" -}}
This is a contact note
{{- end -}}
```

### Immutability Pattern

**Why Immutability Matters:**

Template functions return notes from QueryService's in-memory index. If templates could mutate these notes, they would corrupt the index. All helpers must return defensive copies.

**Defensive Copy Implementation:**

```go
// Note model needs Clone() method
func (n Note) Clone() Note {
    // Deep copy frontmatter fields map
    fields := make(map[string]any, len(n.Frontmatter.Fields))
    for k, v := range n.Frontmatter.Fields {
        fields[k] = v  // Note: assumes field values are immutable (strings, numbers, etc.)
    }

    return Note{
        ID: n.ID,
        Content: n.Content,  // strings are immutable in Go
        Frontmatter: Frontmatter{
            FileClass: n.Frontmatter.FileClass,
            Fields: fields,
        },
    }
}
```

### Testing Standards

From `docs/architecture/testing-strategy.md` and `docs/architecture/coding-standards.md`:

**Unit Test Requirements:**
- Tests live in `internal/app/template/service_test.go`
- Use table-driven tests for multiple cases
- Mock QueryService using test doubles from `tests/utils/mocks.go`
- Verify immutability with mutation tests

**TDD Workflow:**
- RED: Write failing test first
- GREEN: Implement minimum code to pass
- REFACTOR: Improve code quality while tests pass

**Quality Gates:**
- All tests pass: `go test ./internal/app/template`
- No linting errors: `golangci-lint run --fix internal/app/template`
- Test coverage >90% for template helpers

### Refactoring Guidelines

**SRP Decomposition Examples:**

For template function helpers, SRP decomposition focuses on:

**Template Function Registration:**
- buildFunctionMap: Single responsibility = create function map for template engine
- If registration grows >15 lines, extract registerFunction() per function type

**lookup() Helper:**
- makeLookupFunc: Single responsibility = create closure over QueryService
- lookup closure: Single responsibility = delegate to QueryService and return single note
- If lookup logic grows >15 lines, extract executeFunction() helper

**query() Helper:**
- makeQueryFunc: Single responsibility = create closure over QueryService
- query closure: Single responsibility = delegate to QueryService for frontmatter queries
- If filter parsing grows >10 lines, extract buildQuery() helper

**fileClass() Helper:**
- makeFileClassFunc: Single responsibility = create closure over QueryService
- fileClass closure: Single responsibility = extract fileClass from note
- If field extraction grows complex, extract extractFileClass() helper

**When to Decompose:**
- If any helper exceeds 15 lines, consider extraction
- If filter/query building has >2 concerns, extract builder
- If field extraction mixes validation with extraction, separate concerns

**Naming Standards:**
- Factory methods: makeXxxFunc (makeLookupFunc, makeQueryFunc, makeFileClassFunc)
- Helpers: specific action (buildQuery, executeFunction, extractFileClass)
- Closures: match template function names (lookup, query, fileClass)

**Documentation Requirements:**
- All factory methods have GoDoc comments explaining closure pattern
- Document defensive copy requirements in comments
- Document error cases and return values
- Explain filter map format for query function

### Common Pitfalls to Avoid

1. **DO NOT return references to internal index** - Always return defensive copies
2. **DO NOT mix template concerns with query logic** - Keep delegation clean
3. **DO NOT skip error handling** - Propagate QueryService errors with context
4. **DO ensure closures capture context** - Context needed for cancellation
5. **DO verify immutability** - Write mutation tests to confirm defensive copies

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 5 requirements | Bob (Scrum Master) |
| 2025-10-28 | 1.1 | Enhanced with full TDD framework, SRP decomposition, linting checkpoints | QA Specialist |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
