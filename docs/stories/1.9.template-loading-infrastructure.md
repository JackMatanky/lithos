# Story 1.9: Implement Template Loading Infrastructure

## Status

Draft

## Story

**As a** developer,
**I want** to implement FileMetadata model, TemplatePort interface, and TemplateLoaderAdapter,
**so that** templates can be loaded from filesystem following hexagonal architecture.

## Acceptance Criteria

**FileMetadata Model:**

- 1.9.1: Create `internal/adapters/spi/file_metadata.go`:
  - SPI adapter model (NOT domain)
  - Fields:
    - `Path string` - absolute file path
    - `Basename string` - filename without path/extension (computed)
    - `Folder string` - parent directory (computed)
    - `Ext string` - file extension including dot (computed)
    - `ModTime time.Time` - modification timestamp
    - `Size int64` - file size in bytes
    - `MimeType string` - MIME type (computed)
  - Constructor: `NewFileMetadata(path string, info fs.FileInfo) FileMetadata`
  - Helper functions:
    - `computeBasename(path string) string` - removes path and extension
    - `computeFolder(path string) string` - returns directory path
    - `computeMimeType(ext string) string` - detects MIME type from extension

- 1.9.2: Create unit tests in `internal/adapters/spi/file_metadata_test.go`:
  - Test: NewFileMetadata construction and all helper functions
  - Test: Computed fields (Basename, Folder, Ext) are correct
  - Test: MIME type detection works for common file types

**TemplatePort Interface:**

- 1.9.3: Create `internal/ports/spi/template.go`:
  - Interface: `TemplatePort`
  - Method: `List(ctx context.Context) ([]TemplateID, error)` - list available template IDs
  - Method: `Load(ctx context.Context, id TemplateID) (Template, error)` - load template by ID
  - Add documentation comments:
    - Describe port responsibility
    - Document method contracts
    - Reference architecture components.md

**TemplateLoaderAdapter:**

- 1.9.4: Create `internal/adapters/spi/template/loader.go`:
  - Implements TemplatePort interface
  - Constructor: `NewTemplateLoaderAdapter(config Config, log zerolog.Logger) *TemplateLoaderAdapter`
  - Internal metadata cache: `map[TemplateID]FileMetadata` for ID → Path mapping

- 1.9.5: Implement List() method:
  - Scan Config.TemplatesDir using `filepath.Walk`
  - Find all `.md` files
  - Derive TemplateID from basename (filename without `.md` extension)
  - Build FileMetadata for each template
  - Populate internal cache
  - Return sorted []TemplateID

- 1.9.6: Implement Load() method:
  - Look up TemplateID in metadata cache
  - If not found, return ResourceError with "template not found"
  - Read file content using `os.ReadFile`
  - Return Template with ID and Content
  - Validate UTF-8 encoding (return ValidationError if invalid)

- 1.9.7: Error handling:
  - Missing template → ResourceError with "template not found"
  - Read failure → ResourceError with wrapped os.Error
  - Invalid UTF-8 → ValidationError

**Testing:**

- 1.9.8: Create unit tests in `internal/adapters/spi/template/loader_test.go`:
  - Test: FileMetadata construction and helper functions
  - Test: List() finds all templates in testdata
  - Test: Load() reads template content correctly
  - Test: Errors returned for missing templates

- 1.9.9: Create integration test in `tests/integration/template_loader_test.go`:
  - Use existing `testdata/templates/` directory
  - Test: List() finds static-template.md and basic-note.md
  - Test: Load("static-template") returns Template with correct content
  - Test: Load("basic-note") returns Template with correct content
  - Test: Load("nonexistent") returns ResourceError

- 1.9.10: All tests pass: `go test ./internal/adapters/spi/... ./tests/integration/...`

- 1.9.11: All linting passes: `golangci-lint run --fix internal/adapters/spi internal/ports/spi`

- 1.9.12: Committed with message: `feat: implement template loading infrastructure`

## Tasks / Subtasks

- [ ] Task 1: Implement FileMetadata model (AC: 1.9.1-1.9.2)
  - [ ] RED: Write failing test for NewFileMetadata constructor
  - [ ] RED: Write failing test for computeBasename helper
  - [ ] RED: Write failing test for computeFolder helper
  - [ ] RED: Write failing test for computeMimeType helper
  - [ ] GREEN: Implement FileMetadata struct with all fields
  - [ ] GREEN: Implement NewFileMetadata constructor
  - [ ] GREEN: Implement computeBasename helper
  - [ ] GREEN: Implement computeFolder helper
  - [ ] GREEN: Implement computeMimeType helper
  - [ ] GREEN: Verify all tests pass
  - [ ] REFACTOR: Add documentation and review code

- [ ] Task 2: Define TemplatePort interface (AC: 1.9.3)
  - [ ] Create `internal/ports/spi/template.go`
  - [ ] Define TemplatePort interface with List and Load methods
  - [ ] Add comprehensive documentation comments
  - [ ] Reference architecture components.md
  - [ ] Verify interface compiles

- [ ] Task 3: Implement TemplateLoaderAdapter List() method (AC: 1.9.4-1.9.5)
  - [ ] RED: Write failing test for List() with empty directory
  - [ ] RED: Write failing test for List() with multiple templates
  - [ ] RED: Write failing test for List() sorting
  - [ ] GREEN: Implement adapter struct with constructor
  - [ ] GREEN: Implement List() using filepath.Walk
  - [ ] GREEN: Implement TemplateID derivation from basename
  - [ ] GREEN: Implement FileMetadata cache population
  - [ ] GREEN: Verify all tests pass
  - [ ] REFACTOR: Extract helpers if needed

- [ ] Task 4: Implement TemplateLoaderAdapter Load() method (AC: 1.9.6-1.9.7)
  - [ ] RED: Write failing test for Load() success case
  - [ ] RED: Write failing test for Load() with missing template
  - [ ] RED: Write failing test for Load() with read error
  - [ ] RED: Write failing test for Load() with invalid UTF-8
  - [ ] GREEN: Implement Load() method with cache lookup
  - [ ] GREEN: Implement file content reading
  - [ ] GREEN: Implement UTF-8 validation
  - [ ] GREEN: Implement error handling with proper types
  - [ ] GREEN: Verify all tests pass
  - [ ] REFACTOR: Improve error messages

- [ ] Task 5: Create integration tests (AC: 1.9.9)
  - [ ] Create `tests/integration/template_loader_test.go`
  - [ ] Test: List() finds existing templates in testdata
  - [ ] Test: Load() reads static-template.md correctly
  - [ ] Test: Load() reads basic-note.md correctly
  - [ ] Test: Load() returns error for nonexistent template
  - [ ] Verify all integration tests pass

- [ ] Task 6: Run quality gates (AC: 1.9.10-1.9.11)
  - [ ] Run `go test ./internal/adapters/spi/...` and verify 100% pass
  - [ ] Run `go test ./tests/integration/...` and verify 100% pass
  - [ ] Run `golangci-lint run --fix internal/adapters/spi internal/ports/spi` and fix issues
  - [ ] Verify test coverage >80% for adapter code

- [ ] Task 7: Commit changes (AC: 1.9.12)
  - [ ] Review all changes
  - [ ] Stage all new files
  - [ ] Commit with message: `feat: implement template loading infrastructure`

## Dev Notes

### Architecture Alignment (v0.6.8)

This story implements the template loading infrastructure per architecture v0.6.8, establishing the adapter layer that translates between filesystem (infrastructure) and domain concepts.

### FileMetadata Model

From `docs/architecture/data-models.md#filemetadata` (v0.5.1):

**Purpose:** Filesystem-specific metadata used exclusively by filesystem storage adapters. Maps NoteID/TemplateID to file paths and tracks file system state.

**Architecture Layer:** SPI Adapter (Infrastructure)

**Rationale:** FileMetadata is infrastructure model used by adapters to translate between domain identifiers and filesystem paths. Domain never depends on filesystem paths - adapters handle this translation.

**Key Attributes:**
- **Path** (string) - Absolute path to file. Serves as primary key. Immutable once set.
- **Basename** (string, computed) - Filename without path and extension. Used by template lookup function and wikilink resolution.
- **Folder** (string, computed) - Parent directory path. Used for file organization queries.
- **Ext** (string, computed) - File extension including dot. Used for file type filtering.
- **ModTime** (time.Time) - File modification timestamp. Used for staleness detection and incremental indexing.
- **Size** (int64) - File size in bytes. Used for filtering large files.
- **MimeType** (string, computed) - MIME type detected from extension or content. Used for file type classification.

**Helper Functions:**

```go
// NewFileMetadata creates FileMetadata from path and fs.FileInfo
func NewFileMetadata(path string, info fs.FileInfo) FileMetadata {
    ext := filepath.Ext(path)
    return FileMetadata{
        Path:     path,
        Basename: computeBasename(path),
        Folder:   computeFolder(path),
        Ext:      ext,
        ModTime:  info.ModTime(),
        Size:     info.Size(),
        MimeType: computeMimeType(ext),
    }
}

// computeBasename extracts basename from file path
// Removes path and extension (e.g., "/vault/note.md" → "note")
func computeBasename(path string) string {
    base := filepath.Base(path)
    return strings.TrimSuffix(base, filepath.Ext(base))
}

// computeFolder extracts parent directory from file path
func computeFolder(path string) string {
    return filepath.Dir(path)
}

// computeMimeType detects MIME type from file extension
func computeMimeType(ext string) string {
    mimeType := mime.TypeByExtension(ext)
    if mimeType == "" {
        return "application/octet-stream" // Default for unknown types
    }
    return mimeType
}
```

**Design Decisions:**
- **Adapter-only model:** Domain never sees filesystem paths - keeps infrastructure isolated
- **Computed fields cached:** Basename/Folder computed once to avoid repeated string operations
- **Staleness detection:** ModTime enables incremental indexing
- **Shared by adapters:** Both TemplateLoader and VaultReader use FileMetadata

### TemplatePort Interface

From `docs/architecture/components.md#spi-port-interfaces` - TemplatePort (v0.5.11):

**Responsibility:** Load template content from storage. Provides templates to TemplateEngine for rendering.

**Key Interfaces:**
- `List(ctx context.Context) ([]TemplateID, error)` - List available template IDs
- `Load(ctx context.Context, id TemplateID) (Template, error)` - Load template by ID

**Dependencies:** Implemented by TemplateLoaderAdapter.

**Technology Stack:** Go `os.ReadFile`, `filepath.Walk`, FileMetadata for mapping TemplateID ↔ filesystem paths.

### TemplateLoaderAdapter

From `docs/architecture/components.md#spi-adapters` - TemplateLoaderAdapter:

**Responsibility:** Implement TemplatePort by loading template content from filesystem and managing TemplateID ↔ file path mappings.

**Implementation Pattern:**

```go
type TemplateLoaderAdapter struct {
    config   Config
    log      zerolog.Logger
    metadata map[TemplateID]FileMetadata // Internal cache
}

func NewTemplateLoaderAdapter(config Config, log zerolog.Logger) *TemplateLoaderAdapter {
    return &TemplateLoaderAdapter{
        config:   config,
        log:      log,
        metadata: make(map[TemplateID]FileMetadata),
    }
}

func (a *TemplateLoaderAdapter) List(ctx context.Context) ([]TemplateID, error) {
    var templates []TemplateID

    err := filepath.Walk(a.config.TemplatesDir, func(path string, info os.FileInfo, err error) error {
        if err != nil || info.IsDir() {
            return err
        }

        if filepath.Ext(path) == ".md" {
            metadata := NewFileMetadata(path, info)
            templateID := TemplateID(metadata.Basename)

            a.metadata[templateID] = metadata
            templates = append(templates, templateID)
        }

        return nil
    })

    if err != nil {
        return nil, fmt.Errorf("failed to scan templates directory: %w", err)
    }

    sort.Slice(templates, func(i, j int) bool {
        return string(templates[i]) < string(templates[j])
    })

    return templates, nil
}

func (a *TemplateLoaderAdapter) Load(ctx context.Context, id TemplateID) (Template, error) {
    metadata, exists := a.metadata[id]
    if !exists {
        return Template{}, NewResourceError("template", "load", string(id),
            fmt.Errorf("template not found"))
    }

    content, err := os.ReadFile(metadata.Path)
    if err != nil {
        return Template{}, NewResourceError("template", "read", metadata.Path, err)
    }

    // Validate UTF-8 encoding
    if !utf8.Valid(content) {
        return Template{}, NewValidationError("content", "invalid UTF-8 encoding",
            metadata.Path, nil)
    }

    return NewTemplate(id, string(content)), nil
}
```

### Template and TemplateID Models

From `docs/architecture/data-models.md#template` (v0.5.6):

**TemplateID** - Template name used for identification and composition.
- Type: `type TemplateID string`
- Constructor: `NewTemplateID(value string) TemplateID`
- Method: `String() string`

**Template** - Executable template for note generation.
- Field: `ID TemplateID`
- Field: `Content string` (raw template text)
- Constructor: `NewTemplate(id TemplateID, content string) Template`
- NO FilePath field (infrastructure concern)
- NO Parsed field (caching concern)

### Error Handling

From `docs/architecture/components.md#shared-internal-packages` - Error Package:

**ResourceError** - Resource operations (resource, operation, target, cause):
```go
// Missing template
NewResourceError("template", "load", string(templateID),
    fmt.Errorf("template not found"))

// Read failure
NewResourceError("template", "read", path, err)
```

**ValidationError** - Property-level validation failures:
```go
// Invalid UTF-8
NewValidationError("content", "invalid UTF-8 encoding", path, nil)
```

### Testing Standards

From `docs/architecture/testing-strategy.md`:

**Unit Test Organization:**
- Unit tests in `internal/adapters/spi/template/loader_test.go`
- Integration tests in `tests/integration/template_loader_test.go`
- Use table-driven tests for multiple cases
- Test both success and error paths

**Integration Test Setup:**
- Use existing `testdata/templates/` directory
- Verify adapter works with real filesystem
- Test discovery of existing test templates
- Test error handling with missing files

**Quality Gates:**
- All unit tests pass: `go test ./internal/adapters/spi/...`
- All integration tests pass: `go test ./tests/integration/...`
- No linting errors: `golangci-lint run --fix`
- Test coverage >80% for adapter code

### File Locations

From `docs/architecture/source-tree.md`:

**Implementation:**
- `internal/adapters/spi/file_metadata.go` - FileMetadata model (shared infrastructure model)
- `internal/adapters/spi/file_metadata_test.go` - FileMetadata unit tests
- `internal/ports/spi/template.go` - TemplatePort interface definition
- `internal/adapters/spi/template/loader.go` - TemplateLoaderAdapter implementation
- `internal/adapters/spi/template/loader_test.go` - Adapter unit tests
- `tests/integration/template_loader_test.go` - Integration tests

**Test Data:**
- `testdata/templates/` - Sample template files for testing

### Technology Stack

From `docs/architecture/tech-stack.md`:

**File System Operations:**
- `os.ReadFile` - Read file content
- `filepath.Walk` - Directory traversal
- `filepath.Ext` - Extract file extension
- `filepath.Base` - Extract filename
- `filepath.Dir` - Extract directory path

**MIME Type Detection:**
- `mime.TypeByExtension` - Detect MIME type from extension

**UTF-8 Validation:**
- `utf8.Valid` - Validate UTF-8 encoding

### Common Pitfalls to Avoid

1. **DO NOT expose FileMetadata to domain** - Keep filesystem details in adapter layer
2. **DO cache FileMetadata in adapter** - Avoid repeated filesystem scans
3. **DO validate UTF-8 encoding** - Prevent invalid template content
4. **DO use sorted template lists** - Provide consistent ordering for CLI display
5. **DO use proper error types** - ResourceError for missing/read errors, ValidationError for encoding errors
6. **DO populate cache during List()** - Enable fast Load() without rescanning filesystem

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 1 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
