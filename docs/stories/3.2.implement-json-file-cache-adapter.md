# Story 3.2: Implement JSON File Cache Adapter

## Status

Draft

## Story

As a developer, I want to implement the JSONFileCacheAdapter that provides both command and query cache access, so that I have a persistent cache following the architecture.

## Acceptance Criteria

**Adapter Responsibilities:**

3.2.1: `internal/adapters/spi/cache/` contains JSONFileCacheAdapter implementing both CacheCommandPort and CacheQueryPort contracts outlined for Epic 3.[Source: docs/prd/epic-3-vault-indexing-engine.md#story-3-2-implement-json-file-cache-adapter]

3.2.2: `Store` serializes the Note aggregate to JSON files in the configured `.lithos/cache/` directory using the atomic write workflow.[Source: docs/prd/epic-3-vault-indexing-engine.md#story-3-2-implement-json-file-cache-adapter]

3.2.3: `Fetch` deserializes cached JSON into Note instances with structured error handling and path-based lookups.[Source: docs/prd/epic-3-vault-indexing-engine.md#story-3-2-implement-json-file-cache-adapter]

3.2.4: Adapter composes LocalFileSystemAdapter for filesystem access and honors tech stack guidance for JSON serialization and directory management.[Source: docs/prd/epic-3-vault-indexing-engine.md#story-3-2-implement-json-file-cache-adapter]

## Tasks / Subtasks

- [ ] Task 1 (AC: 3.2.1, 3.2.4): Scaffold adapter structure and validate cache port interfaces
  - [ ] Verify final cache port interfaces from Story 3.1 before implementation to avoid interface mismatches
- [ ] Task 1.1: Create adapter structure under `internal/adapters/spi/cache/`
  - [ ] Create `json_file_cache_adapter.go` defining `JSONFileCacheAdapter` that composes `FileSystemPort` for read/write operations.[Source: docs/architecture/components.md#jsonfilecacheadapter]
  - [ ] Provide constructor accepting config (cache directory), logger, and filesystem dependencies without importing domain services to preserve hexagonal boundaries.[Source: docs/architecture/source-tree.md#source-tree]
  - [ ] Ensure cache directory is resolved/created using configuration defaults (`CacheDir` under `.lithos/cache`).[Source: docs/architecture/data-models.md#config]

- [ ] Task 2 (AC: 3.2.2): Implement command-side operations
  - [ ] Add `Store(ctx context.Context, note domain.Note)` that marshals JSON using `encoding/json` and writes via `WriteFileAtomic`, hashing file paths to filenames when persisting.[Source: docs/architecture/components.md#jsonfilecacheadapter]
  - [ ] Implement `Remove(ctx context.Context, path string)` that deletes or archives the corresponding cache file with graceful handling when files are missing.[Source: docs/architecture/components.md#jsonfilecacheadapter]
  - [ ] Enforce context cancellation checks before long-running I/O and wrap errors with cache path metadata using the shared Result pattern.[Source: docs/architecture/coding-standards.md#core-standards]
  - [ ] Define cache-specific error types: `CacheFileNotFoundError`, `InvalidJSONError`, `CachePathError` for structured error handling

- [ ] Task 3 (AC: 3.2.3): Implement query-side operations
  - [ ] Add `Fetch(ctx context.Context, path string)` to locate, read, and unmarshal cache entries into `domain.Note`, returning structured errors when entries are missing or invalid.[Source: docs/architecture/components.md#jsonfilecacheadapter]
  - [ ] Implement `List(ctx context.Context)` to iterate over `.json` files, leveraging path hashing reversal if required, and return `Result[[]domain.Note]` suitable for QueryService consumption.[Source: docs/architecture/components.md#cachequeryport]
  - [ ] Integrate logging for recoverable parse failures while guarding against partial results corruption, in line with the error handling strategy.[Source: docs/architecture/error-handling-strategy.md#general-approach]

- [ ] Task 4 (AC: 3.2.4): Update documentation and verify quality gates
  - [ ] Extend `internal/ports/spi/README.md` to describe how JSONFileCacheAdapter satisfies both cache ports and the atomic write contract.[Source: docs/architecture/components.md#jsonfilecacheadapter]
  - [ ] Author unit tests in `internal/adapters/spi/cache/json_file_cache_adapter_test.go` using temp directories to validate store, fetch, list, and remove flows.[Source: docs/architecture/testing-strategy.md#unit-tests]
  - [ ] Run `golangci-lint run` and `go test ./...` to confirm adapter integration meets linting and coverage expectations, capturing results for the Dev Agent Record.[Source: docs/architecture/testing-strategy.md#continuous-testing]
- [ ] Task 5: Refactor implementation into single-responsibility functions
  - [ ] Decompose `Store` method into smaller functions: `marshalNote`, `hashCacheKey`, `writeAtomically`
  - [ ] Decompose `Fetch` method into: `readCacheFile`, `unmarshalNote`, `validateCacheEntry`
  - [ ] Extract path validation logic into `validateCachePath` helper function
  - [ ] Ensure each function has a single responsibility and clear error boundaries
- [ ] Task 6: Enforce linting and formatting workflow
  - [ ] Run `golangci-lint fmt`
  - [ ] Run `golangci-lint run --fix`, rectifying warnings without `//nolint` unless unavoidable
  - [ ] After each fix, rerun `golangci-lint fmt` and execute tests to ensure they pass
- [ ] Task 7: Pre-commit and commit readiness
  - [ ] Execute `pre-commit run` to confirm hooks pass
  - [ ] Stage updates and commit with a fully descriptive conventional commit message

## Dev Notes

### Previous Story Insights

- Story 3.1 (Cache ports) remains in Draft; adapter implementation must validate final port signatures before coding to avoid interface mismatches.[Source: docs/stories/3.1.implement-cqrs-cache-port-interfaces.md#status]
- **CRITICAL DEPENDENCY**: Implementation should begin only after Story 3.1 port interfaces are finalized to prevent rework
- Previous cache implementations in the codebase use atomic writes and directory creation patterns that should be followed

### Data Models

- `Note` combines `File` (path, basename, folder, mod time) with `Frontmatter` (fileClass, fields map) and is the payload persisted by the cache.[Source: docs/architecture/data-models.md#note]
- `File` uses absolute paths as primary keys with hashed filenames recommended for cache storage, ensuring unique entries per note.[Source: docs/architecture/data-models.md#file]
- `Frontmatter` preserves YAML fields, so cache persistence must retain the full map for downstream validation and querying.[Source: docs/architecture/data-models.md#frontmatter]
- Config model exposes `CacheDir` defaulting to `{VaultPath}/.lithos/cache`, which the adapter must respect and create on demand.[Source: docs/architecture/data-models.md#config]

### API Specifications

- JSONFileCacheAdapter implements both CacheCommandPort and CacheQueryPort to serve VaultIndexer and QueryService.[Source: docs/architecture/components.md#jsonfilecacheadapter]
- CacheCommandPort handles write operations invoked by VaultIndexer during indexing runs.[Source: docs/architecture/components.md#vaultindexer]
- CacheQueryPort powers QueryService read operations and needs thread-safe, deterministic iteration semantics.[Source: docs/architecture/components.md#queryservice]

### Component Specifications

- Adapter composes LocalFileSystemAdapter to reuse atomic write and directory traversal utilities, avoiding direct `os` imports in the domain.[Source: docs/architecture/components.md#jsonfilecacheadapter]
- Vault indexing workflow writes cached notes via `Store` following the sequence diagram, so adapter methods must remain fast and cancellation-aware.[Source: docs/architecture/core-workflows.md#vault-indexing-lithos-index]
- Atomic write pattern (temp file plus rename) prevents partial reads, matching VaultIndexer durability requirements.[Source: docs/architecture/components.md#jsonfilecacheadapter]

### File Locations

- Adapters reside under `internal/adapters/spi/`, with cache-specific code in the `cache` subdirectory per the source tree guide.[Source: docs/architecture/source-tree.md#source-tree]
- Tests should sit beside implementation files (`*_test.go`) and leverage `tests/utils` helpers as needed.[Source: docs/architecture/testing-strategy.md#unit-tests]

### Testing Requirements

- Maintain coverage targets of >=95 percent for `internal/app` and >=85 percent overall by adding focused unit tests for adapter behaviors.[Source: docs/architecture/testing-strategy.md#testing-philosophy]
- Use table-driven tests and temp directories to verify success, missing-file errors, invalid JSON handling, and context cancellation.[Source: docs/architecture/testing-strategy.md#unit-tests]
- Generate coverage artifacts via `just test-coverage` if additional evidence is requested; document command outputs in the Dev Agent Record.[Source: docs/architecture/testing-strategy.md#continuous-testing]

### Technical Constraints

- All public adapter methods must accept `context.Context` first and abort work when cancelled.[Source: docs/architecture/coding-standards.md#core-standards]
- Ports and adapters follow the Result pattern for structured error handling, wrapping underlying filesystem or JSON errors with cache path metadata.[Source: docs/architecture/error-handling-strategy.md#general-approach]
- Cache-specific error categories: FileNotFound (missing cache files), InvalidJSON (corrupt cache data), PathErrors (invalid cache paths), with appropriate logging levels for each
- Cache directory contents are disposable; adapter should tolerate missing files and recreate directories as needed without failing indexing runs.[Source: docs/architecture/database-schema.md#database-schema]

### Project Structure Notes

- Implementing the adapter under `internal/adapters/spi/cache/` keeps alignment with the documented directory structure; ensure no cross-imports from other adapters to maintain hexagonal boundaries.[Source: docs/architecture/source-tree.md#source-tree]

### Risk Mitigation

- **Interface Dependency Risk**: Story 3.1 cache ports still in Draft status
  - **Mitigation**: Task 1 includes explicit validation of final port interfaces before implementation
  - **Fallback**: If interfaces change during implementation, refactor will be isolated to adapter layer only
- **Cache Performance Risk**: JSON serialization could impact indexing performance
  - **Mitigation**: Use efficient JSON marshaling and implement async writes where possible
  - **Monitoring**: Add timing logs for Store/Fetch operations to detect performance issues

### Testing

- After implementation, run `go test ./...` and `golangci-lint run` to confirm no regressions and that lint rules pass, recording outcomes for QA sign-off.[Source: docs/architecture/testing-strategy.md#continuous-testing]

## Change Log

| Date       | Version | Description                                    | Author |
| ---------- | ------- | ---------------------------------------------- | ------ |
| 2025-10-21 | 1.0     | Initial story draft for JSON cache adapter     | sm     |
| 2025-10-23 | 1.1     | Applied story checklist fixes: clarified Task 5 SRP decomposition, added dependency validation, enhanced error handling guidance | sm     |

## Dev Agent Record

### Agent Model Used

_TBD_

### Debug Log References

_TBD_

### Completion Notes List

_TBD_

### File List

_TBD_

## QA Results

_TBD_
