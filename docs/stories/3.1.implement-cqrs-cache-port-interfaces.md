# Story 3.1: Implement CQRS Cache Port Interfaces

## Status

Draft

## Story

As a developer, I want to define separate command and query interfaces for the cache, so that I follow CQRS principles and have clear separation of concerns.

## Acceptance Criteria

**Port Contracts:**

3.1.1: `internal/ports/spi/` contains a `CacheCommandPort` interface with `Store` and `Remove` methods aligned to the port responsibilities defined in the architecture components.[Source: architecture/components.md#cachecommandport]

3.1.2: `CacheQueryPort` interface is defined with `Fetch` and `List` methods to serve read-side cache access per the architecture specification.[Source: architecture/components.md#cachequeryport]

3.1.3: Cache port interfaces model inputs and outputs using the `Note` aggregate composed of `File` and `Frontmatter` structures from the domain model guidance.[Source: architecture/data-models.md#note]

3.1.4: Method signatures include `context.Context` support and structured error handling consistent with the Result pattern mandated for ports.[Source: architecture/coding-standards.md#core-standards]

## Tasks / Subtasks

- [ ] Task 1 (AC: 3.1.1, 3.1.3, 3.1.4): Define `CacheCommandPort` in `internal/ports/spi/cache.go`
  - [ ] Introduce `Store(ctx context.Context, note domain.Note)` and `Remove(ctx context.Context, path string)` signatures that return `errors.Result[struct{}]` (or equivalent) to satisfy structured error handling expectations.[Source: architecture/components.md#cachecommandport]
  - [ ] Ensure GoDoc commentary documents CQRS write responsibilities and context cancellation behavior for implementers.[Source: architecture/components.md#vaultindexer]
  - [ ] Verify imports reuse existing domain packages (`internal/domain`) without introducing adapter dependencies, preserving hexagonal boundaries.[Source: architecture/components.md#domain-services]

- [ ] Task 2 (AC: 3.1.2, 3.1.3, 3.1.4): Define `CacheQueryPort` in the same file
  - [ ] Add `Fetch(ctx context.Context, path string)` returning a `Result[domain.Note]` and `List(ctx context.Context)` returning `Result[[]domain.Note]` to provide read access patterns used by QueryService.[Source: architecture/components.md#cachequeryport]
  - [ ] Include documentation for pagination or iteration considerations with references to `QueryService` usage and thread-safety expectations.[Source: architecture/components.md#queryservice]
  - [ ] Confirm both interfaces share consistent naming and method ordering, keeping the port lean (<=3 methods) per coding standards.[Source: architecture/coding-standards.md#critical-rules]

- [ ] Task 3 (AC: 3.1.1-3.1.4): Update `internal/ports/spi/README.md`
  - [ ] Document the new cache ports, their method signatures, and how adapters such as `JSONFileCacheAdapter` satisfy both command and query contracts.[Source: architecture/components.md#jsonfilecacheadapter]
  - [ ] Describe structured error expectations and context usage so adapter developers follow Result-pattern guidelines.[Source: architecture/error-handling-strategy.md#general-approach]
  - [ ] Cross-link to VaultIndexer and QueryService sections to show how the ports integrate into Epic 3 workflows.[Source: architecture/components.md#vaultindexer]

- [ ] Task 4 (AC: 3.1.4): Validate project standards after interface creation
  - [ ] Run `golangci-lint run` and `go test ./...` to ensure the new interfaces compile cleanly and do not introduce lint violations.[Source: architecture/testing-strategy.md#continuous-testing]
  - [ ] Capture checklist evidence and attach results in the Dev Agent Record upon implementation completion.

## Dev Notes

### Previous Story Insights

- Story 2.8 remains in Draft status (QA audit in progress), so there are no implementation learnings impacting cache port definitions at this time.[Source: docs/stories/2.8.review-epic-2-testing-alignment.md#status]

### Data Models

- The `Note` aggregate embeds `File` (path, basename, folder, mod time) and `Frontmatter` (FileClass, Fields map), and serves as the cache payload used by both write and read interfaces.[Source: architecture/data-models.md#note]
- `File` captures filesystem identity (absolute path primary key, derived basename/folder) which the cache uses as unique identifiers for persistence and lookup.[Source: architecture/data-models.md#file]
- `Frontmatter` preserves YAML metadata with denormalized `FileClass`, enabling schema validation and query filters that the cache must transport without loss.[Source: architecture/data-models.md#frontmatter]

### API Specifications

- `CacheCommandPort` persists index writes to the on-disk cache and is implemented by `JSONFileCacheAdapter` for the writer side of the CQRS cache.[Source: architecture/components.md#cachecommandport]
- `CacheQueryPort` serves read-side cache access and exposes `Fetch` and `List` operations for services needing indexed data.[Source: architecture/components.md#cachequeryport]
- VaultIndexer orchestrates cache writes via the command port, while QueryService consumes the query port for read operations, enforcing the CQRS separation spelled out in the architecture.[Source: architecture/components.md#vaultindexer]

### Component Specifications

- VaultIndexer coordinates FileSystemPort, CacheCommandPort, SchemaValidator, and QueryService; ports must expose context-aware methods to fit into this orchestration pipeline.[Source: architecture/components.md#vaultindexer]
- QueryService relies on CacheQueryPort behind a `sync.RWMutex` guarded index, so query interfaces should anticipate concurrent readers and efficient list operations.[Source: architecture/components.md#queryservice]
- JSONFileCacheAdapter supplies both command and query behaviors with atomic file writes, reinforcing why the port contracts must not assume specific storage mechanisms.[Source: architecture/components.md#jsonfilecacheadapter]

### File Locations

- SPI ports live under `internal/ports/spi/`, with adapters under `internal/adapters/spi/cache/`; create or update `cache.go` in the ports package and keep documentation alongside existing README guidance.[Source: architecture/source-tree.md#source-tree]
- Domain models referenced by the interfaces reside in `internal/domain/`, so the ports should import shared types from there instead of duplicating structures.[Source: architecture/source-tree.md#source-tree]

### Testing Requirements

- Port definitions do not require direct unit tests, but the change must preserve overall coverage targets (>=95 % for `internal/app`, >=85 % overall) and keep the suite green after compilation checks.[Source: architecture/testing-strategy.md#testing-philosophy]
- When adapters implement these ports in subsequent stories, they must follow table-driven tests and mock patterns outlined in the testing strategy to validate persistence and retrieval flows.[Source: architecture/testing-strategy.md#unit-tests]

### Technical Constraints

- Functions that perform I/O or long-running work, including cache operations, must accept `context.Context` as the first parameter and respect cancellation signals in downstream implementations.[Source: architecture/coding-standards.md#core-standards]
- Ports must remain lean (<=3 methods) and use the Result pattern from `internal/shared/errors` to provide structured error handling across adapter boundaries.[Source: architecture/coding-standards.md#critical-rules]
- Error handling should wrap failures with contextual metadata and propagate via the Result helper utilities defined in the shared errors package.[Source: architecture/error-handling-strategy.md#general-approach]

### Project Structure Notes

- No conflicts identified with the established source tree; adding `cache.go` under `internal/ports/spi/` keeps cache ports co-located with other SPI contracts and aligns with the documented directory layout.[Source: architecture/source-tree.md#source-tree]

### Testing

- Execute `go test ./...` and `golangci-lint run` after introducing the new interfaces to confirm the repository remains in a passing state and that CI quality gates will succeed.[Source: architecture/testing-strategy.md#continuous-testing]
- Document command outputs in the Dev Agent Record when the story moves to implementation to provide traceability for quality checks.[Source: architecture/testing-strategy.md#continuous-testing]

## Change Log

| Date       | Version | Description                                             | Author |
| ---------- | ------- | ------------------------------------------------------- | ------ |
| 2025-10-21 | 1.0     | Initial story draft for Cache CQRS port interfaces      | sm     |

## Dev Agent Record

### Agent Model Used

_TBD_

### Debug Log References

_TBD_

### Completion Notes List

_TBD_

### File List

_TBD_

## QA Results

_TBD_
