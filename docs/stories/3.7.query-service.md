# Story 3.7: QueryService

## Status

Draft

## Story

**As a** developer,
**I want** QueryService to expose the lookup methods described in the architecture,
**so that** templates and validators can retrieve indexed notes efficiently.

## Acceptance Criteria

1. `internal/app/query/service.go` implements `ByID`, `ByPath`, `ByFileClass`, `ByFrontmatter`, and `RefreshFromCache` exactly as described in `docs/architecture/components.md#queryservice`, using in-memory indices with `sync.RWMutex`.

2. Query methods satisfy FR9 by supporting lookups by path, basename, and schema-defined keys; helpers return errors consistent with `error-handling-strategy.md`.

3. Service exposes instrumentation hooks or logging recommended in the architecture appendix for query debugging.

4. Unit tests cover index population, each query method, cache refresh, concurrent reads, and error paths when entries are missing.

5. `golangci-lint run ./internal/app/query` and `go test ./internal/app/query` succeed.

## Tasks / Subtasks

- [ ] Task 1: Implement QueryService struct with in-memory indices (AC: 1)
  - [ ] RED: Write failing tests for index structure
  - [ ] GREEN: Create QueryService struct with sync.RWMutex
  - [ ] GREEN: Create index maps: byID, byPath, byBasename, byFileClass
  - [ ] REFACTOR: Document thread-safety guarantees

- [ ] Task 2: Implement query methods (AC: 1, 2)
  - [ ] RED: Write failing tests for ByID()
  - [ ] RED: Write failing tests for ByPath()
  - [ ] RED: Write failing tests for ByFileClass()
  - [ ] RED: Write failing tests for ByFrontmatter()
  - [ ] GREEN: Implement ByID using byID index with RLock
  - [ ] GREEN: Implement ByPath using byPath index with RLock
  - [ ] GREEN: Implement ByFileClass using byFileClass index with RLock
  - [ ] GREEN: Implement ByFrontmatter with field filtering
  - [ ] GREEN: Return ResourceError for missing entries
  - [ ] REFACTOR: Add query logging (debug level)

- [ ] Task 3: Implement RefreshFromCache() method (AC: 1)
  - [ ] RED: Write failing tests for cache refresh
  - [ ] GREEN: Implement RefreshFromCache using CacheReaderPort
  - [ ] GREEN: Rebuild all indices from cache
  - [ ] GREEN: Use Lock for exclusive write access
  - [ ] REFACTOR: Add refresh logging

- [ ] Task 4: Implement package-private AddNote() method
  - [ ] RED: Write failing tests for AddNote
  - [ ] GREEN: Implement AddNote for VaultIndexer integration
  - [ ] GREEN: Update all indices atomically
  - [ ] GREEN: Use Lock for exclusive write access

- [ ] Task 5: Comprehensive testing (AC: 4)
  - [ ] Test index population with sample notes
  - [ ] Test each query method (success and not found)
  - [ ] Test RefreshFromCache with fake CacheReaderPort
  - [ ] Test concurrent reads (multiple goroutines querying)
  - [ ] Test AddNote updates indices correctly
  - [ ] Verify error types and messages

- [ ] Task 6: Quality gates (AC: 5)
  - [ ] Run `golangci-lint run --fix internal/app/query`
  - [ ] Run `go test ./internal/app/query` - verify 100% pass
  - [ ] Run concurrent tests to verify thread-safety
  - [ ] Verify test coverage >90%

## Dev Notes

### QueryService Architecture

From `docs/architecture/components.md#queryservice`:

**Purpose:** Provides fast in-memory lookups for indexed notes. Enables template functions (lookup, query) and FileSpec validation.

**Thread-Safe Design:**
- Uses `sync.RWMutex` for concurrent reads
- Multiple readers can query simultaneously
- Writes (AddNote, RefreshFromCache) are exclusive

**In-Memory Indices:**

```go
type QueryService struct {
    mu sync.RWMutex

    // Primary index: NoteID → Note
    byID map[NoteID]Note

    // Path index: file path → Note
    byPath map[string]Note

    // Basename index: filename without extension → []Note
    byBasename map[string][]Note

    // FileClass index: schema name → []Note
    byFileClass map[string][]Note

    // Dependencies
    cacheReader CacheReaderPort
    log         zerolog.Logger
}
```

### Query Methods

**ByID - Lookup by NoteID:**
```go
func (q *QueryService) ByID(ctx context.Context, id NoteID) (Note, error) {
    q.mu.RLock()
    defer q.mu.RUnlock()

    note, exists := q.byID[id]
    if !exists {
        return Note{}, NewResourceError("note", "get", id.String(), errors.New("not found"))
    }

    q.log.Debug().Str("noteID", id.String()).Msg("query by ID")
    return note, nil
}
```

**ByPath - Lookup by file path:**
```go
func (q *QueryService) ByPath(ctx context.Context, path string) (Note, error) {
    q.mu.RLock()
    defer q.mu.RUnlock()

    note, exists := q.byPath[path]
    if !exists {
        return Note{}, NewResourceError("note", "get", path, errors.New("not found"))
    }

    q.log.Debug().Str("path", path).Msg("query by path")
    return note, nil
}
```

**ByFileClass - Lookup by schema name:**
```go
func (q *QueryService) ByFileClass(ctx context.Context, fileClass string) ([]Note, error) {
    q.mu.RLock()
    defer q.mu.RUnlock()

    notes, exists := q.byFileClass[fileClass]
    if !exists || len(notes) == 0 {
        return nil, nil // Return empty slice, not error
    }

    q.log.Debug().Str("fileClass", fileClass).Int("count", len(notes)).Msg("query by file class")
    return notes, nil
}
```

**ByFrontmatter - Filter by frontmatter fields:**
```go
func (q *QueryService) ByFrontmatter(ctx context.Context, filters map[string]interface{}) ([]Note, error) {
    q.mu.RLock()
    defer q.mu.RUnlock()

    var results []Note

    // Iterate all notes and filter
    for _, note := range q.byID {
        if matchesFilters(note.Frontmatter.Fields, filters) {
            results = append(results, note)
        }
    }

    q.log.Debug().Int("filters", len(filters)).Int("results", len(results)).Msg("query by frontmatter")
    return results, nil
}

func matchesFilters(fields map[string]interface{}, filters map[string]interface{}) bool {
    for key, value := range filters {
        fieldValue, exists := fields[key]
        if !exists || fieldValue != value {
            return false
        }
    }
    return true
}
```

### Index Management

**AddNote - Package-private method for VaultIndexer:**
```go
// AddNote updates indices with new note (package-private, called by VaultIndexer)
func (q *QueryService) AddNote(note Note) {
    q.mu.Lock()
    defer q.mu.Unlock()

    // Update primary index
    q.byID[note.ID] = note

    // Update path index (TODO: get path from adapter mapping)
    // For MVP, may skip or use NoteID as path key

    // Update basename index
    // basename := extractBasename(note.ID)
    // q.byBasename[basename] = append(q.byBasename[basename], note)

    // Update FileClass index
    if note.Frontmatter.FileClass != "" {
        q.byFileClass[note.Frontmatter.FileClass] = append(
            q.byFileClass[note.Frontmatter.FileClass],
            note,
        )
    }
}
```

**RefreshFromCache - Reload from persistent cache:**
```go
func (q *QueryService) RefreshFromCache(ctx context.Context) error {
    q.log.Info().Msg("refreshing query service from cache")

    // Read all notes from cache
    notes, err := q.cacheReader.List(ctx)
    if err != nil {
        return fmt.Errorf("cache refresh failed: %w", err)
    }

    // Rebuild indices
    q.mu.Lock()
    defer q.mu.Unlock()

    // Clear existing indices
    q.byID = make(map[NoteID]Note)
    q.byPath = make(map[string]Note)
    q.byBasename = make(map[string][]Note)
    q.byFileClass = make(map[string][]Note)

    // Populate from cache
    for _, note := range notes {
        q.byID[note.ID] = note

        if note.Frontmatter.FileClass != "" {
            q.byFileClass[note.Frontmatter.FileClass] = append(
                q.byFileClass[note.Frontmatter.FileClass],
                note,
            )
        }

        // TODO: Populate byPath and byBasename
    }

    q.log.Info().Int("count", len(notes)).Msg("query service refreshed")
    return nil
}
```

### FR9: Query Requirements

From `docs/prd/requirements.md#fr9`:

**Query Capabilities:**
- Lookup by NoteID (ByID)
- Lookup by file path (ByPath)
- Lookup by basename for wikilinks (basename index)
- Filter by schema (ByFileClass)
- Filter by frontmatter fields (ByFrontmatter)

**Performance:**
- In-memory indices for O(1) or O(log n) lookups
- Concurrent reads via RWMutex
- Fast enough for template rendering (<300ms total per NFR3)

### File Locations

**Implementation:**
- `internal/app/query/service.go` - QueryService implementation
- `internal/app/query/service_test.go` - Unit tests

**Dependencies:**
- `internal/ports/spi/cache.go` - CacheReaderPort
- `internal/domain/note.go` - Note, NoteID, Frontmatter models
- `internal/shared/errors/resource.go` - ResourceError

### Testing Standards

**Unit Tests:**
- Create QueryService with sample notes
- Test each query method (found and not found cases)
- Test RefreshFromCache with fake CacheReaderPort
- Test AddNote updates all indices
- Test concurrent reads (spin up 10 goroutines querying simultaneously)

**Thread-Safety Tests:**
```go
func TestQueryService_ConcurrentReads(t *testing.T) {
    qs := setupQueryServiceWithNotes(t)

    var wg sync.WaitGroup
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            _, _ = qs.ByFileClass(context.Background(), "contact")
        }()
    }

    wg.Wait() // Should complete without race conditions
}
```

**Fake CacheReaderPort:**
```go
type FakeCacheReader struct {
    notes []Note
}

func (f *FakeCacheReader) List(ctx context.Context) ([]Note, error) {
    return f.notes, nil
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 3 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
