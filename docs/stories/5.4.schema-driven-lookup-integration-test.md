# Story 5.4: Schema-Driven Lookup Integration Test

## Status

Draft

## Story

**As a** QA-focused developer,
**I want** an integration test that exercises schema-driven template lookups end to end,
**so that** future changes cannot break the combined workflow.

## Acceptance Criteria

**Integration Test Setup:**

- 5.4.1: Create `tests/integration/schema_lookup_test.go` for end-to-end schema-driven lookup testing
- 5.4.2: Set up test fixtures with real schemas, property bank, templates, and vault notes (no mocks)
- 5.4.3: Use `testdata/` directory for fixtures following `docs/architecture/testing-strategy.md` conventions
- 5.4.4: Document fixture layout in test file comments

**Fixture Structure:**

- 5.4.5: Create test schema: `testdata/schema/valid/contact.json` with FileSpec property
- 5.4.6: Create test property bank: `testdata/schema/properties/property_bank.json` with standard properties
- 5.4.7: Create test vault notes:
  - `testdata/notes/contacts/john-doe.md` (contact note)
  - `testdata/notes/contacts/jane-smith.md` (contact note)
  - `testdata/notes/projects/project-alpha.md` (project note referencing contacts)

- 5.4.8: Create test template: `testdata/templates/project-with-contacts.md` using lookup/query helpers
- 5.4.9: Create golden file: `testdata/golden/project-with-contacts.md` for output verification

**Test Case 1: Template Lookup Helper:**

- 5.4.10: Test template that uses `{{lookup "john-doe"}}` to find contact by basename
- 5.4.11: Verify TemplateEngine correctly delegates to QueryService
- 5.4.12: Verify rendered output includes contact data from frontmatter
- 5.4.13: Compare rendered output against golden file

**Test Case 2: Template Query Helper:**

- 5.4.14: Test template that uses `{{query (dict "fileClass" "contact")}}` to find all contacts
- 5.4.15: Verify TemplateEngine correctly delegates to QueryService
- 5.4.16: Verify rendered output includes all contact notes
- 5.4.17: Compare rendered output against golden file

**Test Case 3: Template FileClass Helper:**

- 5.4.18: Test template that uses `{{fileClass .ID}}` to check note type
- 5.4.19: Verify TemplateEngine correctly delegates to QueryService
- 5.4.20: Verify template conditionals work based on fileClass value
- 5.4.21: Compare rendered output against golden file

**Test Case 4: FileSpec Validation:**

- 5.4.22: Create note with FileSpec frontmatter field referencing `[[john-doe]]`
- 5.4.23: Index vault to populate QueryService cache
- 5.4.24: Validate frontmatter using FrontmatterService
- 5.4.25: Verify validation succeeds when file exists
- 5.4.26: Verify validation fails with clear error when file missing

**Test Case 5: CommandOrchestrator NewNote Workflow:**

- 5.4.27: Test full note creation workflow using template with lookup helpers
- 5.4.28: Verify template renders with interactive prompts (mocked for test)
- 5.4.29: Verify frontmatter validates including FileSpec references
- 5.4.30: Verify note persists to vault and cache
- 5.4.31: Verify created note appears in subsequent QueryService lookups

**Error Handling Tests:**

- 5.4.32: Test lookup failure when basename not found
- 5.4.33: Test query returning empty results for non-matching filter
- 5.4.34: Test fileClass failure when note missing fileClass field
- 5.4.35: Test FileSpec validation failure with helpful error message
- 5.4.36: Verify all errors include remediation hints per FR8

**Golden File Verification:**

- 5.4.37: Implement golden file comparison helper function
- 5.4.38: Generate golden files from first test run (with review)
- 5.4.39: Verify subsequent test runs match golden files exactly
- 5.4.40: Document golden file regeneration procedure in test comments

**Test Isolation:**

- 5.4.41: Verify each test case runs in isolated context (fresh vault, cache, indices)
- 5.4.42: Use temp directories for vault and cache writes to avoid pollution
- 5.4.43: Clean up temp directories after test completion
- 5.4.44: Verify tests pass when run individually and in suite

**Documentation:**

- 5.4.45: Update `docs/architecture/testing-strategy.md` with integration test section
- 5.4.46: Document command: `go test ./tests/integration -run SchemaLookup -v`
- 5.4.47: Document fixture layout and golden file conventions
- 5.4.48: Document how to regenerate golden files when behavior changes

**CI Integration:**

- 5.4.49: Verify integration tests run in CI pipeline
- 5.4.50: Verify tests have reasonable timeout (< 10 seconds total)
- 5.4.51: Document CI configuration in `.github/workflows/` (future story)

**Committed:**

- 5.4.52: Committed with message: `test(integration): add schema-driven lookup end-to-end regression tests`

## Tasks / Subtasks

- [ ] Task 1: Set up integration test file and fixtures (AC: 5.4.1-5.4.9)
  - [ ] Create `tests/integration/schema_lookup_test.go`
  - [ ] Create fixture directories in `testdata/`
  - [ ] Create test schema: `contact.json`
  - [ ] Create test property bank
  - [ ] Create test vault notes (john-doe, jane-smith, project-alpha)
  - [ ] Create test template using lookup/query helpers
  - [ ] Document fixture layout in comments

- [ ] Task 2: Implement Test Case 1 (lookup helper) (AC: 5.4.10-5.4.13)
  - [ ] Write test for `{{lookup "john-doe"}}`
  - [ ] Spin up TemplateEngine with real QueryService and fixtures
  - [ ] Render template and verify output
  - [ ] Create golden file for comparison

- [ ] Task 3: Implement Test Case 2 (query helper) (AC: 5.4.14-5.4.17)
  - [ ] Write test for `{{query (dict "fileClass" "contact")}}`
  - [ ] Verify all contacts returned
  - [ ] Compare against golden file

- [ ] Task 4: Implement Test Case 3 (fileClass helper) (AC: 5.4.18-5.4.21)
  - [ ] Write test for `{{fileClass .ID}}`
  - [ ] Test template conditionals based on fileClass
  - [ ] Compare against golden file

- [ ] Task 5: Implement Test Case 4 (FileSpec validation) (AC: 5.4.22-5.4.26)
  - [ ] Create note with FileSpec frontmatter
  - [ ] Index vault to populate cache
  - [ ] Validate frontmatter (success case)
  - [ ] Test validation failure with missing file

- [ ] Task 6: Implement Test Case 5 (NewNote workflow) (AC: 5.4.27-5.4.31)
  - [ ] Test full CommandOrchestrator.NewNote workflow
  - [ ] Mock interactive prompts for test
  - [ ] Verify note creation and persistence
  - [ ] Verify note appears in subsequent lookups

- [ ] Task 7: Implement error handling tests (AC: 5.4.32-5.4.36)
  - [ ] Test lookup failure (not found)
  - [ ] Test query empty results
  - [ ] Test fileClass failure
  - [ ] Test FileSpec validation failure
  - [ ] Verify error messages include remediation hints

- [ ] Task 8: Implement golden file verification (AC: 5.4.37-5.4.40)
  - [ ] Create golden file comparison helper
  - [ ] Generate initial golden files
  - [ ] Document regeneration procedure
  - [ ] Verify golden file matching

- [ ] Task 9: Ensure test isolation (AC: 5.4.41-5.4.44)
  - [ ] Use temp directories for each test
  - [ ] Clean up after tests
  - [ ] Verify individual and suite execution

- [ ] Task 10: Update documentation (AC: 5.4.45-5.4.48)
  - [ ] Update `docs/architecture/testing-strategy.md`
  - [ ] Document test command
  - [ ] Document fixture layout
  - [ ] Document golden file regeneration

- [ ] Task 11: CI integration verification (AC: 5.4.49-5.4.51)
  - [ ] Verify tests run in CI
  - [ ] Verify reasonable timeout
  - [ ] Document CI configuration requirements

- [ ] Task 12: Commit changes (AC: 5.4.52)
  - [ ] Run `go test ./tests/integration -run SchemaLookup -v`
  - [ ] Run `golangci-lint run`
  - [ ] Commit with conventional commit message

## Dev Notes

### Integration Test Philosophy

From `docs/architecture/testing-strategy.md`:

**Integration Tests:**

- Live in `tests/integration/`
- Exercise multiple components together with real implementations (no mocks for core services)
- Use real fixtures from `testdata/` directory
- Verify end-to-end workflows that unit tests cannot catch
- Protect against regression when changing component interactions

**What Integration Tests DO:**

- Test component interactions (TemplateEngine → QueryService → Cache)
- Test full workflows (template render → frontmatter validate → note persist)
- Test with real data (actual schemas, notes, templates)
- Verify golden file outputs (expected vs actual)

**What Integration Tests DO NOT:**

- Test individual component logic (that's unit tests)
- Use mocks for domain services (use real implementations)
- Test external infrastructure (filesystem adapters tested separately)

### Test Fixture Layout

```
testdata/
├── schema/
│   ├── valid/
│   │   ├── contact.json         # Contact schema with FileSpec
│   │   └── project.json         # Project schema with FileSpec array
│   └── properties/
│       └── property_bank.json   # Standard properties (title, tags, etc.)
├── notes/
│   ├── contacts/
│   │   ├── john-doe.md          # Contact: John Doe
│   │   └── jane-smith.md        # Contact: Jane Smith
│   └── projects/
│       └── project-alpha.md     # Project referencing contacts
├── templates/
│   ├── project-with-contacts.md # Template using lookup/query helpers
│   └── contact-reference.md     # Template with FileSpec validation
└── golden/
    ├── project-with-contacts.md # Expected output for template render
    └── contact-reference.md     # Expected output for FileSpec validation
```

### Example Test Schema (contact.json)

```json
{
  "name": "contact",
  "properties": [
    {
      "name": "fileClass",
      "spec": {
        "type": "string",
        "enum": ["contact"]
      },
      "required": true,
      "array": false
    },
    {
      "name": "title",
      "spec": {
        "type": "string"
      },
      "required": true,
      "array": false
    },
    {
      "name": "email",
      "spec": {
        "type": "string",
        "pattern": "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
      },
      "required": false,
      "array": false
    },
    {
      "name": "references",
      "spec": {
        "type": "file"
      },
      "required": false,
      "array": true
    }
  ]
}
```

### Example Test Note (john-doe.md)

```markdown
---
fileClass: contact
title: John Doe
email: john@example.com
references:
  - "[[jane-smith]]"
  - "projects/project-alpha.md"
---

# John Doe

Contact information for John Doe.

## Projects

- Project Alpha
```

### Example Test Template (project-with-contacts.md)

```markdown
---
fileClass: project
title: {{prompt "title" "Project Title" ""}}
contacts: []
---

# {{.Frontmatter.Fields.title}}

## Team Contacts

{{- $contacts := query (dict "fileClass" "contact") -}}
{{- range $contacts -}}
- {{.Frontmatter.Fields.title}} ({{.Frontmatter.Fields.email}})
{{- end -}}

## Primary Contact

{{- $primary := lookup (prompt "primary" "Primary Contact Basename" "") -}}
Primary: {{$primary.Frontmatter.Fields.title}}
```

### Integration Test Implementation

```go
package integration

import (
    "context"
    "os"
    "path/filepath"
    "testing"

    "github.com/JackMatanky/lithos/internal/app/template"
    "github.com/JackMatanky/lithos/internal/app/query"
    "github.com/JackMatanky/lithos/internal/app/frontmatter"
    "github.com/JackMatanky/lithos/internal/app/schema"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

// TestSchemaLookup exercises schema-driven template lookups end-to-end
func TestSchemaLookup(t *testing.T) {
    // Set up test environment with fixtures
    ctx := context.Background()
    env := setupTestEnvironment(t)
    defer env.cleanup()

    t.Run("lookup helper finds note by basename", func(t *testing.T) {
        // Load template that uses {{lookup "john-doe"}}
        tmpl, err := env.templateEngine.Load(ctx, "contact-lookup")
        require.NoError(t, err)

        // Render template
        rendered, err := env.templateEngine.Render(ctx, tmpl)
        require.NoError(t, err)

        // Verify rendered output matches golden file
        golden := loadGoldenFile(t, "contact-lookup.md")
        assert.Equal(t, golden, rendered)
    })

    t.Run("query helper finds all notes by fileClass", func(t *testing.T) {
        tmpl, err := env.templateEngine.Load(ctx, "contact-list")
        require.NoError(t, err)

        rendered, err := env.templateEngine.Render(ctx, tmpl)
        require.NoError(t, err)

        // Verify all contacts appear in output
        assert.Contains(t, rendered, "John Doe")
        assert.Contains(t, rendered, "Jane Smith")

        // Verify against golden file
        golden := loadGoldenFile(t, "contact-list.md")
        assert.Equal(t, golden, rendered)
    })

    t.Run("fileClass helper returns note schema", func(t *testing.T) {
        tmpl, err := env.templateEngine.Load(ctx, "conditional-template")
        require.NoError(t, err)

        rendered, err := env.templateEngine.Render(ctx, tmpl)
        require.NoError(t, err)

        // Verify conditional logic based on fileClass worked
        golden := loadGoldenFile(t, "conditional-output.md")
        assert.Equal(t, golden, rendered)
    })

    t.Run("FileSpec validation checks file existence", func(t *testing.T) {
        // Create frontmatter with valid FileSpec reference
        fm := Frontmatter{
            FileClass: "project",
            Fields: map[string]any{
                "title":      "Test Project",
                "references": []string{"[[john-doe]]", "contacts/jane-smith.md"},
            },
        }

        // Validate should succeed (files exist in test vault)
        err := env.frontmatterService.Validate(ctx, fm)
        assert.NoError(t, err)
    })

    t.Run("FileSpec validation fails for missing file", func(t *testing.T) {
        fm := Frontmatter{
            FileClass: "project",
            Fields: map[string]any{
                "title":      "Test Project",
                "references": []string{"[[missing-contact]]"},
            },
        }

        // Validate should fail with helpful error
        err := env.frontmatterService.Validate(ctx, fm)
        require.Error(t, err)
        assert.Contains(t, err.Error(), "file not found")
        assert.Contains(t, err.Error(), "missing-contact")
    })

    t.Run("NewNote workflow with lookup helpers", func(t *testing.T) {
        // Mock interactive prompts for test
        env.setPromptResponses(map[string]string{
            "title":   "New Project",
            "primary": "john-doe",
        })

        // Create note using template with lookup helpers
        note, err := env.orchestrator.NewNote(ctx, "project-with-contacts")
        require.NoError(t, err)

        // Verify note created
        assert.Equal(t, NoteID("new-project"), note.ID)

        // Verify note contains data from lookup
        assert.Contains(t, note.Content, "John Doe")

        // Verify note appears in subsequent lookups
        found, err := env.queryService.ByID(ctx, note.ID)
        require.NoError(t, err)
        assert.Equal(t, note.ID, found.ID)
    })
}

// testEnvironment holds all components for integration testing
type testEnvironment struct {
    t                  *testing.T
    tempDir            string
    config             Config
    schemaEngine       *schema.Engine
    queryService       *query.Service
    frontmatterService *frontmatter.Service
    templateEngine     *template.Engine
    orchestrator       *CommandOrchestrator
    cleanup            func()
}

// setupTestEnvironment creates real components with test fixtures
func setupTestEnvironment(t *testing.T) *testEnvironment {
    // Create temp directory for vault and cache
    tempDir := t.TempDir()

    // Copy test fixtures to temp directory
    copyFixtures(t, "testdata/notes", filepath.Join(tempDir, "vault"))
    copyFixtures(t, "testdata/templates", filepath.Join(tempDir, "templates"))
    copyFixtures(t, "testdata/schema", filepath.Join(tempDir, "schemas"))

    // Configure components with temp paths
    config := Config{
        VaultPath:     filepath.Join(tempDir, "vault"),
        TemplatesDir:  filepath.Join(tempDir, "templates"),
        SchemasDir:    filepath.Join(tempDir, "schemas"),
        CachePath:     filepath.Join(tempDir, ".lithos/cache"),
    }

    // Instantiate real components (no mocks)
    log := logger.NewTest()

    schemaLoader := schema.NewLoaderAdapter(config, log)
    schemaRegistry := schema.NewRegistryAdapter(log)
    schemaEngine := schema.NewEngine(schemaLoader, schemaRegistry, log)
    require.NoError(t, schemaEngine.Load(context.Background()))

    cacheWriter := cache.NewJSONWriter(config, log)
    cacheReader := cache.NewJSONReader(config, log)

    queryService := query.NewService(cacheReader, log)

    frontmatterService := frontmatter.NewService(schemaRegistry, queryService, log)

    templateLoader := template.NewLoaderAdapter(config, log)
    prompter := &FakePrompter{} // Fake for interactive prompts
    templateEngine := template.NewEngine(templateLoader, prompter, queryService, frontmatterService, config, log)

    vaultReader := vault.NewReaderAdapter(config, log)
    vaultWriter := vault.NewWriterAdapter(config, log)

    vaultIndexer := indexer.NewVaultIndexer(vaultReader, frontmatterService, cacheWriter, queryService, log, config)

    // Index vault to populate cache
    _, err := vaultIndexer.Build(context.Background())
    require.NoError(t, err)

    cliAdapter := &FakeCLIAdapter{}
    orchestrator := NewCommandOrchestrator(
        cliAdapter,
        templateEngine,
        vaultIndexer,
        queryService,
        frontmatterService,
        schemaEngine,
        vaultWriter,
        cacheWriter,
        config,
        log,
    )

    return &testEnvironment{
        t:                  t,
        tempDir:            tempDir,
        config:             config,
        schemaEngine:       schemaEngine,
        queryService:       queryService,
        frontmatterService: frontmatterService,
        templateEngine:     templateEngine,
        orchestrator:       orchestrator,
        cleanup:            func() { os.RemoveAll(tempDir) },
    }
}

// loadGoldenFile loads expected output from testdata/golden/
func loadGoldenFile(t *testing.T, filename string) string {
    path := filepath.Join("testdata", "golden", filename)
    content, err := os.ReadFile(path)
    require.NoError(t, err, "failed to load golden file: %s", path)
    return string(content)
}

// copyFixtures recursively copies test fixtures to temp directory
func copyFixtures(t *testing.T, src, dst string) {
    err := filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }

        // Compute destination path
        relPath, _ := filepath.Rel(src, path)
        dstPath := filepath.Join(dst, relPath)

        if info.IsDir() {
            return os.MkdirAll(dstPath, 0755)
        }

        // Copy file
        data, err := os.ReadFile(path)
        if err != nil {
            return err
        }
        return os.WriteFile(dstPath, data, 0644)
    })
    require.NoError(t, err, "failed to copy fixtures from %s to %s", src, dst)
}
```

### Golden File Regeneration

**When to Regenerate Golden Files:**

- Template rendering behavior changes (intentional)
- Frontmatter validation error messages change
- Query result formatting changes

**How to Regenerate:**

1. Update expected behavior in code
2. Run tests with `UPDATE_GOLDEN=1` environment variable:
   ```bash
   UPDATE_GOLDEN=1 go test ./tests/integration -run SchemaLookup -v
   ```
3. Review generated golden files for correctness
4. Commit updated golden files with behavior change

**Implementation:**

```go
func loadGoldenFile(t *testing.T, filename string) string {
    path := filepath.Join("testdata", "golden", filename)

    // Check if we should update golden files
    if os.Getenv("UPDATE_GOLDEN") == "1" {
        // Return empty string - test will write new golden file
        return ""
    }

    content, err := os.ReadFile(path)
    require.NoError(t, err, "failed to load golden file: %s", path)
    return string(content)
}

func assertGoldenMatch(t *testing.T, filename string, actual string) {
    path := filepath.Join("testdata", "golden", filename)

    if os.Getenv("UPDATE_GOLDEN") == "1" {
        // Write new golden file
        err := os.MkdirAll(filepath.Dir(path), 0755)
        require.NoError(t, err)
        err = os.WriteFile(path, []byte(actual), 0644)
        require.NoError(t, err)
        t.Logf("Updated golden file: %s", path)
        return
    }

    // Load and compare
    golden := loadGoldenFile(t, filename)
    assert.Equal(t, golden, actual, "output does not match golden file: %s", path)
}
```

### Testing Strategy Documentation

From `docs/architecture/testing-strategy.md`:

**Integration Test Command:**

```bash
# Run all integration tests
go test ./tests/integration -v

# Run specific integration test
go test ./tests/integration -run SchemaLookup -v

# Update golden files
UPDATE_GOLDEN=1 go test ./tests/integration -run SchemaLookup -v
```

**Fixture Layout:**

See "Test Fixture Layout" section above for directory structure.

**Golden File Conventions:**

- Golden files live in `testdata/golden/`
- Named to match test case: `contact-lookup.md`, `contact-list.md`, etc.
- Regenerate when expected behavior changes
- Commit golden files with behavior changes for review

### Functional Requirements Coverage

**FR3: Template Interactivity**

> Templates execute with interactive prompts for missing data using InteractivePort. Functions like {{prompt}} and {{suggester}} provide UX hooks.

Integration tests verify template helpers (lookup, query, fileClass) work alongside interactive prompts in full rendering workflow.

**FR8: Query Hints**

> Validation errors should include helpful suggestions like similar file paths or case corrections.

Integration tests verify FileSpec validation errors include query hints from QueryService.

**FR9: Schema-Driven Templates**

> Templates can reference properties from schema definitions to guide rendering and validation. TemplateEngine queries SchemaRegistry for property constraints during execution.

Integration tests verify end-to-end schema-driven workflow: template render → frontmatter validate → note persist.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 5 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
