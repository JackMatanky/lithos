# Story 1.13: Write Rendered Template to File

## Status: Ready for Review

## Story

As a user, I want the `lithos new <template-path>` command to create a new Markdown file using the `FileSystemPort`, so that a complete note is generated atomically.

## Acceptance Criteria

- 1.13.1: The `WriteFileAtomic` method on the `FileSystemPort` is used to write the rendered content to a new file.
- 1.13.2: The new filename is identical to the template's base filename and is created in the current working directory.
- 1.13.3: A confirmation message is printed to standard output after the file is successfully written.

## Dev Notes

### Previous Story Insights

Story 1.12 "Generate Rendered Template Content" completed the template rendering process, producing a final content string ready for file writing. This story builds directly on that by persisting the rendered content to disk using the FileSystemPort for atomic writes.

### Data Models

No new data models are required for this story. The story uses the existing `Template` model from `internal/domain/template.go` to access the template's base filename for the output file naming.

### API Specifications

The story extends the `new` command's functionality from story 1.9. The command now accepts a `<template-path>` argument and uses the `FileSystemPort` for both reading the template (already implemented) and writing the rendered output.

### Component Specifications

**FileSystemPort Integration:**
- The `WriteFileAtomic` method is used to ensure atomic file creation, preventing partial writes that could corrupt the output file.
- Method signature: `WriteFileAtomic(path string, data []byte) error`
- Implementation: LocalFileSystemAdapter uses temp file + rename pattern for atomicity.

**Command Flow:**
- The `new` command's `RunE` function now includes file writing after template rendering.
- Error handling propagates from the FileSystemPort through the command to the user.
- Success confirmation is printed to stdout using the shared logger.

### File Locations

- **Command Implementation:** `internal/adapters/api/cli/new.go` (extends existing new command)
- **FileSystemPort:** `internal/ports/spi/filesystem.go`
- **LocalFileSystemAdapter:** `internal/adapters/spi/filesystem/local.go`
- **Output File:** Created in current working directory with template's base filename + ".md" extension

### Testing Requirements

Unit tests for the new command functionality, including:

- Successful file creation with rendered content
- Error handling for file write failures
- Atomic write behavior verification (no partial files on failure)
- Confirmation message output
- Context cancellation support
- Performance benchmarks for file write operations
- File size limit validation

Integration tests to verify end-to-end command execution with actual file creation.

### Technical Constraints

- **Atomic Writes:** Must use `WriteFileAtomic` to ensure complete file creation or no file at all.
- **Filename Generation:** Output filename matches template's base filename (without path/extension).
- **Current Directory:** Files are created in the current working directory, not relative to template location.
- **Error Propagation:** File system errors must be clearly communicated to the user.
- **Confirmation Output:** Success message must be printed to stdout, not stderr.

### Performance Characteristics

- **Write Time:** File creation completes in < 100ms for typical rendered content (< 10KB)
- **File Size Limits:** Maximum recommended file size is 1MB for atomic writes (configurable in future versions)
- **Memory Usage:** O(n) space complexity where n is content size, plus temporary file overhead
- **Scalability:** Linear performance scaling with content size
- **Atomicity Guarantee:** No partial files created on failure, ensuring data integrity

### Project Structure Alignment

The implementation follows the hexagonal architecture:
- Domain logic remains in `internal/app/command/`
- File I/O is abstracted through `FileSystemPort`
- CLI adapter in `internal/adapters/api/cli/`
- SPI adapter in `internal/adapters/spi/filesystem/`

## Tasks / Subtasks

- [ ] Task 1: Extend the `new` command to write rendered content to file
  - [ ] Modify `internal/adapters/api/cli/new.go` to call `WriteFileAtomic` after rendering
  - [ ] Pass context.Context from command execution to file operations
  - [ ] Generate output filename from template's base filename
  - [ ] Add confirmation message printing to stdout

- [ ] Task 2: Update command error handling for file operations
  - [ ] Propagate FileSystemPort errors through the command's RunE function
  - [ ] Ensure clear error messages for file write failures

- [ ] Task 3: Add unit tests for file writing functionality
  - [ ] Test successful file creation with rendered content
  - [ ] Test error handling for write failures
  - [ ] Test atomic write behavior (no partial files on failure)
  - [ ] Test confirmation message output

- [ ] Task 4: Add integration tests for end-to-end command flow
  - [ ] Test complete `lithos new <template>` command execution
  - [ ] Verify output file creation in current directory
  - [ ] Verify file content matches rendered template

- [ ] Task 5: Update documentation and commit changes
  - [ ] Ensure all pre-commit hooks pass (golangci-lint run and gitleaks detect)
  - [ ] Commit changes with conventional commit message

### Source References

- FileSystemPort: `docs/architecture/components.md#spi-port-interfaces`
- LocalFileSystemAdapter: `docs/architecture/components.md#spi-adapters`
- File System: `docs/architecture/tech-stack.md#file-system`
- Testing: `docs/architecture/testing-strategy.md#unit-tests`
- Coding Standards: `docs/architecture/coding-standards.md#error-handling`

