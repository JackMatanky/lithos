# Story 1.13: Write Rendered Template to File

## Status: Ready for Review

## Story

As a user, I want the `lithos new <template-path>` command to create a new Markdown file using the `FileSystemPort`, so that a complete note is generated atomically.

## Acceptance Criteria

- 1.13.1: The `WriteFileAtomic` method on the `FileSystemPort` is used to write the rendered content to a new file.
- 1.13.2: The new filename is identical to the template's base filename and is created in the current working directory.
- 1.13.3: A confirmation message is printed to standard output after the file is successfully written.

## Dev Notes

### Previous Story Insights

Story 1.12 "Generate Rendered Template Content" completed the template rendering process, producing a final content string ready for file writing. This story builds directly on that by persisting the rendered content to disk using the FileSystemPort for atomic writes.

### Data Models

No new data models are required for this story. The story uses the existing `Template` model from `internal/domain/template.go` to access the template's base filename for the output file naming.

### API Specifications

The story extends the `new` command's functionality from story 1.9. The command now accepts a `<template-path>` argument and uses the `FileSystemPort` for both reading the template (already implemented) and writing the rendered output.

### Component Specifications

**FileSystemPort Integration:**
- The `WriteFileAtomic` method is used to ensure atomic file creation, preventing partial writes that could corrupt the output file.
- Method signature: `WriteFileAtomic(path string, data []byte) error`
- Implementation: LocalFileSystemAdapter uses temp file + rename pattern for atomicity.

**Command Flow:**
- The `new` command's `RunE` function now includes file writing after template rendering.
- Error handling propagates from the FileSystemPort through the command to the user.
- Success confirmation is printed to stdout using the shared logger.

### File Locations

- **Command Implementation:** `internal/adapters/api/cli/new.go` (extends existing new command)
- **FileSystemPort:** `internal/ports/spi/filesystem.go`
- **LocalFileSystemAdapter:** `internal/adapters/spi/filesystem/local.go`
- **Output File:** Created in current working directory with template's base filename + ".md" extension

### Testing Requirements

Unit tests for the new command functionality, including:

- Successful file creation with rendered content
- Error handling for file write failures
- Atomic write behavior verification (no partial files on failure)
- Confirmation message output
- Context cancellation support
- Performance benchmarks for file write operations
- File size limit validation

Integration tests to verify end-to-end command execution with actual file creation.

### Technical Constraints

- **Atomic Writes:** Must use `WriteFileAtomic` to ensure complete file creation or no file at all.
- **Filename Generation:** Output filename matches template's base filename (without path/extension).
- **Current Directory:** Files are created in the current working directory, not relative to template location.
- **Error Propagation:** File system errors must be clearly communicated to the user.
- **Confirmation Output:** Success message must be printed to stdout, not stderr.

### Performance Characteristics

- **Write Time:** File creation completes in < 100ms for typical rendered content (< 10KB)
- **File Size Limits:** Maximum recommended file size is 1MB for atomic writes (configurable in future versions)
- **Memory Usage:** O(n) space complexity where n is content size, plus temporary file overhead
- **Scalability:** Linear performance scaling with content size
- **Atomicity Guarantee:** No partial files created on failure, ensuring data integrity

### Project Structure Alignment

The implementation follows the hexagonal architecture:
- Domain logic remains in `internal/app/command/`
- File I/O is abstracted through `FileSystemPort`
- CLI adapter in `internal/adapters/api/cli/`
- SPI adapter in `internal/adapters/spi/filesystem/`

## Tasks / Subtasks

- [x] Task 1: Extend the `new` command to write rendered content to file
  - [x] Modify `internal/adapters/api/cli/new.go` to call `WriteFileAtomic` after rendering
  - [x] Pass context.Context from command execution to file operations
  - [x] Generate output filename from template's base filename
  - [x] Add confirmation message printing to stdout

- [x] Task 2: Update command error handling for file operations
  - [x] Propagate FileSystemPort errors through the command's RunE function
  - [x] Ensure clear error messages for file write failures

- [x] Task 3: Add unit tests for file writing functionality
  - [x] Test successful file creation with rendered content
  - [x] Test error handling for write failures
  - [x] Test atomic write behavior (no partial files on failure)
  - [x] Test confirmation message output

- [x] Task 4: Add integration tests for end-to-end command flow
  - [x] Test complete `lithos new <template>` command execution
  - [x] Verify output file creation in current directory
  - [x] Verify file content matches rendered template

- [x] Task 5: Update documentation and commit changes
  - [x] Ensure all pre-commit hooks pass (golangci-lint run and gitleaks detect)
  - [x] Commit changes with conventional commit message

### Source References

- FileSystemPort: `docs/architecture/components.md#spi-port-interfaces`
- LocalFileSystemAdapter: `docs/architecture/components.md#spi-adapters`
- File System: `docs/architecture/tech-stack.md#file-system`
- Testing: `docs/architecture/testing-strategy.md#unit-tests`
- Coding Standards: `docs/architecture/coding-standards.md#error-handling`

## Dev Agent Record

### Agent Model Used
- Claude 3.5 Sonnet (claude-3-5-sonnet-20241022)

### Debug Log References
```bash
# Build and test commands
go build -mod=readonly -o lithos cmd/lithos/main.go
go test -mod=readonly ./internal/adapters/api/cli -v
./lithos new test-simple.txt

# Manual testing
echo "# Test {{toLower \"TEMPLATE\"}} - {{now \"2006-01-02\"}}" > test-simple.txt
./lithos new test-simple.txt
cat test-simple.md
# Output: # Test template - 2025-10-19
```

### Completion Notes List
1. **File Writing Implementation**: Extended the `new` command to write rendered template content to files using `WriteFileAtomic` for atomic writes, ensuring no partial files on failure.

2. **Function Decomposition**: Refactored the `NewCommand` function from 66 lines to under 60 lines by extracting helper functions (`executeNewCommand`, `readAndParseTemplate`, `executeTemplate`, `writeOutputFile`) to improve readability and maintainability.

3. **Comprehensive Testing**: Added 12 test scenarios covering:
   - Unit tests: Successful file creation with template function execution
   - Unit tests: Error handling for write failures and filename generation
   - Integration tests: End-to-end functionality with real filesystem operations in `tests/integration/`
   - Test data: Created proper test templates in `testdata/templates/` following project conventions
   - Atomic write behavior verification with large template content

4. **Error Handling**: Implemented proper error propagation from FileSystemPort through the command interface with clear, contextual error messages including file paths and operations.

5. **Output Confirmation**: Added confirmation message printing to stdout in format "Created {filename}.md" after successful file creation.

### File List
**Modified Files:**
- `internal/adapters/api/cli/new.go` - Extended new command with file writing capability
- `internal/adapters/api/cli/cobra_adapter_test.go` - Updated mock filesystem port and existing tests

**New Files:**
- `tests/integration/new_command_test.go` - Integration tests for end-to-end functionality
- `testdata/templates/integration-test-template.txt` - Test template for integration tests
- `testdata/templates/large-integration-template.txt` - Large template for atomic write testing

### Change Log
- **2025-10-19**: Implemented file writing functionality for Story 1.13
  - Added `WriteFileAtomic` call to new command after template rendering
  - Generated output filename from template base name with .md extension
  - Added confirmation message output to stdout
  - Refactored command logic into helper functions for maintainability
  - Added comprehensive unit tests in CLI package and integration tests in `tests/integration/`
  - Created test data files in `testdata/templates/` following project conventions
  - Fixed linting issues (function length, error checking, formatting)
  - All tests passing, command verified working end-to-end
