# Story 1.6: Logger Package

## Status

Draft

## Story

**As a** developer,
**I want** to implement structured logging with zerolog,
**so that** the application has consistent, structured logging across all components with configurable output formats.

## Acceptance Criteria

- 1.6.1: Add `github.com/rs/zerolog` v1.34.0 to `go.mod`

- 1.6.2: Create `internal/shared/logger/logger.go`:
  - Global `Log zerolog.Logger` instance
  - `New(output io.Writer, level string) zerolog.Logger` - creates configured logger
  - TTY detection via `golang.org/x/term` - pretty-print for terminals, JSON for pipes
  - Level parsing: "debug", "info", "warn", "error" (case-insensitive)

- 1.6.3: Context methods:
  - `WithComponent(logger zerolog.Logger, component string) zerolog.Logger`
  - `WithOperation(logger zerolog.Logger, operation string) zerolog.Logger`
  - `WithCorrelationID(logger zerolog.Logger, id string) zerolog.Logger`

- 1.6.4: Sensitive data filtering:
  - Filter password, token, apiKey fields from logs
  - Redact with "[REDACTED]" string

- 1.6.5: Test helper:
  - `NewTest() zerolog.Logger` - returns logger with ioutil.Discard for testing

- 1.6.6: Create unit tests in `internal/shared/logger/logger_test.go`:
  - Test: Log level configuration works
  - Test: TTY detection switches output format
  - Test: Context methods add fields correctly
  - Test: Sensitive data filtering works

- 1.6.7: All tests pass: `go test ./internal/shared/logger`

- 1.6.8: All linting passes: `golangci-lint run --fix internal/shared/logger`

- 1.6.9: Committed with message: `feat(shared): implement logger package with zerolog`

## Tasks / Subtasks

- [ ] Task 1: Add zerolog dependency (AC: 1.6.1)
  - [ ] Run `go get github.com/rs/zerolog@v1.34.0`
  - [ ] Run `go get golang.org/x/term@v0.25.0` (TTY detection)
  - [ ] Verify dependencies in go.mod
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/shared/logger`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 2: Implement logger constructor and TTY detection (AC: 1.6.2)
  - [ ] RED: Write failing test for New() constructor
    - [ ] Write test case in `internal/shared/logger/logger_test.go`
    - [ ] Verify test fails with expected error message
    - [ ] Run `go test ./internal/shared/logger` and confirm failure
  - [ ] GREEN: Implement New() with level parsing
    - [ ] Implement New() function
    - [ ] Run `go test ./internal/shared/logger` and verify pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract createLogger() helper for logger initialization
      - [ ] Extract configureTTY() helper for terminal detection and setup
      - [ ] Extract parseLevel() helper for level string parsing
    - [ ] Review naming: New() (idiomatic), createLogger(), configureTTY(), parseLevel()
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Package comment at top of logger.go
      - [ ] GoDoc for New() explaining TTY detection and level parsing
      - [ ] GoDoc for createLogger() helper
      - [ ] GoDoc for configureTTY() with terminal vs pipe behavior
      - [ ] GoDoc for parseLevel() with supported level strings
    - [ ] Run `golangci-lint run --fix internal/shared/logger`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/shared/logger` to verify refactoring didn't break tests
    - [ ] Verify test coverage >70% for adapters
  - [ ] RED: Write test for pretty-print vs JSON mode
    - [ ] Write test with mock TTY and non-TTY outputs
    - [ ] Run `go test ./internal/shared/logger` and confirm failure
  - [ ] GREEN: Implement ConsoleWriter for TTY, JSON for pipes
    - [ ] Implement TTY detection logic using x/term
    - [ ] Run `go test ./internal/shared/logger` and verify pass
    - [ ] Verify no other tests broken
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/shared/logger`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 3: Implement context methods (AC: 1.6.3)
  - [ ] RED: Write failing test for WithComponent()
    - [ ] Write test case verifying component field added
    - [ ] Run `go test ./internal/shared/logger` and confirm failure
  - [ ] GREEN: Implement WithComponent() adding component field
    - [ ] Implement WithComponent() method
    - [ ] Run `go test ./internal/shared/logger` and verify pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify WithComponent() has single responsibility (add component field)
      - [ ] Verify WithOperation() has single responsibility (add operation field)
      - [ ] Verify WithCorrelationID() has single responsibility (add correlation ID field)
    - [ ] Review naming: With* pattern (consistent), descriptive field names
    - [ ] Add comprehensive GoDoc comments:
      - [ ] GoDoc for WithComponent() explaining usage and chaining
      - [ ] GoDoc for WithOperation() explaining usage
      - [ ] GoDoc for WithCorrelationID() explaining usage
      - [ ] Example code showing method chaining pattern
    - [ ] Run `golangci-lint run --fix internal/shared/logger`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/shared/logger` to verify refactoring didn't break tests
    - [ ] Verify test coverage >70% for context methods
  - [ ] RED: Write failing test for WithOperation()
    - [ ] Write test case verifying operation field added
    - [ ] Run `go test ./internal/shared/logger` and confirm failure
  - [ ] GREEN: Implement WithOperation() adding operation field
    - [ ] Implement WithOperation() method
    - [ ] Run `go test ./internal/shared/logger` and verify pass
    - [ ] Verify no other tests broken
  - [ ] RED: Write failing test for WithCorrelationID()
    - [ ] Write test case verifying correlation_id field added
    - [ ] Run `go test ./internal/shared/logger` and confirm failure
  - [ ] GREEN: Implement WithCorrelationID() adding id field
    - [ ] Implement WithCorrelationID() method
    - [ ] Run `go test ./internal/shared/logger` and verify pass
    - [ ] Verify no other tests broken
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/shared/logger`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 4: Implement sensitive data filtering (AC: 1.6.4)
  - [ ] RED: Write failing test for password redaction
    - [ ] Write test case logging password field
    - [ ] Verify password should be redacted
    - [ ] Run `go test ./internal/shared/logger` and confirm failure
  - [ ] GREEN: Implement field filter for password
    - [ ] Implement SensitiveFieldHook
    - [ ] Run `go test ./internal/shared/logger` and verify pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract setupFiltering() helper to configure hook
      - [ ] Extract isSensitiveField() helper to check field names
      - [ ] Extract redactValue() helper to replace sensitive values
    - [ ] Review naming: SensitiveFieldHook (clear), setupFiltering(), isSensitiveField()
    - [ ] Add comprehensive GoDoc comments:
      - [ ] GoDoc for SensitiveFieldHook explaining purpose
      - [ ] GoDoc for setupFiltering() with list of filtered fields
      - [ ] GoDoc for isSensitiveField() explaining matching logic
      - [ ] Inline comments explaining why specific fields are sensitive
    - [ ] Run `golangci-lint run --fix internal/shared/logger`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/shared/logger` to verify refactoring didn't break tests
    - [ ] Verify test coverage >70% for filtering
  - [ ] RED: Write test for multiple sensitive fields
    - [ ] Test password, token, and apiKey redaction
    - [ ] Run `go test ./internal/shared/logger` and confirm test behavior
  - [ ] GREEN: Verify all sensitive fields redacted
    - [ ] Add token and apiKey to filter list
    - [ ] Run `go test ./internal/shared/logger` and verify pass
    - [ ] Verify no other tests broken
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/shared/logger`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 5: Implement test helper (AC: 1.6.5)
  - [ ] RED: Write test verifying NewTest() produces no output
    - [ ] Write test creating logger with NewTest()
    - [ ] Verify no output produced when logging
    - [ ] Run `go test ./internal/shared/logger` and confirm behavior
  - [ ] GREEN: Implement NewTest() with ioutil.Discard
    - [ ] Implement NewTest() returning disabled logger
    - [ ] Run `go test ./internal/shared/logger` and verify pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify NewTest() has single responsibility (create test logger)
    - [ ] Review naming: NewTest() (idiomatic for test helpers)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] GoDoc for NewTest() explaining test usage
      - [ ] Example showing NewTest() in test code
    - [ ] Run `golangci-lint run --fix internal/shared/logger`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/shared/logger` to verify refactoring didn't break tests
    - [ ] Verify test coverage >70%
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/shared/logger`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 6: Complete test coverage (AC: 1.6.6)
  - [ ] Test log level parsing (all levels)
  - [ ] Test TTY detection behavior
  - [ ] Test context method chaining
  - [ ] Test sensitive data redaction
  - [ ] Test invalid log level handling (fallback to info)
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/shared/logger`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 7: Verify tests and linting (AC: 1.6.7-1.6.8)
  - [ ] Run `go test ./internal/shared/logger` - verify all pass
  - [ ] Run `golangci-lint run --fix internal/shared/logger` - verify no warnings
  - [ ] Review test coverage for completeness
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/shared/logger`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 8: Commit changes (AC: 1.6.9)
  - [ ] Stage logger package files
  - [ ] Commit with message: `feat(shared): implement logger package with zerolog`

## Dev Notes

### QA Test Design Reference

**Test Design Document:** `docs/qa/assessments/1.6-test-design-20251028.md`

This story incorporates all 17 unit test scenarios identified in the QA test design:
- UNIT-001 through UNIT-017 covering logger construction, context methods, security filtering, and helper functions
- 8 P0 priority scenarios for critical logging functionality, 5 P1 for standard features, 4 P2 for edge cases
- Test coverage ensures proper zerolog integration, context enrichment, and security compliance

**Note:** The detailed test scenarios in AC1.6.6-1.6.7 and Tasks 1-5 are derived from this QA analysis.

### Logger Package Architecture

From `docs/architecture/components.md#shared-internal-packages`:

**Logger Responsibility:** Centralized structured logging wrapper around zerolog. Provides consistent log formatting across all components. Supports both JSON (machine-readable) and pretty-print (human-readable) output modes. Filters sensitive data and provides context-aware logging.

**Architecture Layer:** Shared Internal Package (Cross-Cutting Concern). Used by all layers. Not domain logic or infrastructure—pure technical concern. Centralized to enforce consistent logging patterns.

**Key Interfaces:**
- `Log zerolog.Logger` - Global logger instance
- `WithComponent(component string) zerolog.Logger` - Add component context
- `WithOperation(operation string) zerolog.Logger` - Add operation context
- `WithCorrelationID(id string) zerolog.Logger` - Add correlation ID

**Dependencies:**
- ConfigPort - For log level configuration
- `golang.org/x/term` - For TTY detection (pretty-print vs JSON)

[Source: docs/architecture/components.md#logger]

From `docs/architecture/tech-stack.md`:

**Logging:** `github.com/rs/zerolog` v1.34.0
- High-performance zero-allocation JSON logger with CLI-friendly pretty-print mode
- PRD explicitly specifies
- Supports both machine-readable (JSON) and human-readable (colorized) output
- Latest release Mar 2025

[Source: docs/architecture/tech-stack.md]

From `docs/architecture/coding-standards.md`:

- Shared logging (`internal/shared/logger`) **MUST** be the only logging facility; no `fmt.Print*` or `log.*`.

[Source: docs/architecture/coding-standards.md]

### Logger Implementation Patterns

**TTY Detection Pattern:**
```go
import (
    "os"
    "github.com/rs/zerolog"
    "golang.org/x/term"
)

func New(output io.Writer, level string) zerolog.Logger {
    logLevel := parseLevel(level)

    // Detect if output is a TTY
    if f, ok := output.(*os.File); ok && term.IsTerminal(int(f.Fd())) {
        // Pretty-print for terminals
        output = zerolog.ConsoleWriter{
            Out:        output,
            TimeFormat: "15:04:05",
        }
    }
    // else: JSON format for pipes/files

    return zerolog.New(output).
        Level(logLevel).
        With().
        Timestamp().
        Logger()
}
```

**Level Parsing Pattern:**
```go
func parseLevel(level string) zerolog.Level {
    switch strings.ToLower(level) {
    case "debug":
        return zerolog.DebugLevel
    case "info":
        return zerolog.InfoLevel
    case "warn", "warning":
        return zerolog.WarnLevel
    case "error":
        return zerolog.ErrorLevel
    default:
        return zerolog.InfoLevel // Fallback
    }
}
```

**Context Methods Pattern:**
```go
func WithComponent(logger zerolog.Logger, component string) zerolog.Logger {
    return logger.With().Str("component", component).Logger()
}

func WithOperation(logger zerolog.Logger, operation string) zerolog.Logger {
    return logger.With().Str("operation", operation).Logger()
}

func WithCorrelationID(logger zerolog.Logger, id string) zerolog.Logger {
    return logger.With().Str("correlation_id", id).Logger()
}
```

**Sensitive Data Filtering Pattern:**
```go
type SensitiveFieldHook struct{}

func (h SensitiveFieldHook) Run(e *zerolog.Event, level zerolog.Level, msg string) {
    // Hook into zerolog to redact sensitive fields
    // Redact: password, token, apiKey
}
```

**Test Helper Pattern:**
```go
import "io/ioutil"

func NewTest() zerolog.Logger {
    return zerolog.New(ioutil.Discard).Level(zerolog.Disabled)
}
```

### Testing Standards

From `docs/architecture/testing-strategy.md`:

- Unit tests live beside code (`*_test.go`)
- Use table-driven tests for log level parsing
- Test TTY detection behavior
- Verify context methods produce correct output
- Test sensitive data redaction
- Ensure test helper produces no output

### File Locations

- Logger: `internal/shared/logger/logger.go`
- Tests: `internal/shared/logger/logger_test.go`

### Implementation Notes

**Key Requirements:**

1. **Structured Logging:** All logs as JSON (machine-readable) or pretty-print (human-readable)
2. **TTY Detection:** Automatic format switching based on output destination
3. **Level Configuration:** Support debug/info/warn/error levels, case-insensitive
4. **Context Enrichment:** Methods to add component/operation/correlation fields
5. **Sensitive Data:** Redact password/token/apiKey fields automatically
6. **Test Support:** NewTest() helper for silent logging in tests

**Output Modes:**
- **TTY (terminal):** Colorized, human-readable format with timestamps
- **Non-TTY (pipes, files):** JSON format for log aggregation/parsing

**Log Levels:**
- **debug:** Detailed diagnostic information
- **info:** General informational messages (default)
- **warn:** Warning messages for potential issues
- **error:** Error conditions requiring attention

### Refactoring Guidelines

**SRP Decomposition Examples:**

For logger package, decompose into focused helpers:

**New() function decomposition:**
- createLogger() - Single responsibility: initialize base zerolog logger
- configureTTY() - Single responsibility: detect terminal and configure output format
- parseLevel() - Single responsibility: convert level string to zerolog.Level

**Filtering decomposition:**
- setupFiltering() - Single responsibility: configure sensitive field hook
- isSensitiveField() - Single responsibility: check if field name is sensitive
- redactValue() - Single responsibility: replace sensitive value with "[REDACTED]"

**When to Decompose:**
- Methods >60 lines → extract helpers
- >2 nested control structures → extract to functions
- Mixed concerns (TTY detection + logger creation) → separate functions

**Naming Standards:**
- Exported functions: PascalCase (New, WithComponent, WithOperation, WithCorrelationID)
- Constructors: New* pattern (NewTest)
- Private helpers: camelCase, descriptive action verbs (createLogger, configureTTY, parseLevel)
- Context methods: With* prefix (idiomatic zerolog pattern)

**Documentation Requirements:**
- Package comment at top explaining logging philosophy
- All exported functions have GoDoc describing purpose and usage
- All exported functions have GoDoc with parameters and returns
- Complex private logic (TTY detection) has inline comments explaining "why"
- Example code showing method chaining pattern

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 1 requirements | Bob (Scrum Master) |
| 2025-10-28 | 1.1 | Enhanced with full TDD framework, SRP decomposition, linting checkpoints | QA Specialist |

## Dev Agent Record

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
