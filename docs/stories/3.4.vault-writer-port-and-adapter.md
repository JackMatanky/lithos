# Story 3.4: Implement VaultWriterPort and FileSystemVaultWriterAdapter

## Status

Draft

## Story

**As a** developer,
**I want** a vault writer port and adapter,
**so that** CommandOrchestrator and the indexer can persist notes with atomic guarantees.

## Acceptance Criteria

**VaultWriterPort Interface:**

- 3.4.1: Add VaultWriterPort interface to `internal/ports/spi/vault.go`:
  - Method: `Persist(ctx context.Context, note Note, path string) error` - Write note to vault with atomic guarantees
  - Method: `Delete(ctx context.Context, path string) error` - Remove note from vault
  - GoDoc: Document idempotency expectations, FR6 preservation, atomic write guarantees

**FileSystemVaultWriterAdapter Implementation:**

- 3.4.2: Create `internal/adapters/spi/vault/writer.go` with FileSystemVaultWriterAdapter:
  - Implements VaultWriterPort interface
  - Constructor: `NewVaultWriterAdapter(config Config, log Logger) *FileSystemVaultWriterAdapter`
  - Uses `moby/sys/atomicwriter` for atomic writes (temp + rename)
  - Uses Config.VaultPath for vault root directory

- 3.4.3: Implement Persist method:
  - Ensure target directory exists using `os.MkdirAll`
  - Serialize Note to markdown format (frontmatter YAML + body)
  - Write atomically using `atomicwriter.WriteFile`
  - Wrap errors with `FileSystemError` including operation and path
  - Log successful writes at debug level with zerolog
  - Support overwrite semantics without mutating note content

- 3.4.4: Implement Delete method:
  - Remove file using `os.Remove`
  - Return nil if file doesn't exist (idempotent delete)
  - Wrap errors with `FileSystemError` including operation and path
  - Log successful deletes at debug level

**Testing:**

- 3.4.5: Create comprehensive unit tests in `internal/adapters/spi/vault/writer_test.go`:
  - Test Persist creates new file (writes content, uses atomic write)
  - Test Persist overwrites existing file (atomic replacement)
  - Test Persist creates parent directories if missing
  - Test Persist with invalid vault directory (permission denied)
  - Test Persist preserves frontmatter fields (FR6)
  - Test Delete removes file successfully
  - Test Delete with non-existent file (returns nil - idempotent)
  - Test Delete with permission error
  - Verify error wrapping includes operation and path
  - Verify atomic write semantics (use temp directory)

- 3.4.6: All tests pass: `go test ./internal/adapters/spi/vault`

- 3.4.7: All linting passes: `golangci-lint run ./internal/adapters/spi/vault`

- 3.4.8: Committed with message: `feat(vault): implement VaultWriterPort and FileSystemVaultWriterAdapter with atomic writes`

## Tasks / Subtasks

- [ ] Task 1: Define VaultWriterPort interface (AC: 3.4.1)
  - [ ] RED: Write failing test for VaultWriterPort interface compliance
    - [ ] Write test case verifying interface methods exist
    - [ ] Run `go test ./internal/ports/spi` and confirm failure
  - [ ] RED: Write failing test for Persist signature
    - [ ] Write test case checking method signature
    - [ ] Run `go test ./internal/ports/spi` and confirm failure
  - [ ] RED: Write failing test for Delete signature
    - [ ] Write test case checking method signature
    - [ ] Run `go test ./internal/ports/spi` and confirm failure
  - [ ] GREEN: Add VaultWriterPort to `internal/ports/spi/vault.go`
    - [ ] Define Persist and Delete methods with proper signatures
    - [ ] Add comprehensive GoDoc referencing idempotency, FR6, atomic writes
    - [ ] Run `go test ./internal/ports/spi` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify Persist has single responsibility (write note atomically)
      - [ ] Verify Delete has single responsibility (remove file idempotently)
    - [ ] Review naming: VaultWriterPort (clear domain concept), method names (clear actions)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for VaultWriterPort explaining CQRS write-side semantics
      - [ ] Add GoDoc for Persist explaining atomic guarantees and FR6
      - [ ] Add GoDoc for Delete explaining idempotency
      - [ ] Reference dual-write pattern usage
    - [ ] Run `golangci-lint run --fix internal/ports/spi`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/ports/spi` to verify refactoring didn't break tests
    - [ ] Verify documentation clarity and completeness
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/ports/spi`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 2: Implement FileSystemVaultWriterAdapter struct and constructor (AC: 3.4.2)
  - [ ] RED: Write failing test for NewVaultWriterAdapter
    - [ ] Write test case in `internal/adapters/spi/vault/writer_test.go`
    - [ ] Verify interface compliance with type assertion
    - [ ] Run `go test ./internal/adapters/spi/vault` and confirm failure
  - [ ] GREEN: Create `internal/adapters/spi/vault/writer.go`
    - [ ] Define FileSystemVaultWriterAdapter struct with config and log fields
    - [ ] Implement NewVaultWriterAdapter constructor
    - [ ] Add interface compliance check: `var _ VaultWriterPort = (*FileSystemVaultWriterAdapter)(nil)`
    - [ ] Run `go test ./internal/adapters/spi/vault` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify struct has single responsibility (vault write operations)
      - [ ] Verify constructor has single responsibility (initialization)
    - [ ] Review naming: FileSystemVaultWriterAdapter (clear), NewVaultWriterAdapter (idiomatic)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for struct explaining atomic write guarantees
      - [ ] Add GoDoc for constructor explaining dependencies
      - [ ] Reference VaultWriterPort interface contract
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/vault`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/spi/vault` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/vault`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 3: Implement Persist method (AC: 3.4.3)
  - [ ] RED: Write failing test for Persist creates new file
    - [ ] Write test case verifying file creation
    - [ ] Run `go test ./internal/adapters/spi/vault` and confirm failure
  - [ ] RED: Write failing test for Persist overwrites existing file
    - [ ] Write test case with pre-existing file
    - [ ] Run `go test ./internal/adapters/spi/vault` and confirm failure
  - [ ] RED: Write failing test for Persist creates parent directories
    - [ ] Write test case with nested path
    - [ ] Run `go test ./internal/adapters/spi/vault` and confirm failure
  - [ ] RED: Write failing test for Persist uses atomic write
    - [ ] Write test case verifying atomic write semantics
    - [ ] Run `go test ./internal/adapters/spi/vault` and confirm failure
  - [ ] RED: Write failing test for Persist wraps errors correctly
    - [ ] Write test case for error scenarios
    - [ ] Run `go test ./internal/adapters/spi/vault` and confirm failure
  - [ ] RED: Write failing test for Persist preserves frontmatter (FR6)
    - [ ] Write test case with unknown frontmatter fields
    - [ ] Verify fields preserved in output
    - [ ] Run `go test ./internal/adapters/spi/vault` and confirm failure
  - [ ] GREEN: Implement Persist method
    - [ ] Add directory creation with os.MkdirAll
    - [ ] Add Note serialization to markdown format
    - [ ] Add atomic write with atomicwriter.WriteFile
    - [ ] Add error wrapping with FileSystemError
    - [ ] Add debug logging with zerolog
    - [ ] Run `go test ./internal/adapters/spi/vault` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract serializeNote(note Note) ([]byte, error) helper for markdown serialization
      - [ ] Extract ensureDirectory(path string) error helper if logic >5 lines
      - [ ] Extract writeAtomic(path string, content []byte) error helper if logic >10 lines
      - [ ] Verify Persist delegates to serialization and write helpers
    - [ ] Review naming: Persist (clear domain action), helper methods descriptive
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for Persist explaining atomic guarantees and FR6
      - [ ] Document directory creation behavior
      - [ ] Document overwrite semantics
      - [ ] Add inline comments for serialization logic
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/vault`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/spi/vault` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for Persist
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/vault`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 4: Implement Delete method (AC: 3.4.4)
  - [ ] RED: Write failing test for Delete removes file
    - [ ] Write test case verifying file removal
    - [ ] Run `go test ./internal/adapters/spi/vault` and confirm failure
  - [ ] RED: Write failing test for Delete is idempotent (non-existent file)
    - [ ] Write test case with non-existent file
    - [ ] Verify returns nil
    - [ ] Run `go test ./internal/adapters/spi/vault` and confirm failure
  - [ ] RED: Write failing test for Delete wraps errors correctly
    - [ ] Write test case for error scenarios
    - [ ] Run `go test ./internal/adapters/spi/vault` and confirm failure
  - [ ] GREEN: Implement Delete method
    - [ ] Add os.Remove call
    - [ ] Add idempotent check (return nil if os.IsNotExist)
    - [ ] Add error wrapping with FileSystemError
    - [ ] Add debug logging
    - [ ] Run `go test ./internal/adapters/spi/vault` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify Delete has single responsibility (remove file idempotently)
      - [ ] Extract error wrapping if repeated pattern
    - [ ] Review naming: Delete (clear action), error handling clear
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc explaining idempotent behavior
      - [ ] Document error cases
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/vault`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/spi/vault` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for Delete
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/vault`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 5: Run quality gates (AC: 3.4.6-3.4.7)
  - [ ] Run `go test ./internal/adapters/spi/vault` and verify 100% pass
  - [ ] Run `golangci-lint run --fix internal/adapters/spi/vault`
  - [ ] Fix any linting issues
  - [ ] Verify test coverage is adequate (>85% for adapters)
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/spi/vault`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 6: Commit changes (AC: 3.4.8)
  - [ ] Review all changes
  - [ ] Stage files: `git add internal/ports/spi/vault.go internal/adapters/spi/vault/writer.go`
  - [ ] Commit with message: `feat(vault): implement VaultWriterPort and FileSystemVaultWriterAdapter with atomic writes`

## Dev Notes

### Architecture Alignment (v0.6.8)

From `docs/architecture/components.md#vaultwriterport`:

**CQRS Write-Side Responsibility:**

VaultWriterPort handles CQRS write-side operations for vault persistence:

- **Source of Truth:** Vault is the persistent storage, cache is projection
- **Atomic Guarantees:** Writes must be all-or-nothing (no partial writes)
- **Idempotency:** Delete operations must be idempotent (safe to call multiple times)

**Why Separate from CacheWriter:**
- Vault is source of truth (persistent storage)
- Cache is projection (can be rebuilt from vault)
- Different failure modes (vault write failure = hard error, cache write failure = soft error)
- CQRS pattern: VaultWriter + CacheWriter = write side, VaultReader + QueryService = read side

### VaultWriterPort Interface

From `docs/architecture/components.md#vaultwriterport`:

**Purpose:** Provide CQRS write-side access for persisting notes to vault with atomic guarantees.

**Key Interfaces:**

```go
type VaultWriterPort interface {
    // Persist writes note to vault with atomic guarantees
    // Creates parent directories if missing
    // Overwrites existing file without mutating note content
    // Preserves all frontmatter fields (FR6)
    // Used by CommandOrchestrator.NewNote() and dual-write pattern
    Persist(ctx context.Context, note Note, path string) error

    // Delete removes note from vault
    // Idempotent: returns nil if file doesn't exist
    // Used by CommandOrchestrator for note deletion
    Delete(ctx context.Context, path string) error
}
```

**Design Decisions:**
- Path parameter separate from Note (enables flexible file placement)
- Atomic write guarantees prevent partial writes
- Idempotent Delete (safe to call multiple times)
- Context-aware for cancellation support

### FileSystemVaultWriterAdapter Implementation

From `docs/architecture/components.md#vaultwriteradapter`:

**Atomic Write Semantics:**

Uses `moby/sys/atomicwriter.WriteFile` for atomic writes:
1. Write to temporary file in same directory as target
2. Set proper permissions (0644 for files)
3. Rename temp file to target atomically (atomic filesystem operation)
4. Guarantees all-or-nothing semantics (no partial writes)

**Implementation Pattern:**
```go
type FileSystemVaultWriterAdapter struct {
    config Config
    log    zerolog.Logger
}

func (a *FileSystemVaultWriterAdapter) Persist(ctx context.Context, note Note, path string) error {
    // 1. Ensure parent directory exists
    dir := filepath.Dir(path)
    if err := os.MkdirAll(dir, 0755); err != nil {
        return fmt.Errorf("failed to create directory %s: %w", dir, err)
    }

    // 2. Serialize note to markdown format
    content, err := serializeNote(note)
    if err != nil {
        return fmt.Errorf("failed to serialize note %s: %w", note.ID, err)
    }

    // 3. Atomic write
    if err := atomicwriter.WriteFile(path, bytes.NewReader(content), 0644); err != nil {
        return fmt.Errorf("vault write failed for note %s at %s: %w", note.ID, path, err)
    }

    a.log.Debug().
        Str("note_id", string(note.ID)).
        Str("path", path).
        Msg("vault write successful")

    return nil
}

func (a *FileSystemVaultWriterAdapter) Delete(ctx context.Context, path string) error {
    err := os.Remove(path)
    if err != nil {
        if os.IsNotExist(err) {
            // Idempotent: file doesn't exist, operation successful
            return nil
        }
        return fmt.Errorf("vault delete failed for path %s: %w", path, err)
    }

    a.log.Debug().
        Str("path", path).
        Msg("vault delete successful")

    return nil
}
```

**Note Serialization to Markdown:**

```go
func serializeNote(note Note) ([]byte, error) {
    var buf bytes.Buffer

    // 1. Write frontmatter (YAML)
    buf.WriteString("---\n")

    // Serialize frontmatter fields to YAML
    yamlData, err := yaml.Marshal(note.Frontmatter.Fields)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal frontmatter: %w", err)
    }
    buf.Write(yamlData)

    buf.WriteString("---\n")

    // 2. Write body content (if present)
    // MVP: Note doesn't have body content yet
    // Post-MVP: Add note.Body field and write here

    return buf.Bytes(), nil
}
```

**Markdown File Format:**
```markdown
---
fileClass: contact
title: Alice Smith
email: alice@example.com
tags:
  - work
  - engineering
custom_field: preserved value
---

Body content goes here (post-MVP)
```

### Dual Write Pattern

From `docs/architecture/components.md#commandorchestrator`:

**CommandOrchestrator uses dual writes to keep vault and cache in sync:**

```go
func (o *CommandOrchestrator) NewNote(ctx context.Context, templateID TemplateID) (Note, error) {
    // ... template rendering, frontmatter extraction, validation ...

    // Dual write pattern (vault + cache)
    // 1. Persist to vault (source of truth)
    if err := o.vaultWriter.Persist(ctx, note, path); err != nil {
        return Note{}, fmt.Errorf("failed to persist note to vault: %w", err)
    }

    // 2. Persist to cache (projection) - keeps index in sync
    if err := o.cacheWriter.Persist(ctx, note); err != nil {
        // Log warning but don't fail - can rebuild index later
        o.log.Warn().Err(err).Msg("failed to update cache")
    }

    return note, nil
}
```

**Why Dual Write:**
- **Vault = Source of Truth:** Persistent storage, survives cache rebuilds
- **Cache = Projection:** Fast queries, can be rebuilt from vault via indexing
- **Different Failure Modes:**
  - Vault write failure → Hard error, abort operation
  - Cache write failure → Soft error, log warning, continue (eventual consistency)
- **Eventual Consistency:** User can run `lithos index` to rebuild cache from vault

### Directory Creation

**Automatic Parent Directory Creation:**

```go
// Ensure parent directory exists
dir := filepath.Dir(path)
if err := os.MkdirAll(dir, 0755); err != nil {
    return fmt.Errorf("failed to create directory %s: %w", dir, err)
}
```

**Design Rationale:**
- Templates can specify nested paths: `contacts/work/alice.md`
- Adapter creates all parent directories automatically
- User doesn't need to pre-create directory structure
- Uses `os.MkdirAll` (mkdir -p semantics) - idempotent, safe to call multiple times

### Idempotent Delete

From `docs/architecture/components.md#vaultwriterport`:

**Delete Idempotency:**

```go
func (a *FileSystemVaultWriterAdapter) Delete(ctx context.Context, path string) error {
    err := os.Remove(path)
    if err != nil {
        // Check if file doesn't exist
        if os.IsNotExist(err) {
            // Idempotent: operation successful (file is gone)
            return nil
        }
        // Other errors (permission denied, etc.)
        return fmt.Errorf("vault delete failed for path %s: %w", path, err)
    }
    return nil
}
```

**Why Idempotency Matters:**
- Safe to call Delete multiple times on same file
- Simplifies error recovery (can retry without checking existence)
- Matches HTTP DELETE semantics (DELETE is idempotent by spec)

### Frontmatter Preservation (FR6)

From `docs/architecture/data-models.md#frontmatter` and `docs/prd/requirements.md#fr6`:

**FR6 Requirement:** Preserve all frontmatter fields during round-trip (read → modify → write).

**Implementation Strategy:**
- Use `note.Frontmatter.Fields` map (contains ALL fields, including unknown)
- Serialize entire Fields map to YAML (no filtering)
- YAML marshaling preserves all fields automatically
- Unknown fields pass through untouched

**Example Round-Trip:**
```go
// 1. Original frontmatter (with custom field)
original := `---
fileClass: contact
title: Alice
custom_field: preserved
---`

// 2. VaultReader reads and parses
note := Note{
    Frontmatter: Frontmatter{
        Fields: map[string]interface{}{
            "fileClass": "contact",
            "title": "Alice",
            "custom_field": "preserved", // Unknown field
        },
    },
}

// 3. VaultWriter serializes and writes
// custom_field is preserved in output
output := `---
fileClass: contact
title: Alice
custom_field: preserved
---`
```

### Error Handling Strategy

From `docs/architecture/error-handling-strategy.md`:

**Structured Error Types:**

```go
type FileSystemError struct {
    Operation string // "persist", "delete"
    Path      string
    Cause     error
}

func (e *FileSystemError) Error() string {
    return fmt.Sprintf("filesystem %s failed for path %s: %v", e.Operation, e.Path, e.Cause)
}

func (e *FileSystemError) Unwrap() error {
    return e.Cause
}
```

**Error Wrapping Examples:**
```go
// Directory creation failure
return &FileSystemError{
    Operation: "persist",
    Path:      dir,
    Cause:     err,
}

// Atomic write failure
return &FileSystemError{
    Operation: "persist",
    Path:      path,
    Cause:     err,
}

// Delete failure (non-existence is not an error)
if !os.IsNotExist(err) {
    return &FileSystemError{
        Operation: "delete",
        Path:      path,
        Cause:     err,
    }
}
```

### Logging Standards

From `docs/architecture/coding-standards.md`:

**Structured Logging with zerolog:**

```go
// Success (debug level)
a.log.Debug().
    Str("note_id", string(note.ID)).
    Str("path", path).
    Msg("vault write successful")

// Delete success (debug level)
a.log.Debug().
    Str("path", path).
    Msg("vault delete successful")

// Error (error level)
a.log.Error().
    Err(err).
    Str("note_id", string(note.ID)).
    Str("path", path).
    Str("operation", "persist").
    Msg("vault write failed")
```

**Logging Guidelines:**
- Debug level for successful operations
- Error level for operation failures
- Include structured fields (note_id, path, operation)
- Use `Err(err)` to include error details

### Testing Strategy

From `docs/architecture/testing-strategy.md`:

**Test Data Setup:**
```go
func setupTestVault(t *testing.T) string {
    tmpDir := t.TempDir()
    // Return temporary vault directory
    return tmpDir
}

func createTestNote() Note {
    return Note{
        ID: NoteID("test-note"),
        Frontmatter: Frontmatter{
            Fields: map[string]interface{}{
                "fileClass": "test",
                "title":     "Test Note",
                "custom":    "preserved",
            },
        },
    }
}
```

**Table-Driven Tests:**
```go
func TestPersist(t *testing.T) {
    tests := []struct {
        name      string
        note      Note
        path      string
        setupFunc func(t *testing.T, vaultPath string)
        wantErr   bool
    }{
        {
            name: "new file",
            note: createTestNote(),
            path: "notes/test.md",
            wantErr: false,
        },
        {
            name: "overwrite existing",
            note: createTestNote(),
            path: "notes/test.md",
            setupFunc: func(t *testing.T, vaultPath string) {
                // Pre-create file
                os.MkdirAll(filepath.Join(vaultPath, "notes"), 0755)
                os.WriteFile(filepath.Join(vaultPath, "notes", "test.md"), []byte("old"), 0644)
            },
            wantErr: false,
        },
        {
            name: "nested path creates directories",
            note: createTestNote(),
            path: "contacts/work/alice.md",
            wantErr: false,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            vaultPath := setupTestVault(t)
            if tt.setupFunc != nil {
                tt.setupFunc(t, vaultPath)
            }

            adapter := NewVaultWriterAdapter(
                Config{VaultPath: vaultPath},
                logger.NewTest(),
            )

            fullPath := filepath.Join(vaultPath, tt.path)
            err := adapter.Persist(context.Background(), tt.note, fullPath)

            if (err != nil) != tt.wantErr {
                t.Errorf("Persist() error = %v, wantErr %v", err, tt.wantErr)
            }

            if !tt.wantErr {
                // Verify file exists and content is correct
                content, err := os.ReadFile(fullPath)
                if err != nil {
                    t.Fatalf("Failed to read persisted file: %v", err)
                }
                // Verify frontmatter preserved (FR6)
                if !bytes.Contains(content, []byte("custom: preserved")) {
                    t.Errorf("Custom field not preserved in output")
                }
            }
        })
    }
}
```

### Functional Requirements Traceability

**FR6: Preserve Unknown Fields**
- VaultWriter MUST serialize all fields in note.Frontmatter.Fields
- YAML marshaling preserves unknown fields automatically
- Test round-trip to verify preservation

**FR9: Error Context**
- All errors include operation context (persist, delete)
- All errors include resource identifiers (note ID, file path)
- Preserve error chains with `%w` for debugging

### Dependencies

**Standard Library:**
- `context` - Cancellation support
- `os` - File operations (Remove, MkdirAll, ReadFile for tests)
- `path/filepath` - OS-agnostic path handling (Dir, Join)
- `bytes` - Buffer for markdown serialization

**Third-Party:**
- `github.com/moby/sys/atomicwriter` - Atomic file writes (temp + rename)
- `github.com/goccy/go-yaml` - YAML serialization for frontmatter
- `github.com/rs/zerolog` - Structured logging

**Internal:**
- `internal/domain` - Note, NoteID, Frontmatter models
- `internal/ports/spi` - VaultWriterPort interface
- `internal/shared/errors` - FileSystemError type
- `internal/shared/logger` - Logger wrapper

### File Locations

From `docs/architecture/source-tree.md`:

**Port Definition:**
- `internal/ports/spi/vault.go` - VaultWriterPort interface (same file as VaultReaderPort)

**Adapter Implementation:**
- `internal/adapters/spi/vault/writer.go` - FileSystemVaultWriterAdapter
- `internal/adapters/spi/vault/reader.go` - FileSystemVaultReaderAdapter (Story 3.3)

**Unit Tests:**
- `internal/ports/spi/vault_test.go` - Port interface tests
- `internal/adapters/spi/vault/writer_test.go` - Write adapter tests

### Refactoring Guidelines

**SRP Decomposition for Vault Writer:**

**FileSystemVaultWriterAdapter:**
- Persist method: Extract helpers if method exceeds 20 lines
  - `serializeNote(note Note) ([]byte, error)` - Handle markdown serialization (YAML frontmatter + body)
  - `ensureDirectory(path string) error` - Create parent directories if needed
  - `writeAtomic(path string, content []byte) error` - Atomic write using atomicwriter
  - `wrapVaultError(op string, noteID NoteID, path string, err error) error` - Consistent error wrapping
- Delete method: Should remain simple (<15 lines)
  - Extract error wrapping if repeated pattern

**When to Decompose:**
- If Persist exceeds 20 lines, extract serialization and write helpers
- If error wrapping is repeated >2 times, extract helper
- If directory creation logic exceeds 5 lines, extract helper
- If testing is difficult due to complexity, decompose

**Naming Standards:**
- Adapter types: FileSystem[Purpose]Adapter (FileSystemVaultWriterAdapter)
- Constructors: NewVaultWriterAdapter (domain-focused name)
- Private helpers: camelCase, specific action (serializeNote, writeAtomic, ensureDirectory)
- Error wrappers: wrap[Purpose]Error (wrapVaultError)

**Documentation Requirements:**
- Package comment explaining vault writer pattern
- All exported types have GoDoc comments
- Methods have GoDoc explaining behavior, parameters, errors, guarantees
- Atomic write semantics documented in detail
- FR6 preservation explained in Persist method
- Reference architecture documents where relevant

### Common Pitfalls to Avoid

1. **DO NOT use non-atomic writes** - Use atomicwriter, not plain os.WriteFile
2. **DO preserve all frontmatter fields** - Serialize entire Fields map, no filtering
3. **DO make Delete idempotent** - Return nil if file doesn't exist
4. **DO create parent directories** - Use os.MkdirAll before writing
5. **DO wrap errors with context** - Include note ID, path, operation
6. **DO use structured logging** - Include note_id, path fields
7. **DO test atomic write semantics** - Verify temp file + rename pattern

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 3 requirements | Bob (Scrum Master) |
| 2025-10-28 | 1.1 | Enhanced with full TDD framework, SRP decomposition (serializeNote, ensureDirectory, writeAtomic helpers), linting checkpoints, refactoring guidelines | QA Specialist |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
