# Story 5.3: CommandOrchestrator NewNote Workflow

## Status

Draft

## Story

**As a** developer,
**I want** CommandOrchestrator.NewNote to follow the ten-step workflow in the architecture,
**so that** note creation is schema-driven and keeps vault and cache in sync.

## Acceptance Criteria

**NewNote Workflow Implementation:**

- 5.3.1: Implement `CommandOrchestrator.NewNote(ctx context.Context, templateID TemplateID) (Note, error)` method following the documented ten-step workflow
- 5.3.2: Document workflow steps in method comments referencing `docs/architecture/components.md#commandorchestrator`
- 5.3.3: Verify each step executes in correct order with proper error handling

**Workflow Steps:**

- 5.3.4: Step 1 - Load template via `TemplateEngine.Load(ctx, templateID)`
- 5.3.5: Step 2 - Render template via `TemplateEngine.Render(ctx, template)`
- 5.3.6: Step 3 - Extract frontmatter via `FrontmatterService.Extract([]byte(rendered))`
- 5.3.7: Step 4 - Validate frontmatter via `FrontmatterService.Validate(ctx, frontmatter)`
- 5.3.8: Step 5 - Generate NoteID from frontmatter (filename → title slug → UUID)
- 5.3.9: Step 6 - Resolve file path (template context → frontmatter → default)
- 5.3.10: Step 7 - Create Note object with ID, Content, Frontmatter
- 5.3.11: Step 8 - Persist to vault via `VaultWriterPort.Persist(ctx, note, path)`
- 5.3.12: Step 9 - Persist to cache via `CacheWriterPort.Persist(ctx, note)` (log warning on failure, don't abort)
- 5.3.13: Step 10 - Return Note object

**Testing:**

- 5.3.14: Create unit tests in `internal/app/orchestrator/orchestrator_test.go`:
  - Test successful workflow end-to-end
  - Test failures at each step (template load, render, extract, validate, vault write)
  - Test cache write failure logged but doesn't fail workflow
  - Test NoteID generation strategies (filename, title slug, UUID)
  - Test file path resolution strategies

- 5.3.15: All tests pass: `go test ./internal/app/orchestrator`

- 5.3.16: All linting passes: `golangci-lint run --fix internal/app/orchestrator`

- 5.3.17: Committed with message: `feat(orchestrator): implement schema-driven NewNote workflow with dual-write pattern`

## Tasks / Subtasks

- [ ] Task 1: Implement NewNote method skeleton (AC: 5.3.1-5.3.3)
  - [ ] RED: Write failing test for NewNote signature
    - [ ] Write test case in `internal/app/orchestrator/orchestrator_test.go`
    - [ ] Verify method signature matches spec
    - [ ] Run `go test ./internal/app/orchestrator` and confirm failure
  - [ ] GREEN: Implement minimal code to pass tests
    - [ ] Create `NewNote(ctx, templateID)` method signature
    - [ ] Return empty Note and nil error (skeleton)
    - [ ] Run `go test ./internal/app/orchestrator` and verify test passes
  - [ ] REFACTOR:
    - [ ] Add method comment documenting ten-step workflow
    - [ ] Reference architecture docs
    - [ ] Run `golangci-lint run --fix internal/app/orchestrator`
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/orchestrator`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)

- [ ] Task 2: Implement steps 1-4 (Load, Render, Extract, Validate) (AC: 5.3.4-5.3.7)
  - [ ] RED: Write failing test for template load
    - [ ] Create fake TemplateEngine returning error
    - [ ] Verify NewNote returns error
    - [ ] Run `go test ./internal/app/orchestrator` and confirm failure
  - [ ] RED: Write failing test for template render
    - [ ] Create fake returning render error
    - [ ] Verify error propagates
    - [ ] Run `go test ./internal/app/orchestrator` and confirm failure
  - [ ] RED: Write failing test for frontmatter extract
    - [ ] Create fake FrontmatterService returning extraction error
    - [ ] Verify error propagates
    - [ ] Run `go test ./internal/app/orchestrator` and confirm failure
  - [ ] RED: Write failing test for frontmatter validate
    - [ ] Create fake returning ValidationError
    - [ ] Verify error propagates
    - [ ] Run `go test ./internal/app/orchestrator` and confirm failure
  - [ ] GREEN: Implement minimal code to pass tests
    - [ ] Call TemplateEngine.Load with error handling
    - [ ] Call TemplateEngine.Render with error handling
    - [ ] Call FrontmatterService.Extract with error handling
    - [ ] Call FrontmatterService.Validate with error handling
    - [ ] Run `go test ./internal/app/orchestrator` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify each step has single responsibility
      - [ ] If any step >15 lines, extract helper
      - [ ] Extract registerFunction() if workflow coordination grows complex
    - [ ] Review naming: clear step names
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Document each workflow step
      - [ ] Explain error handling strategy
    - [ ] Run `golangci-lint run --fix internal/app/orchestrator`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/orchestrator` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/orchestrator`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)

- [ ] Task 3: Implement step 5 (Generate NoteID) (AC: 5.3.8)
  - [ ] RED: Write failing test for NoteID from filename field
    - [ ] Create frontmatter with explicit filename
    - [ ] Verify NoteID matches filename
    - [ ] Run `go test ./internal/app/orchestrator` and confirm failure
  - [ ] RED: Write failing test for NoteID from title slug
    - [ ] Create frontmatter with title, no filename
    - [ ] Verify NoteID is slugified title
    - [ ] Run `go test ./internal/app/orchestrator` and confirm failure
  - [ ] RED: Write failing test for NoteID from UUID fallback
    - [ ] Create frontmatter without filename or title
    - [ ] Verify NoteID is UUID format
    - [ ] Run `go test ./internal/app/orchestrator` and confirm failure
  - [ ] GREEN: Implement minimal code to pass tests
    - [ ] Implement `generateNoteID()` with three-priority strategy
    - [ ] Implement `slugify()` helper for title conversion
    - [ ] Run `go test ./internal/app/orchestrator` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract registerFunction() if strategy selection >10 lines
      - [ ] Extract executeFunction() if slugification >10 lines
      - [ ] Verify generateNoteID has single responsibility (select strategy)
      - [ ] Verify slugify has single responsibility (transform title)
    - [ ] Review naming: generateNoteID (clear), slugify (standard term)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Document three-priority strategy
      - [ ] Explain slugification rules
      - [ ] Document UUID fallback
    - [ ] Run `golangci-lint run --fix internal/app/orchestrator`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/orchestrator` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for NoteID generation
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/orchestrator`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)

- [ ] Task 4: Implement step 6 (Resolve File Path) (AC: 5.3.9)
  - [ ] RED: Write failing test for path from template context
    - [ ] Create template with explicit path
    - [ ] Verify path used
    - [ ] Run `go test ./internal/app/orchestrator` and confirm failure
  - [ ] RED: Write failing test for path from frontmatter
    - [ ] Create frontmatter with folder and filename fields
    - [ ] Verify path constructed from fields
    - [ ] Run `go test ./internal/app/orchestrator` and confirm failure
  - [ ] RED: Write failing test for default path
    - [ ] Create frontmatter without path hints
    - [ ] Verify default vault root + noteID + .md
    - [ ] Run `go test ./internal/app/orchestrator` and confirm failure
  - [ ] RED: Write failing test for security check
    - [ ] Create path outside vault bounds
    - [ ] Verify error returned
    - [ ] Run `go test ./internal/app/orchestrator` and confirm failure
  - [ ] GREEN: Implement minimal code to pass tests
    - [ ] Implement `resolveFilePath()` with three-priority strategy
    - [ ] Implement `securePathCheck()` for vault bounds verification
    - [ ] Run `go test ./internal/app/orchestrator` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract buildQuery() if path construction >10 lines
      - [ ] Verify resolveFilePath has single responsibility (select path strategy)
      - [ ] Verify securePathCheck has single responsibility (security validation)
    - [ ] Review naming: resolveFilePath (clear), securePathCheck (security intent)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Document three-priority strategy
      - [ ] Explain security check requirements
      - [ ] Document error cases
    - [ ] Run `golangci-lint run --fix internal/app/orchestrator`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/orchestrator` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for path resolution
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/orchestrator`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)

- [ ] Task 5: Implement steps 7-10 (Create Note, Persist, Return) (AC: 5.3.10-5.3.13)
  - [ ] RED: Write failing test for Note construction
    - [ ] Verify Note has ID, Content, Frontmatter
    - [ ] Run `go test ./internal/app/orchestrator` and confirm failure
  - [ ] RED: Write failing test for vault write failure
    - [ ] Create fake VaultWriter returning error
    - [ ] Verify workflow aborts
    - [ ] Run `go test ./internal/app/orchestrator` and confirm failure
  - [ ] RED: Write failing test for cache write failure
    - [ ] Create fake CacheWriter returning error
    - [ ] Verify warning logged but workflow succeeds
    - [ ] Run `go test ./internal/app/orchestrator` and confirm failure
  - [ ] RED: Write failing test for successful end-to-end workflow
    - [ ] Create all fakes returning success
    - [ ] Verify Note returned
    - [ ] Run `go test ./internal/app/orchestrator` and confirm failure
  - [ ] GREEN: Implement minimal code to pass tests
    - [ ] Construct Note struct
    - [ ] Call VaultWriterPort.Persist with error handling (abort on failure)
    - [ ] Call CacheWriterPort.Persist with warning-only on failure
    - [ ] Return Note object
    - [ ] Run `go test ./internal/app/orchestrator` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify Note construction separate from persistence
      - [ ] Verify vault and cache writes handled independently
      - [ ] Extract executeFunction() if persistence logic >15 lines
    - [ ] Review naming: clear and descriptive
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Document dual-write pattern
      - [ ] Explain eventual consistency for cache
      - [ ] Document error handling philosophy
    - [ ] Run `golangci-lint run --fix internal/app/orchestrator`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/orchestrator` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for persistence workflow
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/orchestrator`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)

- [ ] Task 6: Run quality gates (AC: 5.3.15-5.3.16)
  - [ ] Run `go test ./internal/app/orchestrator` and verify 100% pass
  - [ ] Run `golangci-lint run --fix internal/app/orchestrator` and fix any issues
  - [ ] Verify test coverage is adequate (>90% for workflow orchestration)
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/orchestrator`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 7: Commit changes (AC: 5.3.17)
  - [ ] Review all changes
  - [ ] Stage files: `git add internal/app/orchestrator/orchestrator.go internal/app/orchestrator/orchestrator_test.go`
  - [ ] Commit with message: `feat(orchestrator): implement schema-driven NewNote workflow with dual-write pattern`

## Dev Notes

### Architecture Alignment (v0.6.8)

From `docs/architecture/components.md#commandorchestrator`:

**NewNote Use Case Workflow:**

The NewNote method orchestrates the complete note creation workflow:

1. **Load Template:** Load template via TemplateEngine.Load()
2. **Render Template:** Execute template with user prompts via TemplateEngine.Render()
3. **Extract Frontmatter:** Parse YAML frontmatter via FrontmatterService.Extract()
4. **Validate Frontmatter:** Validate against schema via FrontmatterService.Validate()
5. **Generate NoteID:** Derive NoteID from frontmatter fields (filename, title slug, or UUID)
6. **Resolve File Path:** Determine target path from template's path control functions or derive from frontmatter
7. **Create Note Object:** Construct Note with ID, Content, and Frontmatter
8. **Persist to Vault:** Write note via VaultWriterPort.Persist() (source of truth)
9. **Persist to Cache:** Write note via CacheWriterPort.Persist() (projection - keeps index in sync)
10. **Return Note:** Return Note object for CLI to display confirmation and optionally show content

### Dual Write Pattern (CQRS)

**Write-Side Concerns:**

CommandOrchestrator implements the dual-write pattern to keep vault (source of truth) and cache (projection) in sync:

```go
// 1. Persist to vault (source of truth)
if err := o.vaultWriter.Persist(ctx, note, path); err != nil {
    return Note{}, fmt.Errorf("failed to persist note to vault: %w", err)
}

// 2. Persist to cache (projection) - keeps index in sync
if err := o.cacheWriter.Persist(ctx, note); err != nil {
    // Log warning but don't fail - can rebuild index later
    o.log.Warn().Err(err).Msg("failed to update cache")
}

return note, nil
```

**Why This Design:**

- **Vault is Source of Truth:** All data persists to vault first. If vault write fails, entire operation fails.
- **Cache is Projection:** Cache derives from vault. If cache write fails, operation succeeds with warning.
- **Eventual Consistency:** Cache can be rebuilt from vault via `lithos index` command.
- **Atomic Vault Writes:** VaultWriterAdapter uses `moby/sys/atomicwriter` for atomic guarantees (temp + rename).

**Failure Modes:**

| Step | Failure Impact | Action |
|------|---------------|--------|
| Steps 1-7 | No side effects | Return error, abort workflow |
| Step 8 (Vault) | Source of truth corrupted | Return error, abort workflow |
| Step 9 (Cache) | Projection stale | Log warning, return success (eventual consistency) |

### NoteID Generation Strategy

**Three-Priority Strategy:**

```go
func (o *CommandOrchestrator) generateNoteID(fm Frontmatter) (NoteID, error) {
    // Priority 1: Use explicit filename field from frontmatter
    if filename, ok := fm.Fields["filename"].(string); ok {
        return NoteID(filename), nil
    }

    // Priority 2: Slugify title field
    if title, ok := fm.Fields["title"].(string); ok {
        slug := slugify(title)  // Convert "My Note" → "my-note"
        return NoteID(slug), nil
    }

    // Priority 3: Generate UUID-based ID
    return NoteID(generateUUID()), nil
}
```

**Slugification Algorithm:**

```go
func slugify(title string) string {
    // Convert to lowercase
    slug := strings.ToLower(title)

    // Replace spaces with hyphens
    slug = strings.ReplaceAll(slug, " ", "-")

    // Remove special characters (keep alphanumeric and hyphens)
    var builder strings.Builder
    for _, r := range slug {
        if unicode.IsLetter(r) || unicode.IsDigit(r) || r == '-' {
            builder.WriteRune(r)
        }
    }
    slug = builder.String()

    // Collapse multiple consecutive hyphens
    for strings.Contains(slug, "--") {
        slug = strings.ReplaceAll(slug, "--", "-")
    }

    // Trim hyphens from start and end
    slug = strings.Trim(slug, "-")

    return slug
}
```

### File Path Resolution Strategy

**Three-Priority Strategy:**

1. **Template Explicit Path:** Check template execution context for path set by file path functions
2. **Frontmatter-Derived Path:** Use `folder` + `filename` fields from frontmatter if present
3. **Default Path:** Vault root + noteID + ".md" extension

**Security Check:**

```go
func (o *CommandOrchestrator) securePathCheck(path string) (string, error) {
    // Ensure path is absolute
    absPath, err := filepath.Abs(path)
    if err != nil {
        return "", fmt.Errorf("invalid path: %w", err)
    }

    // Ensure path is within vault bounds (prevent directory traversal)
    if !strings.HasPrefix(absPath, o.config.VaultPath) {
        return "", fmt.Errorf("path outside vault bounds: %s", absPath)
    }

    return absPath, nil
}
```

### Testing Standards

From `docs/architecture/testing-strategy.md` and `docs/architecture/coding-standards.md`:

**Unit Test Requirements:**
- Tests live in `internal/app/orchestrator/orchestrator_test.go`
- Use fakes for all dependencies (TemplateEngine, FrontmatterService, VaultWriter, CacheWriter)
- Table-driven tests for different workflow scenarios
- Test doubles in `tests/utils/mocks.go`

**TDD Workflow:**
- RED: Write failing test first
- GREEN: Implement minimum code to pass
- REFACTOR: Improve code quality while tests pass

**Quality Gates:**
- All tests pass: `go test ./internal/app/orchestrator`
- No linting errors: `golangci-lint run --fix internal/app/orchestrator`
- Test coverage >90% for workflow orchestration

### Refactoring Guidelines

**SRP Decomposition Examples:**

For CommandOrchestrator NewNote workflow, SRP decomposition focuses on:

**Workflow Orchestration:**
- NewNote: Single responsibility = orchestrate ten-step workflow
- If workflow coordination >50 lines, extract registerFunction() per workflow phase
- Each step should be clear and focused

**NoteID Generation:**
- generateNoteID: Single responsibility = select ID generation strategy
- If strategy selection >15 lines, extract registerFunction() per strategy
- slugify: Single responsibility = transform title to slug
- If slugification >10 lines, extract executeFunction() per transformation step

**File Path Resolution:**
- resolveFilePath: Single responsibility = select path resolution strategy
- If path construction >10 lines, extract buildQuery() per source
- securePathCheck: Single responsibility = verify path security
- If security checks >10 lines, separate concerns

**Note Construction:**
- constructNote: Single responsibility = build Note object from parts
- If construction has validation logic, extract validation

**Persistence:**
- persistToVault: Single responsibility = write to vault with error handling
- persistToCache: Single responsibility = write to cache with warning on failure
- Keep vault and cache writes independent

**When to Decompose:**
- If NewNote method exceeds 50 lines, extract workflow phases
- If any step exceeds 15 lines, extract helper
- If helper has >2 concerns, separate into focused functions
- If error handling mixes with business logic, extract error handlers

**Naming Standards:**
- Workflow steps: loadTemplate, renderTemplate, extractFrontmatter (action-based)
- Generators: generate, create (generateNoteID, createNote)
- Resolvers: resolve (resolveFilePath)
- Validators: validate, check, verify (securePathCheck)
- Persistence: persist, write (persistToVault, persistToCache)

**Documentation Requirements:**
- Document ten-step workflow in NewNote method comment
- Reference architecture documentation
- Explain dual-write pattern and eventual consistency
- Document NoteID generation strategies
- Document path resolution strategies
- Explain error handling philosophy

### Common Pitfalls to Avoid

1. **DO NOT skip validation before persistence** - Always validate frontmatter
2. **DO NOT abort on cache write failure** - Log warning, continue (eventual consistency)
3. **DO NOT allow paths outside vault bounds** - Security check required
4. **DO propagate errors from steps 1-8** - These are fatal
5. **DO return success if vault write succeeds** - Cache can be rebuilt

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 5 requirements | Bob (Scrum Master) |
| 2025-10-28 | 1.1 | Enhanced with full TDD framework, SRP decomposition, linting checkpoints | QA Specialist |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
