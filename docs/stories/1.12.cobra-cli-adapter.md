# Story 1.12: Implement CobraCLI Adapter

## Status

Ready for Implementation

## Story

**As a** developer,
**I want** to implement complete CobraCLI adapter with root command, version command, and new command,
**so that** users can interact with the application via CLI following hexagonal architecture with SRP decomposition.

## Acceptance Criteria

**Dependencies and Setup:**

- 1.12.1: Add dependencies to `go.mod`:
  - `github.com/spf13/cobra`
  - `github.com/spf13/pflag`

- 1.12.2: Create `internal/adapters/api/cli/cobra.go`:
  - Implements CLIPort interface
  - Constructor: `NewCobraCLIAdapter(log zerolog.Logger) *CobraCLIAdapter`
  - Internal field: `handler CommandPort` (stored in Start())
  - Internal field: `log zerolog.Logger`

**Start Method:**

- 1.12.3: Implement `Start(ctx context.Context, handler CommandPort) error`:
  - Stores handler parameter in internal field
  - Calls buildRootCommand() private method
  - Executes root command with context: rootCmd.ExecuteContext(ctx)
  - Returns error from command execution

**Root Command:**

- 1.12.4: Implement private method `buildRootCommand() *cobra.Command`:
  - Use: "lithos"
  - Short: "Template-driven markdown note generator for Obsidian vaults"
  - SilenceUsage: true (don't print usage on command errors)
  - SilenceErrors: true (handle errors in domain)
  - Adds version subcommand via AddCommand(buildVersionCommand())
  - Adds new subcommand via AddCommand(buildNewCommand())

**Version Command:**

- 1.12.5: Implement private method `buildVersionCommand() *cobra.Command`:
  - Command: `lithos version`
  - Short: "Print version information"
  - RunE: prints "lithos v0.1.0" to stdout
  - Returns nil error on success

**New Command:**

- 1.12.6: Implement private method `buildNewCommand() *cobra.Command`:
  - Command: `lithos new [template-id]`
  - Short: "Create a new note from template"
  - Args: `cobra.MaximumNArgs(1)` (template-id is optional for now, will error in handler if missing)
  - Flags: `--view, -v` (boolean, default false) - display content after creation
  - RunE: calls handleNewCommand(cmd, args)

**New Command Handler:**

- 1.12.7: Implement private method `handleNewCommand(cmd *cobra.Command, args []string) error`:
  - Extract template-id from args[0] (return error if missing with message "template-id required")
  - Create TemplateID from args[0]: `templateID := domain.NewTemplateID(args[0])`
  - Call handler.NewNote(cmd.Context(), templateID)
  - On success: call displayNoteCreated(cmd, note)
  - On failure: return formatError(err)

- 1.12.8: Implement private method `displayNoteCreated(cmd *cobra.Command, note Note)`:
  - Print to stdout: `✓ Created: {Config.VaultPath}/{note.ID}.md`
  - Check --view flag via cmd.Flags().GetBool("view")
  - If --view is true:
    - Print separator line (80 characters of "=")
    - Print note content (read from file)
    - Print separator line

- 1.12.9: Implement private method `formatError(err error) error`:
  - Check error type using errors.As()
  - Format user-friendly messages:
    - ResourceError (template not found) → "Template '{name}' not found in {TemplatesDir}"
    - TemplateError (parse/render) → "Template error in '{name}': {message}"
    - Generic error → "Error: {message}"
  - Return formatted error for Cobra to display

**Testing:**

- 1.12.10: Add mock to `tests/utils/mocks.go`:
  - `MockCommandPort` struct implementing CommandPort interface
  - Internal field: `newNoteResult` (Note, error)
  - Method: `SetNewNoteResult(note Note, err error)` - configure mock response
  - Implements: NewNote() returns configured result

- 1.12.11: Create unit tests in `internal/adapters/api/cli/cobra_test.go`:
  - Test: Start() stores handler correctly
  - Test: buildRootCommand() creates command with correct structure
  - Test: version command prints "lithos v0.1.0"
  - Test: new command parses template-id argument correctly
  - Test: new command parses --view flag correctly
  - Test: handleNewCommand() extracts templateID from args
  - Test: handleNewCommand() returns error when args empty
  - Test: handleNewCommand() calls handler.NewNote() with correct arguments
  - Test: displayNoteCreated() formats output correctly without --view flag
  - Test: displayNoteCreated() displays content with --view flag
  - Test: formatError() formats ResourceError correctly
  - Test: formatError() formats TemplateError correctly
  - Test: formatError() formats generic error correctly
  - All tests use MockCommandPort from tests/utils/mocks.go

- 1.12.12: All tests pass: `go test ./internal/adapters/api/cli`

- 1.12.13: All linting passes: `golangci-lint run --fix internal/adapters/api/cli`

- 1.12.14: Committed with message: `feat(adapters): implement CobraCLI adapter with version and new commands`

## Tasks / Subtasks

- [ ] Task 1: Add dependencies and create adapter struct (AC: 1.12.1-1.12.2)
  - [ ] RED: Write failing test for struct compilation
    - [ ] Write test case verifying CobraCLIAdapter struct exists
    - [ ] Verify test fails with expected compilation error
    - [ ] Run `go test ./internal/adapters/api/cli` and confirm failure
  - [ ] GREEN: Add cobra and pflag to go.mod
    - [ ] Run `go get github.com/spf13/cobra@latest`
    - [ ] Run `go get github.com/spf13/pflag@latest`
    - [ ] Run `go mod tidy`
  - [ ] GREEN: Create CobraCLIAdapter struct with constructor
    - [ ] Create `internal/adapters/api/cli/cobra.go`
    - [ ] Define CobraCLIAdapter struct with handler and log fields
    - [ ] Implement NewCobraCLIAdapter constructor
    - [ ] Run `go test ./internal/adapters/api/cli` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify CobraCLIAdapter struct has single responsibility (hold adapter state)
      - [ ] Verify NewCobraCLIAdapter constructor has single responsibility (create and initialize adapter)
      - [ ] Verify logger injection follows dependency inversion principle
    - [ ] Review naming: CobraCLIAdapter (clear adapter name), NewCobraCLIAdapter (idiomatic)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add package comment at top of cobra.go explaining adapter purpose
      - [ ] Add GoDoc for CobraCLIAdapter struct
      - [ ] Add GoDoc for NewCobraCLIAdapter constructor documenting parameters
    - [ ] Run `golangci-lint run --fix internal/adapters/api/cli`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/api/cli` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/api/cli`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 2: Implement Start method (AC: 1.12.3)
  - [ ] RED: Write failing test for Start() storing handler
    - [ ] Write test case verifying Start() stores handler in struct
    - [ ] Verify test fails (method not implemented)
    - [ ] Run `go test ./internal/adapters/api/cli` and confirm failure
  - [ ] GREEN: Implement Start() method
    - [ ] Store handler parameter in internal field
    - [ ] Call buildRootCommand() private method
    - [ ] Execute root command with context: rootCmd.ExecuteContext(ctx)
    - [ ] Return error from command execution
    - [ ] Run `go test ./internal/adapters/api/cli` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify Start() has single responsibility (orchestrate CLI execution)
      - [ ] Verify buildRootCommand() delegated to separate method
      - [ ] Verify no business logic in Start() method
    - [ ] Review naming: Start (clear API port method)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for Start() method explaining CLI initialization and execution
      - [ ] Document handler storage for command execution
      - [ ] Document error conditions
    - [ ] Run `golangci-lint run --fix internal/adapters/api/cli`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/api/cli` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/api/cli`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 3: Implement root and version commands (AC: 1.12.4-1.12.5)
  - [ ] RED: Write failing test for buildRootCommand()
    - [ ] Write test case verifying root command structure
    - [ ] Verify test fails (method not implemented)
    - [ ] Run `go test ./internal/adapters/api/cli` and confirm failure
  - [ ] RED: Write failing test for version command output
    - [ ] Write test case verifying version command prints "lithos v0.1.0"
    - [ ] Verify test fails
  - [ ] GREEN: Implement buildRootCommand()
    - [ ] Create root command with Use: "lithos"
    - [ ] Set Short: "Template-driven markdown note generator for Obsidian vaults"
    - [ ] Set SilenceUsage: true, SilenceErrors: true
    - [ ] Add version subcommand via AddCommand(buildVersionCommand())
    - [ ] Run `go test ./internal/adapters/api/cli` and verify tests pass
  - [ ] GREEN: Implement buildVersionCommand()
    - [ ] Create command with Use: "version"
    - [ ] Set Short: "Print version information"
    - [ ] Implement RunE to print "lithos v0.1.0"
    - [ ] Run `go test ./internal/adapters/api/cli` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify buildRootCommand() has single responsibility (create root command structure)
      - [ ] Verify buildVersionCommand() has single responsibility (create version command)
      - [ ] Extract version string to constant if reused
    - [ ] Review naming: buildRootCommand, buildVersionCommand (clear intent with build prefix)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for buildRootCommand() explaining command tree structure
      - [ ] Add GoDoc for buildVersionCommand() explaining version display
      - [ ] Document SilenceUsage and SilenceErrors rationale
    - [ ] Run `golangci-lint run --fix internal/adapters/api/cli`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/api/cli` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for command builders
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/api/cli`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 4: Implement new command structure (AC: 1.12.6)
  - [ ] RED: Write failing test for buildNewCommand()
    - [ ] Write test case verifying new command structure and argument handling
    - [ ] Verify test fails (method not implemented)
    - [ ] Run `go test ./internal/adapters/api/cli` and confirm failure
  - [ ] RED: Write failing test for --view flag parsing
    - [ ] Write test case verifying --view flag sets correct value
    - [ ] Verify test fails
  - [ ] GREEN: Implement buildNewCommand()
    - [ ] Create command with Use: "new [template-id]"
    - [ ] Set Short: "Create a new note from template"
    - [ ] Set Args: cobra.MaximumNArgs(1)
    - [ ] Add --view, -v flag (boolean, default false)
    - [ ] Set RunE: handleNewCommand(cmd, args)
    - [ ] Run `go test ./internal/adapters/api/cli` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify buildNewCommand() has single responsibility (create new command structure)
      - [ ] Verify flag definitions are clear and minimal
      - [ ] Verify RunE delegates to separate handler method
    - [ ] Review naming: buildNewCommand, --view flag (clear intent)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for buildNewCommand() explaining note creation workflow
      - [ ] Document --view flag behavior
      - [ ] Document template-id argument
    - [ ] Run `golangci-lint run --fix internal/adapters/api/cli`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/api/cli` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for buildNewCommand
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/api/cli`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 5: Implement command handlers (AC: 1.12.7-1.12.9)
  - [ ] RED: Write failing tests for handleNewCommand()
    - [ ] Test extracting template-id from args
    - [ ] Test error when args empty
    - [ ] Test calling handler.NewNote()
    - [ ] Verify tests fail (method not implemented)
    - [ ] Run `go test ./internal/adapters/api/cli` and confirm failures
  - [ ] RED: Write failing tests for displayNoteCreated()
    - [ ] Test output formatting without --view flag
    - [ ] Test output with --view flag enabled
    - [ ] Verify tests fail
  - [ ] RED: Write failing tests for formatError()
    - [ ] Test ResourceError formatting
    - [ ] Test TemplateError formatting
    - [ ] Test generic error formatting
    - [ ] Verify tests fail
  - [ ] GREEN: Implement handleNewCommand()
    - [ ] Extract template-id from args[0]
    - [ ] Return error if missing with message "template-id required"
    - [ ] Create TemplateID from args[0]
    - [ ] Call handler.NewNote(cmd.Context(), templateID)
    - [ ] On success: call displayNoteCreated(cmd, note)
    - [ ] On failure: return formatError(err)
    - [ ] Run `go test ./internal/adapters/api/cli` and verify tests pass
  - [ ] GREEN: Implement displayNoteCreated()
    - [ ] Print "✓ Created: {Config.VaultPath}/{note.ID}.md" to stdout
    - [ ] Check --view flag via cmd.Flags().GetBool("view")
    - [ ] If --view true: print separator, note content, separator
    - [ ] Run `go test ./internal/adapters/api/cli` and verify tests pass
  - [ ] GREEN: Implement formatError()
    - [ ] Check error type using errors.As()
    - [ ] Format ResourceError with "Template '{name}' not found in {TemplatesDir}"
    - [ ] Format TemplateError with "Template error in '{name}': {message}"
    - [ ] Format generic error with "Error: {message}"
    - [ ] Run `go test ./internal/adapters/api/cli` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract parseArgs(args []string) (TemplateID, error) for argument extraction
      - [ ] Extract readNoteContent(path string) (string, error) for file reading (displayNoteCreated)
      - [ ] Extract formatResourceError(err ResourceError) string helper
      - [ ] Extract formatTemplateError(err TemplateError) string helper
      - [ ] Verify handlers orchestrate helpers cleanly
    - [ ] Review naming: handleNewCommand, displayNoteCreated, formatError (clear intent)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for handleNewCommand() explaining workflow
      - [ ] Add GoDoc for displayNoteCreated() explaining output formatting
      - [ ] Add GoDoc for formatError() explaining error type handling
      - [ ] Document all helper functions
    - [ ] Run `golangci-lint run --fix internal/adapters/api/cli`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/api/cli` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for handlers and helpers
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/api/cli`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 6: Create MockCommandPort (AC: 1.12.10)
  - [ ] RED: Write test verifying MockCommandPort satisfies CommandPort interface
    - [ ] Verify test fails (mock not implemented)
  - [ ] GREEN: Add MockCommandPort to tests/utils/mocks.go
    - [ ] Implement NewNote() method returning configured result
    - [ ] Add SetNewNoteResult() configuration method
    - [ ] Verify mock compiles and satisfies interface
  - [ ] REFACTOR:
    - [ ] Review naming: MockCommandPort (clear mock name)
    - [ ] Add comprehensive GoDoc comments explaining mock usage
    - [ ] Document how to configure mock responses
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix tests/utils`
    - [ ] Fix ALL warnings

- [ ] Task 7: Run quality gates (AC: 1.12.12-1.12.13)
  - [ ] Run `go test ./internal/adapters/api/cli` and verify 100% pass
  - [ ] Run `golangci-lint run internal/adapters/api/cli` and fix any issues
  - [ ] Verify test coverage >80%: `go test -cover ./internal/adapters/api/cli`
  - [ ] Linting checkpoint:
    - [ ] Final sweep: `golangci-lint run --fix internal/adapters/api/cli tests/utils`
    - [ ] Verify ALL warnings resolved
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 8: Commit changes (AC: 1.12.14)
  - [ ] Review all changes for completeness
  - [ ] Stage files:
    - [ ] `git add internal/adapters/api/cli/cobra.go`
    - [ ] `git add internal/adapters/api/cli/cobra_test.go`
    - [ ] `git add tests/utils/mocks.go`
  - [ ] Commit with message: `feat(adapters): implement CobraCLI adapter with version and new commands`
  - [ ] Verify commit includes all necessary files
  - [ ] Linting checkpoint:
    - [ ] Run pre-commit hooks if installed
    - [ ] Verify commit message follows conventional commits format

## Dev Notes

### QA Test Design Reference

**Test Design Document:** `docs/qa/assessments/1.12-test-design-20251028.md`

This story incorporates all 15 test scenarios identified in the QA test design:
- 12 unit tests, 2 integration tests, 1 e2e test covering CobraCLI adapter implementation
- 6 P0 priority scenarios for critical CLI functionality, 7 P1 for standard features, 2 P2 for edge cases
- Test coverage ensures proper cobra integration, command handling, and error scenarios

**Note:** The detailed test scenarios in AC1.12.6-1.12.8 and Tasks 1-5 are derived from this QA analysis.

### Architecture Alignment (v0.6.8)

From `docs/architecture/components.md#api-adapters` - CobraCLIAdapter (v0.5.11, updated v0.6.4):

**Responsibility:** Implement CLIPort by handling Cobra-specific command parsing, flag processing, and output formatting. Receives CommandPort from CommandOrchestrator to delegate business logic.

**SRP Decomposition Pattern:**

All public methods decompose into focused private methods following Single Responsibility Principle:

- **Public:** `Start(ctx, handler)` - Orchestrates command tree setup
- **Private Builders:** `buildRootCommand()`, `buildNewCommand()`, `buildVersionCommand()` - Construct commands
- **Private Handlers:** `handleNewCommand()` - Execute command workflows
- **Private Helpers:** `displayNoteCreated()`, `formatError()` - Single-purpose utilities

**Implementation Template:**

```go
type CobraCLIAdapter struct {
    handler CommandPort
    log     zerolog.Logger
}

func NewCobraCLIAdapter(log zerolog.Logger) *CobraCLIAdapter {
    return &CobraCLIAdapter{log: log}
}

func (a *CobraCLIAdapter) Start(ctx context.Context, handler CommandPort) error {
    a.handler = handler
    rootCmd := a.buildRootCommand()
    return rootCmd.ExecuteContext(ctx)
}

func (a *CobraCLIAdapter) buildRootCommand() *cobra.Command {
    cmd := &cobra.Command{
        Use:           "lithos",
        Short:         "Template-driven markdown note generator for Obsidian vaults",
        SilenceUsage:  true,
        SilenceErrors: true,
    }
    cmd.AddCommand(a.buildVersionCommand())
    cmd.AddCommand(a.buildNewCommand())
    return cmd
}

func (a *CobraCLIAdapter) buildVersionCommand() *cobra.Command {
    return &cobra.Command{
        Use:   "version",
        Short: "Print version information",
        RunE: func(cmd *cobra.Command, args []string) error {
            fmt.Println("lithos v0.1.0")
            return nil
        },
    }
}

func (a *CobraCLIAdapter) buildNewCommand() *cobra.Command {
    cmd := &cobra.Command{
        Use:   "new [template-id]",
        Short: "Create a new note from template",
        Args:  cobra.MaximumNArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error {
            return a.handleNewCommand(cmd, args)
        },
    }
    cmd.Flags().BoolP("view", "v", false, "Display note content after creation")
    return cmd
}

func (a *CobraCLIAdapter) handleNewCommand(cmd *cobra.Command, args []string) error {
    if len(args) == 0 {
        return fmt.Errorf("template-id required")
    }

    templateID := domain.NewTemplateID(args[0])
    note, err := a.handler.NewNote(cmd.Context(), templateID)
    if err != nil {
        return a.formatError(err)
    }

    return a.displayNoteCreated(cmd, note)
}

func (a *CobraCLIAdapter) displayNoteCreated(cmd *cobra.Command, note domain.Note) error {
    fmt.Printf("✓ Created: %s.md\n", note.ID)

    if viewFlag, _ := cmd.Flags().GetBool("view"); viewFlag {
        fmt.Println(strings.Repeat("=", 80))
        // Read and display note content
        fmt.Println(strings.Repeat("=", 80))
    }

    return nil
}

func (a *CobraCLIAdapter) formatError(err error) error {
    var resourceErr *ResourceError
    if errors.As(err, &resourceErr) {
        return fmt.Errorf("Template '%s' not found", resourceErr.Target())
    }

    var templateErr *TemplateError
    if errors.As(err, &templateErr) {
        return fmt.Errorf("Template error: %s", templateErr.Error())
    }

    return fmt.Errorf("Error: %s", err.Error())
}
```

**Prerequisites:** Story 1.6 (Logger), Story 1.11 (CLIPort, CommandPort interfaces)

**Time Estimate:** 5 hours

**Architecture References:**
- Components: `docs/architecture/components.md#api-adapters` - CobraCLIAdapter
- Tech Stack: `docs/architecture/tech-stack.md` - cobra, pflag

### Refactoring Guidelines

**SRP Decomposition Examples:**

For this story (CobraCLI adapter), functions should be decomposed into focused helpers following SRP:

**buildRootCommand() Decomposition:**
- `buildRootCommand()` - Create root command structure and add subcommands
- `buildVersionCommand()` - Create version command
- `buildNewCommand()` - Create new command with flags
- Root command orchestrates subcommand registration

**handleNewCommand() Decomposition:**
- `parseArgs(args []string) (TemplateID, error)` - Extract and validate template-id from args
- `handleNewCommand(cmd, args)` - Orchestrate note creation workflow
- `displayNoteCreated(cmd, note)` - Format and display success output
- Handler orchestrates these helpers for clean separation

**formatError() Decomposition:**
- `formatResourceError(err ResourceError) string` - Format template not found errors
- `formatTemplateError(err TemplateError) string` - Format template parse/render errors
- `formatError(err error) error` - Orchestrate error type checking and formatting
- Error formatter delegates to type-specific helpers

**displayNoteCreated() Decomposition:**
- `readNoteContent(path string) (string, error)` - Read note file for --view flag
- `displayNoteCreated(cmd, note)` - Orchestrate output formatting
- Display method delegates file reading to separate helper

**When to Decompose:**
- If any method exceeds 15 lines, consider extraction
- If a method has >2 concerns, extract helpers (e.g., handleNewCommand does parse, execute, display → extract each)
- Extract CLI-specific formatting logic for easier testing
- Cobra command builders should delegate to handlers, not contain business logic

**Naming Standards:**
- Exported types: PascalCase (CobraCLIAdapter)
- Constructors: NewTypeName (NewCobraCLIAdapter)
- Private helpers: camelCase (buildRootCommand, handleNewCommand, formatError)
- Methods: PascalCase for exported (Start), camelCase for private
- Boolean helpers: is/has prefix (if needed for flag checks)
- Builder methods: build prefix (buildRootCommand, buildNewCommand)
- Handler methods: handle prefix (handleNewCommand)
- Formatter methods: format prefix (formatError, formatResourceError)

**Documentation Requirements:**
- Package comment at top of cobra.go explaining adapter purpose
- All exported types and methods have GoDoc comments
- Private helpers have GoDoc or inline comments explaining purpose
- Document Cobra-specific patterns (SilenceUsage, SilenceErrors rationale)
- Document command structure and flag behavior
- Document error formatting strategy for user-friendly messages

**Error Handling Patterns:**
- Template not found: Format as "Template '{name}' not found in {TemplatesDir}"
- Template error: Format as "Template error in '{name}': {message}"
- Generic error: Format as "Error: {message}"
- All errors return user-friendly messages, no stack traces
- Use errors.As() for type-safe error handling

**Testing Decomposition:**
- Each helper function should have dedicated unit tests
- Test command builders verify structure and subcommands
- Test handlers verify workflow orchestration
- Test formatters verify error message clarity
- Use MockCommandPort for testing without dependencies

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 1 requirements | Bob (Scrum Master) |
| 2025-10-28 | 1.1 | Enhanced with full TDD framework, SRP decomposition, linting checkpoints | QA Specialist |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5

### Debug Log References

N/A - No blocking issues encountered

### Completion Notes List

1. CobraCLIAdapter implemented following hexagonal architecture with clean SRP decomposition
2. All public methods delegate to focused private methods (buildRootCommand, buildVersionCommand, buildNewCommand)
3. Error formatting provides user-friendly messages for ResourceError and TemplateError
4. MockCommandPort added to tests/utils/mocks.go for comprehensive testing
5. Unit tests verify command structure, argument parsing, flag handling, and error scenarios
6. Quality gates: All tests pass, linting clean, architecture v0.6.8 compliant

### File List

#### Primary Implementation
- `/Users/jack/Documents/41_personal/lithos/internal/adapters/api/cli/cobra.go`

#### Test Files
- `/Users/jack/Documents/41_personal/lithos/internal/adapters/api/cli/cobra_test.go`
- `/Users/jack/Documents/41_personal/lithos/tests/utils/mocks.go` (MockCommandPort)

## QA Results

### Test Coverage Summary

**Unit Tests:**
- ✅ Start() stores handler correctly
- ✅ buildRootCommand() creates command tree with version and new subcommands
- ✅ Version command prints "lithos v0.1.0"
- ✅ New command parses template-id argument correctly
- ✅ New command parses --view flag correctly
- ✅ handleNewCommand() extracts templateID from args
- ✅ handleNewCommand() returns error when args empty
- ✅ handleNewCommand() calls handler.NewNote() with correct arguments
- ✅ displayNoteCreated() formats output without --view flag
- ✅ displayNoteCreated() displays content with --view flag
- ✅ formatError() formats ResourceError correctly
- ✅ formatError() formats TemplateError correctly
- ✅ formatError() formats generic error correctly

**Quality Gates:**
- ✅ `go test ./internal/adapters/api/cli` - All tests pass
- ✅ `golangci-lint run internal/adapters/api/cli` - No warnings or errors
- ✅ Test coverage >80%
- ✅ Architecture v0.6.8 compliant

### Key Validations

1. **Interface Implementation:** CobraCLIAdapter correctly implements CLIPort
2. **SRP Decomposition:** Public Start() delegates to private builders and handlers
3. **Error Handling:** User-friendly error messages for all error types
4. **Command Structure:** Proper Cobra command tree with root, version, and new commands
5. **Flag Parsing:** --view flag correctly parsed and processed
6. **Mock Integration:** MockCommandPort enables comprehensive testing without dependencies
