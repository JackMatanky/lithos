# Story 1.7: Registry Package

## Status

Draft

## Story

**As a** developer,
**I want** to implement generic thread-safe registry with CQRS interfaces,
**so that** schemas and templates can be stored in-memory with concurrent read access.

## Acceptance Criteria

- 1.7.1: Create `internal/shared/registry/service.go`:
  - Uses Go 1.23+ generics: `Registry[T any]`
  - Thread-safe with `sync.RWMutex`
  - Internal storage: `map[string]T`

- 1.7.2: Define CQRS interfaces in same file:
  - `Reader[T any]` interface:
    - `Get(key string) (T, error)`
    - `Exists(key string) bool`
    - `ListKeys() []string`
  - `Writer[T any]` interface:
    - `Register(key string, value T) error`
    - `Clear()`
  - `Registry[T any]` interface embeds both Reader and Writer

- 1.7.3: Implement `registry[T any]` struct (unexported):
  - Fields: `mu sync.RWMutex`, `items map[string]T`
  - Constructor: `New[T any]() Registry[T]`

- 1.7.4: Implement all interface methods:
  - `Get()` uses `RLock()` for concurrent reads
  - `Register()` uses `Lock()` for exclusive writes
  - `Exists()` uses `RLock()` for concurrent reads
  - Returns `ErrNotFound` from errors package when key doesn't exist

- 1.7.5: Create unit tests in `internal/shared/registry/service_test.go`:
  - Test: Generic type instantiation works (string, int, custom struct)
  - Test: Concurrent reads don't block each other
  - Test: Writes block reads correctly
  - Test: ErrNotFound returned for missing keys
  - Test: ListKeys() returns all registered keys

- 1.7.6: Create benchmark tests:
  - Benchmark: Concurrent read performance
  - Benchmark: Write contention

- 1.7.7: All tests pass: `go test ./internal/shared/registry`

- 1.7.8: All linting passes: `golangci-lint run --fix internal/shared/registry`

- 1.7.9: Committed with message: `feat(shared): implement thread-safe registry with CQRS`

## Tasks / Subtasks

- [ ] Task 1: Implement CQRS interfaces (AC: 1.7.1-1.7.2)
  - [ ] RED: Write failing test for Registry interface definition
  - [ ] GREEN: Define Reader[T any] interface with Get/Exists/ListKeys
  - [ ] REFACTOR: Apply SRP decomposition checklist:
    - [ ] Verify Reader[T] has single responsibility (read-only access)
    - [ ] Verify Writer[T] has single responsibility (write-only access)
    - [ ] Verify Registry[T] has single responsibility (combine both interfaces)
    - [ ] Review naming: Reader, Writer, Registry (clear CQRS pattern)
    - [ ] Add comprehensive GoDoc for each interface
    - [ ] Document CQRS separation rationale
    - [ ] Run `golangci-lint run --fix internal/shared/registry`
    - [ ] Fix ALL linter warnings without using nolint
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/shared/registry`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 2: Implement registry struct and constructor (AC: 1.7.3)
  - [ ] RED: Write failing test for New() constructor
    - [ ] Write test case in service_test.go
    - [ ] Verify test fails with expected error message
    - [ ] Run `go test ./internal/shared/registry` and confirm failure
  - [ ] RED: Write test for empty registry behavior
    - [ ] Create test for zero-value behavior
    - [ ] Run `go test ./internal/shared/registry` and confirm failure
  - [ ] GREEN: Implement minimal code to pass tests
    - [ ] Implement unexported registry[T any] struct
    - [ ] Implement New[T any]() Registry[T] constructor
    - [ ] Initialize map in constructor
    - [ ] Run `go test ./internal/shared/registry` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR: Apply SRP decomposition checklist:
    - [ ] Verify registry[T] struct has single responsibility (storage management)
    - [ ] Verify New[T]() has single responsibility (construction)
    - [ ] Review naming: registry (unexported), New (idiomatic constructor)
    - [ ] Add comprehensive GoDoc for struct and constructor
    - [ ] Document generic parameter usage
    - [ ] Run `golangci-lint run --fix internal/shared/registry`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/shared/registry` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for constructor
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/shared/registry`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 3: Implement read methods (AC: 1.7.4)
  - [ ] RED: Write failing test for Get() with missing key
    - [ ] Write test case verifying ErrNotFound returned
    - [ ] Run `go test ./internal/shared/registry` and confirm failure
  - [ ] RED: Write failing test for Exists()
    - [ ] Write test case for key existence check
    - [ ] Run `go test ./internal/shared/registry` and confirm failure
  - [ ] RED: Write failing test for ListKeys()
    - [ ] Write test case verifying sorted keys returned
    - [ ] Run `go test ./internal/shared/registry` and confirm failure
  - [ ] GREEN: Implement minimal code to pass tests
    - [ ] Implement Get() with RLock and ErrNotFound
    - [ ] Implement Exists() with RLock
    - [ ] Implement ListKeys() returning sorted keys
    - [ ] Run `go test ./internal/shared/registry` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR: Apply SRP decomposition checklist:
    - [ ] Verify Get() has single responsibility (retrieve value by key)
    - [ ] Verify Exists() has single responsibility (check key existence)
    - [ ] Verify ListKeys() has single responsibility (return all keys)
    - [ ] Extract lockForRead() helper if lock logic >5 lines
    - [ ] Extract validateKey() helper if validation logic grows
    - [ ] Review naming: Get, Exists, ListKeys (clear intent)
    - [ ] Add comprehensive GoDoc for each method
    - [ ] Ensure proper lock release with defer
    - [ ] Run `golangci-lint run --fix internal/shared/registry`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/shared/registry` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for read methods
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/shared/registry`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 4: Implement write methods (AC: 1.7.4)
  - [ ] RED: Write failing test for Register()
    - [ ] Write test case for key registration
    - [ ] Run `go test ./internal/shared/registry` and confirm failure
  - [ ] RED: Write failing test for Clear()
    - [ ] Write test case for registry clearing
    - [ ] Run `go test ./internal/shared/registry` and confirm failure
  - [ ] GREEN: Implement minimal code to pass tests
    - [ ] Implement Register() with Lock
    - [ ] Implement Clear() resetting map
    - [ ] Run `go test ./internal/shared/registry` and verify all tests pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR: Apply SRP decomposition checklist:
    - [ ] Verify Register() has single responsibility (add key-value pair)
    - [ ] Verify Clear() has single responsibility (reset registry)
    - [ ] Extract lockForWrite() helper if lock logic >5 lines
    - [ ] Review naming: Register, Clear (clear intent)
    - [ ] Add comprehensive GoDoc for each method
    - [ ] Handle duplicate key registration appropriately
    - [ ] Run `golangci-lint run --fix internal/shared/registry`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/shared/registry` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for write methods
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/shared/registry`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 5: Test concurrent access (AC: 1.7.5)
  - [ ] RED: Write test for concurrent reads
    - [ ] Create test with multiple goroutines reading simultaneously
    - [ ] Run `go test ./internal/shared/registry` and verify behavior
  - [ ] RED: Write test for write blocking reads
    - [ ] Create test verifying exclusive write access
    - [ ] Run `go test ./internal/shared/registry` and verify behavior
  - [ ] GREEN: Verify tests pass with concurrent access
    - [ ] Use sync.WaitGroup for coordination
    - [ ] Test race conditions with `go test -race ./internal/shared/registry`
    - [ ] Verify no data races detected
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/shared/registry`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)

- [ ] Task 6: Test generic instantiation (AC: 1.7.5)
  - [ ] Test Registry[string] with string values
  - [ ] Test Registry[int] with integer values
  - [ ] Test Registry[CustomStruct] with custom types
  - [ ] Verify type safety enforced at compile time
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/shared/registry`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)

- [ ] Task 7: Create benchmarks (AC: 1.7.6)
  - [ ] Benchmark concurrent read performance
  - [ ] Benchmark write contention
  - [ ] Benchmark ListKeys() with large registries
  - [ ] Document performance characteristics
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/shared/registry`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)

- [ ] Task 8: Verify tests and linting (AC: 1.7.7-1.7.8)
  - [ ] Run `go test ./internal/shared/registry` - verify all pass
  - [ ] Run `go test -race ./internal/shared/registry` - verify no races
  - [ ] Run `go test -bench=. ./internal/shared/registry` - verify benchmarks
  - [ ] Run `golangci-lint run --fix internal/shared/registry` - verify no warnings
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/shared/registry`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 9: Commit changes (AC: 1.7.9)
  - [ ] Stage registry package files
  - [ ] Commit with message: `feat(shared): implement thread-safe registry with CQRS`

## Dev Notes

### Registry Package Architecture

From `docs/architecture/components.md#shared-internal-packages`:

**Registry Package Responsibility:** Generic in-memory registry implementation with CQRS-aware interfaces. Provides thread-safe storage for schemas and templates loaded at startup. Supports read-only access for validators/queries and write-only access for loaders. Generic implementation reusable across different data types.

**Architecture Layer:** Shared Internal Package (Cross-Cutting Concern). Used by Schema Service and Template Service. Not domain logic or infrastructure—pure technical pattern. Centralized to avoid code duplication.

**Key Interfaces:**
- `Reader[T any]` - Read-only access (`Get`, `Exists`, `ListKeys`)
- `Writer[T any]` - Write-only access (`Register`, `Clear`)
- `Persister` - Persistence operations (`SaveIndex`, `LoadIndex`)
- `Registry[T any]` - Full registry combining all capabilities
- `New[T any]() Registry[T]` - Constructor

**Dependencies:**
- Go stdlib `sync` package for RWMutex
- Go stdlib `encoding/json` for Persister (optional)

**Technology Stack:**
- Pure Go with generics (requires Go 1.23+)
- Go stdlib `sync.RWMutex` for thread-safe access

[Source: docs/architecture/components.md#registry-package]

### Registry Implementation Patterns

**CQRS Interface Pattern:**
```go
// Reader provides read-only access
type Reader[T any] interface {
    Get(key string) (T, error)
    Exists(key string) bool
    ListKeys() []string
}

// Writer provides write-only access
type Writer[T any] interface {
    Register(key string, value T) error
    Clear()
}

// Registry combines read and write interfaces
type Registry[T any] interface {
    Reader[T]
    Writer[T]
}
```

**Thread-Safe Implementation:**
```go
type registry[T any] struct {
    mu    sync.RWMutex
    items map[string]T
}

func New[T any]() Registry[T] {
    return &registry[T]{
        items: make(map[string]T),
    }
}

func (r *registry[T]) Get(key string) (T, error) {
    r.mu.RLock()
    defer r.mu.RUnlock()

    value, exists := r.items[key]
    if !exists {
        var zero T
        return zero, ErrNotFound
    }
    return value, nil
}

func (r *registry[T]) Register(key string, value T) error {
    r.mu.Lock()
    defer r.mu.Unlock()

    r.items[key] = value
    return nil
}

func (r *registry[T]) Exists(key string) bool {
    r.mu.RLock()
    defer r.mu.RUnlock()

    _, exists := r.items[key]
    return exists
}

func (r *registry[T]) ListKeys() []string {
    r.mu.RLock()
    defer r.mu.RUnlock()

    keys := make([]string, 0, len(r.items))
    for k := range r.items {
        keys = append(keys, k)
    }
    sort.Strings(keys) // Optional: return sorted keys
    return keys
}

func (r *registry[T]) Clear() {
    r.mu.Lock()
    defer r.mu.Unlock()

    r.items = make(map[string]T)
}
```

**Generic Usage Examples:**
```go
// Schema registry
schemaReg := registry.New[Schema]()
schemaReg.Register("contact", contactSchema)
schema, err := schemaReg.Get("contact")

// Template registry
templateReg := registry.New[Template]()
templateReg.Register("daily-note", dailyTemplate)
template, err := templateReg.Get("daily-note")
```

### Concurrency Patterns

**Read-Write Lock Benefits:**
- Multiple concurrent readers (RLock doesn't block other RLocks)
- Exclusive writer (Lock blocks all RLocks and Locks)
- Optimized for read-heavy workloads (schema/template lookups)

**Lock Usage:**
- `RLock()` for Get(), Exists(), ListKeys() - allows concurrent reads
- `Lock()` for Register(), Clear() - exclusive write access
- Always use `defer` for unlocking to handle panics

### Testing Standards

From `docs/architecture/testing-strategy.md`:

- Unit tests live beside code (`*_test.go`)
- Test generic type instantiation with multiple types
- Test concurrent access patterns with goroutines
- Use `go test -race` to detect race conditions
- Benchmark read and write performance
- Test error conditions (missing keys)

### File Locations

- Registry: `internal/shared/registry/service.go`
- Tests: `internal/shared/registry/service_test.go`

### Implementation Notes

**Key Requirements:**

1. **Generics:** Use Go 1.23+ generics for type-safe storage
2. **Thread Safety:** sync.RWMutex for concurrent read access
3. **CQRS Interfaces:** Separate Reader and Writer interfaces
4. **Error Handling:** Return ErrNotFound for missing keys
5. **Immutability:** ListKeys() returns copy, not reference

**Design Decisions:**

- **Unexported struct:** registry[T] is unexported, only interfaces exported
- **CQRS Pattern:** Enables read-only access for validators, write-only for loaders
- **Generic Parameter:** Single type parameter T for stored values
- **Map Storage:** Simple map[string]T for MVP, can optimize later
- **Sorted Keys:** ListKeys() returns sorted keys for deterministic behavior

**Performance Characteristics:**
- Get/Exists: O(1) with RLock (concurrent reads)
- Register: O(1) with Lock (exclusive writes)
- ListKeys: O(n log n) with sorting (can be optimized if order not needed)

### Refactoring Guidelines

**SRP Decomposition Examples:**

For this story, the Registry package focuses on thread-safe storage with CQRS pattern. SRP decomposition focuses on:

**Interface Separation:**
- Reader[T]: Single responsibility = provide read-only access
- Writer[T]: Single responsibility = provide write-only access
- Registry[T]: Single responsibility = combine both interfaces

**Implementation Methods:**
- Get(): Single responsibility = retrieve value by key with RLock
  - If error handling grows >10 lines, extract validateKey() helper
- Exists(): Single responsibility = check key existence with RLock
- ListKeys(): Single responsibility = return all keys sorted
  - If sorting logic becomes complex, extract sortKeys() helper
- Register(): Single responsibility = add key-value pair with Lock
  - Extract lockForWrite() if lock handling >5 lines
- Clear(): Single responsibility = reset registry with Lock

**Helper Extraction Criteria:**
- lockForRead(): Extract if lock acquisition+defer+logging >5 lines
- lockForWrite(): Extract if lock acquisition+defer+logging >5 lines
- validateKey(key string) error: Extract if validation logic needed

**When to Decompose:**
- If any method exceeds 15 lines, consider extraction
- If lock handling duplicated across methods, extract helper
- If error wrapping becomes complex, extract error factory

**Naming Standards:**
- Exported interfaces: PascalCase (Reader, Writer, Registry)
- Generic parameters: Single letter T for type (Reader[T], Writer[T])
- Unexported implementation: camelCase (registry[T])
- Constructors: New[T any]() for generic constructors
- Methods: PascalCase for exported (Get, Register, ListKeys)
- Boolean methods: is, has, can prefix (if added: IsEmpty(), HasKey())

**Documentation Requirements:**
- Package comment explaining CQRS pattern and generics
- All exported interfaces have GoDoc comments
- All methods have GoDoc explaining thread-safety guarantees
- Lock usage documented (RLock for reads, Lock for writes)
- Generic parameter T documented in interface comments

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 1 requirements | Bob (Scrum Master) |
| 2025-10-28 | 1.1 | Enhanced with full TDD framework, SRP decomposition, linting checkpoints | QA Specialist |

## Dev Agent Record

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
