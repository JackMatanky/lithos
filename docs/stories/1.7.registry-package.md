# Story 1.7: Registry Package

## Status

Draft

## Story

**As a** developer,
**I want** to implement generic thread-safe registry with CQRS interfaces,
**so that** schemas and templates can be stored in-memory with concurrent read access.

## Acceptance Criteria

- 1.7.1: Create `internal/shared/registry/service.go`:
  - Uses Go 1.23+ generics: `Registry[T any]`
  - Thread-safe with `sync.RWMutex`
  - Internal storage: `map[string]T`

- 1.7.2: Define CQRS interfaces in same file:
  - `Reader[T any]` interface:
    - `Get(key string) (T, error)`
    - `Exists(key string) bool`
    - `ListKeys() []string`
  - `Writer[T any]` interface:
    - `Register(key string, value T) error`
    - `Clear()`
  - `Registry[T any]` interface embeds both Reader and Writer

- 1.7.3: Implement `registry[T any]` struct (unexported):
  - Fields: `mu sync.RWMutex`, `items map[string]T`
  - Constructor: `New[T any]() Registry[T]`

- 1.7.4: Implement all interface methods:
  - `Get()` uses `RLock()` for concurrent reads
  - `Register()` uses `Lock()` for exclusive writes
  - `Exists()` uses `RLock()` for concurrent reads
  - Returns `ErrNotFound` from errors package when key doesn't exist

- 1.7.5: Create unit tests in `internal/shared/registry/service_test.go`:
  - Test: Generic type instantiation works (string, int, custom struct)
  - Test: Concurrent reads don't block each other
  - Test: Writes block reads correctly
  - Test: ErrNotFound returned for missing keys
  - Test: ListKeys() returns all registered keys

- 1.7.6: Create benchmark tests:
  - Benchmark: Concurrent read performance
  - Benchmark: Write contention

- 1.7.7: All tests pass: `go test ./internal/shared/registry`

- 1.7.8: All linting passes: `golangci-lint run --fix internal/shared/registry`

- 1.7.9: Committed with message: `feat(shared): implement thread-safe registry with CQRS`

## Tasks / Subtasks

- [ ] Task 1: Implement CQRS interfaces (AC: 1.7.1-1.7.2)
  - [ ] RED: Write failing test for Registry interface definition
  - [ ] GREEN: Define Reader[T any] interface with Get/Exists/ListKeys
  - [ ] REFACTOR: Document interface contracts
  - [ ] RED: Write failing test for Writer interface
  - [ ] GREEN: Define Writer[T any] interface with Register/Clear
  - [ ] REFACTOR: Document CQRS separation rationale
  - [ ] GREEN: Define Registry[T any] embedding Reader and Writer

- [ ] Task 2: Implement registry struct and constructor (AC: 1.7.3)
  - [ ] RED: Write failing test for New() constructor
  - [ ] GREEN: Implement unexported registry[T any] struct
  - [ ] REFACTOR: Initialize map in constructor
  - [ ] RED: Write test for empty registry behavior
  - [ ] GREEN: Verify constructor creates valid instance
  - [ ] REFACTOR: Add documentation for generic parameter

- [ ] Task 3: Implement read methods (AC: 1.7.4)
  - [ ] RED: Write failing test for Get() with missing key
  - [ ] GREEN: Implement Get() with RLock and ErrNotFound
  - [ ] REFACTOR: Ensure proper lock release with defer
  - [ ] RED: Write failing test for Exists()
  - [ ] GREEN: Implement Exists() with RLock
  - [ ] REFACTOR: Optimize existence check
  - [ ] RED: Write failing test for ListKeys()
  - [ ] GREEN: Implement ListKeys() returning sorted keys
  - [ ] REFACTOR: Consider key ordering

- [ ] Task 4: Implement write methods (AC: 1.7.4)
  - [ ] RED: Write failing test for Register()
  - [ ] GREEN: Implement Register() with Lock
  - [ ] REFACTOR: Handle duplicate key registration
  - [ ] RED: Write failing test for Clear()
  - [ ] GREEN: Implement Clear() resetting map
  - [ ] REFACTOR: Ensure proper lock handling

- [ ] Task 5: Test concurrent access (AC: 1.7.5)
  - [ ] RED: Write test for concurrent reads
  - [ ] GREEN: Verify reads don't block each other
  - [ ] REFACTOR: Use sync.WaitGroup for coordination
  - [ ] RED: Write test for write blocking reads
  - [ ] GREEN: Verify exclusive write access
  - [ ] REFACTOR: Test race conditions with -race flag

- [ ] Task 6: Test generic instantiation (AC: 1.7.5)
  - [ ] Test Registry[string] with string values
  - [ ] Test Registry[int] with integer values
  - [ ] Test Registry[CustomStruct] with custom types
  - [ ] Verify type safety enforced at compile time

- [ ] Task 7: Create benchmarks (AC: 1.7.6)
  - [ ] Benchmark concurrent read performance
  - [ ] Benchmark write contention
  - [ ] Benchmark ListKeys() with large registries
  - [ ] Document performance characteristics

- [ ] Task 8: Verify tests and linting (AC: 1.7.7-1.7.8)
  - [ ] Run `go test ./internal/shared/registry` - verify all pass
  - [ ] Run `go test -race ./internal/shared/registry` - verify no races
  - [ ] Run `go test -bench=. ./internal/shared/registry` - verify benchmarks
  - [ ] Run `golangci-lint run --fix internal/shared/registry` - verify no warnings

- [ ] Task 9: Commit changes (AC: 1.7.9)
  - [ ] Stage registry package files
  - [ ] Commit with message: `feat(shared): implement thread-safe registry with CQRS`

## Dev Notes

### Registry Package Architecture

From `docs/architecture/components.md#shared-internal-packages`:

**Registry Package Responsibility:** Generic in-memory registry implementation with CQRS-aware interfaces. Provides thread-safe storage for schemas and templates loaded at startup. Supports read-only access for validators/queries and write-only access for loaders. Generic implementation reusable across different data types.

**Architecture Layer:** Shared Internal Package (Cross-Cutting Concern). Used by Schema Service and Template Service. Not domain logic or infrastructureâ€”pure technical pattern. Centralized to avoid code duplication.

**Key Interfaces:**
- `Reader[T any]` - Read-only access (`Get`, `Exists`, `ListKeys`)
- `Writer[T any]` - Write-only access (`Register`, `Clear`)
- `Persister` - Persistence operations (`SaveIndex`, `LoadIndex`)
- `Registry[T any]` - Full registry combining all capabilities
- `New[T any]() Registry[T]` - Constructor

**Dependencies:**
- Go stdlib `sync` package for RWMutex
- Go stdlib `encoding/json` for Persister (optional)

**Technology Stack:**
- Pure Go with generics (requires Go 1.23+)
- Go stdlib `sync.RWMutex` for thread-safe access

[Source: docs/architecture/components.md#registry-package]

### Registry Implementation Patterns

**CQRS Interface Pattern:**
```go
// Reader provides read-only access
type Reader[T any] interface {
    Get(key string) (T, error)
    Exists(key string) bool
    ListKeys() []string
}

// Writer provides write-only access
type Writer[T any] interface {
    Register(key string, value T) error
    Clear()
}

// Registry combines read and write interfaces
type Registry[T any] interface {
    Reader[T]
    Writer[T]
}
```

**Thread-Safe Implementation:**
```go
type registry[T any] struct {
    mu    sync.RWMutex
    items map[string]T
}

func New[T any]() Registry[T] {
    return &registry[T]{
        items: make(map[string]T),
    }
}

func (r *registry[T]) Get(key string) (T, error) {
    r.mu.RLock()
    defer r.mu.RUnlock()

    value, exists := r.items[key]
    if !exists {
        var zero T
        return zero, ErrNotFound
    }
    return value, nil
}

func (r *registry[T]) Register(key string, value T) error {
    r.mu.Lock()
    defer r.mu.Unlock()

    r.items[key] = value
    return nil
}

func (r *registry[T]) Exists(key string) bool {
    r.mu.RLock()
    defer r.mu.RUnlock()

    _, exists := r.items[key]
    return exists
}

func (r *registry[T]) ListKeys() []string {
    r.mu.RLock()
    defer r.mu.RUnlock()

    keys := make([]string, 0, len(r.items))
    for k := range r.items {
        keys = append(keys, k)
    }
    sort.Strings(keys) // Optional: return sorted keys
    return keys
}

func (r *registry[T]) Clear() {
    r.mu.Lock()
    defer r.mu.Unlock()

    r.items = make(map[string]T)
}
```

**Generic Usage Examples:**
```go
// Schema registry
schemaReg := registry.New[Schema]()
schemaReg.Register("contact", contactSchema)
schema, err := schemaReg.Get("contact")

// Template registry
templateReg := registry.New[Template]()
templateReg.Register("daily-note", dailyTemplate)
template, err := templateReg.Get("daily-note")
```

### Concurrency Patterns

**Read-Write Lock Benefits:**
- Multiple concurrent readers (RLock doesn't block other RLocks)
- Exclusive writer (Lock blocks all RLocks and Locks)
- Optimized for read-heavy workloads (schema/template lookups)

**Lock Usage:**
- `RLock()` for Get(), Exists(), ListKeys() - allows concurrent reads
- `Lock()` for Register(), Clear() - exclusive write access
- Always use `defer` for unlocking to handle panics

### Testing Standards

From `docs/architecture/testing-strategy.md`:

- Unit tests live beside code (`*_test.go`)
- Test generic type instantiation with multiple types
- Test concurrent access patterns with goroutines
- Use `go test -race` to detect race conditions
- Benchmark read and write performance
- Test error conditions (missing keys)

### File Locations

- Registry: `internal/shared/registry/service.go`
- Tests: `internal/shared/registry/service_test.go`

### Implementation Notes

**Key Requirements:**

1. **Generics:** Use Go 1.23+ generics for type-safe storage
2. **Thread Safety:** sync.RWMutex for concurrent read access
3. **CQRS Interfaces:** Separate Reader and Writer interfaces
4. **Error Handling:** Return ErrNotFound for missing keys
5. **Immutability:** ListKeys() returns copy, not reference

**Design Decisions:**

- **Unexported struct:** registry[T] is unexported, only interfaces exported
- **CQRS Pattern:** Enables read-only access for validators, write-only for loaders
- **Generic Parameter:** Single type parameter T for stored values
- **Map Storage:** Simple map[string]T for MVP, can optimize later
- **Sorted Keys:** ListKeys() returns sorted keys for deterministic behavior

**Performance Characteristics:**
- Get/Exists: O(1) with RLock (concurrent reads)
- Register: O(1) with Lock (exclusive writes)
- ListKeys: O(n log n) with sorting (can be optimized if order not needed)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 1 requirements | Bob (Scrum Master) |

## Dev Agent Record

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
