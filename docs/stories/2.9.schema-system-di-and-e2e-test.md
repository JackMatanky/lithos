# Story 2.9: Wire Schema System Dependency Injection and Create End-to-End Tests

## Status

Draft

## Story

**As a** developer,
**I want** to wire all schema system components in main.go using constructor-based dependency injection and create end-to-end tests,
**so that** the complete schema loading workflow works from CLI invocation with proper initialization order.

## Acceptance Criteria

**Dependency Injection in main.go:**

- 2.9.1: Update main() function in `cmd/lithos/main.go` to initialize schema system:
  - Follow initialization order per architecture v0.6.8 (after config, before command orchestrator)
  - Insert schema system initialization between layers 2 and 3

- 2.9.2: Schema infrastructure layer initialization (after Config, before TemplateEngine):
  - Create SchemaLoaderAdapter: `schemaLoader := schema.NewLoaderAdapter(cfg, log)`
  - Create SchemaRegistryAdapter: `schemaRegistry := schema.NewRegistryAdapter(log)`

- 2.9.3: Schema service initialization:
  - Create SchemaEngine: `schemaEngine := app.NewSchemaEngine(schemaLoader, schemaRegistry, log)`
  - Call Load: `err := schemaEngine.Load(ctx)` - **fatal error if fails**

- 2.9.4: Update CommandOrchestrator initialization:
  - Add SchemaEngine to CommandOrchestrator dependencies
  - Update constructor: `orchestrator := app.NewCommandOrchestrator(cliAdapter, templateEngine, schemaEngine, cfg, log)`
  - Update CommandOrchestrator struct and constructor in `internal/app/command_orchestrator.go`

- 2.9.5: Error handling:
  - Schema load failure → `log.Fatal().Err(err).Msg("failed to load schemas")`
  - Log stage durations at info level per NFR3 observability requirements
  - Fatal errors include remediation hints per error-handling-strategy.md

**End-to-End Tests:**

- 2.9.6: Create `tests/e2e/lithos_schema_test.go`:
  - Test scenario: Full schema loading workflow from CLI startup to schema registration
  - Setup:
    - Create temporary vault directory using `os.MkdirTemp`
    - Create schemas/ and templates/ subdirectories
    - Copy valid schema files from testdata/schemas/ to temp vault
    - Copy property_bank.json from testdata/schemas/ to temp vault
    - Set environment variable LITHOS_VAULT_PATH to temp directory
  - Execute:
    - Build lithos binary: `go build -o {tempDir}/lithos cmd/lithos/main.go`
    - Run command with schema-dependent operation (to be determined based on Epic 3 integration)
    - For now: verify startup succeeds with schemas loaded (check logs/exit code)
  - Verify:
    - Command exits with code 0
    - Logs indicate schema loading completed successfully
    - Verify stage durations logged (loading, validation, resolution, registration)
  - Cleanup:
    - Remove temporary directory

- 2.9.7: Additional test scenarios in same file:
  - Test: Missing property_bank.json returns exit code 1 with actionable error
  - Test: Invalid schema JSON returns exit code 1 with file path context
  - Test: Circular inheritance detected returns exit code 1 with schema names
  - Test: Missing $ref target returns exit code 1 with property ID
  - Test: Duplicate schema names returns exit code 1 with conflicting names

**Integration Tests:**

- 2.9.8: Create `tests/integration/schema_system_test.go`:
  - Test: SchemaEngine with real adapters loads valid fixtures
  - Test: SchemaEngine properly validates and resolves inheritance
  - Test: SchemaRegistry concurrent access is thread-safe
  - Test: Error messages include remediation hints
  - Golden files for expected error output

**Manual Testing:**

- 2.9.9: Manual test checklist (documented in story, not automated):
  - Build: `go build -o bin/lithos cmd/lithos/main.go`
  - Run: `./bin/lithos version` with schemas/ directory → loads schemas on startup
  - Verify: Logs show schema loading stages with durations
  - Run: `./bin/lithos version` with missing property_bank.json → shows actionable error
  - Run: `./bin/lithos version` with invalid schema JSON → shows file path and error
  - Run: `./bin/lithos version` with circular inheritance → detects cycle and reports schemas
  - Verify: All error messages include remediation hints
  - Verify: Schema load time <100ms for typical vault (NFR3)
  - Verify: Environment variables override config (test with LITHOS_SCHEMAS_DIR)

- 2.9.10: All tests pass: `go test ./...` (all packages)

- 2.9.11: All linting passes: `golangci-lint run` (all code)

- 2.9.12: Committed with message: `feat(schema): wire schema system DI in main.go and add e2e tests`

## Tasks / Subtasks

- [ ] Task 1: Update main.go with schema system initialization (AC: 2.9.1-2.9.3)
  - [ ] Add schema loader initialization after config load
  - [ ] Add schema registry initialization
  - [ ] Add schema engine initialization
  - [ ] Call schemaEngine.Load(ctx) with fatal error handling
  - [ ] Add schema load failure error handling with remediation hints
  - [ ] Document schema system initialization order in comments
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix cmd/lithos`
    - [ ] Fix ALL warnings

- [ ] Task 2: Update CommandOrchestrator dependencies (AC: 2.9.4)
  - [ ] Add SchemaEngine field to CommandOrchestrator struct
  - [ ] Update NewCommandOrchestrator constructor signature
  - [ ] Update constructor implementation to accept schemaEngine parameter
  - [ ] Update main.go to pass schemaEngine to orchestrator
  - [ ] Verify application compiles: `go build -o bin/lithos cmd/lithos/main.go`
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app`
    - [ ] Fix ALL warnings

- [ ] Task 3: Create e2e test infrastructure (AC: 2.9.6)
  - [ ] Create tests/e2e/lithos_schema_test.go
  - [ ] Implement temp directory setup with schemas/ and property_bank.json
  - [ ] Copy schema fixtures from testdata/schemas/
  - [ ] Implement binary build and execution
  - [ ] Verify schema loading logs and exit code
  - [ ] Implement cleanup with defer
  - [ ] Document test flow in comments
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix tests/e2e`
    - [ ] Fix ALL warnings

- [ ] Task 4: Add e2e error scenarios (AC: 2.9.7)
  - [ ] Test: Missing property_bank.json error handling
  - [ ] Test: Invalid schema JSON error handling
  - [ ] Test: Circular inheritance detection
  - [ ] Test: Missing $ref target error handling
  - [ ] Test: Duplicate schema names error handling
  - [ ] Verify all error scenarios include remediation hints
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix tests/e2e`
    - [ ] Fix ALL warnings

- [ ] Task 5: Create integration tests (AC: 2.9.8)
  - [ ] Create tests/integration/schema_system_test.go
  - [ ] Test SchemaEngine with real adapters and fixtures
  - [ ] Test validation and resolution with complex inheritance
  - [ ] Test concurrent registry access (thread safety)
  - [ ] Create golden files for error output
  - [ ] Verify error messages include remediation hints
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix tests/integration`
    - [ ] Fix ALL warnings

- [ ] Task 6: Manual testing (AC: 2.9.9)
  - [ ] Build: `go build -o bin/lithos cmd/lithos/main.go` succeeds
  - [ ] Version with schemas: logs show loading stages with durations
  - [ ] Missing property bank: shows actionable error message
  - [ ] Invalid schema JSON: shows file path and parse error
  - [ ] Circular inheritance: detects cycle and reports schema names
  - [ ] All errors include remediation hints
  - [ ] Schema load time <100ms for typical vault
  - [ ] Environment variables override config
  - [ ] Document all manual test results

- [ ] Task 7: Run quality gates (AC: 2.9.10-2.9.11)
  - [ ] Run full test suite: `go test ./...` and verify 100% pass
  - [ ] Run linting: `golangci-lint run` and fix any issues
  - [ ] Verify test coverage >70% for domain/app layers
  - [ ] Linting checkpoint:
    - [ ] Final sweep: `golangci-lint run --fix`
    - [ ] Verify ALL warnings resolved
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 8: Commit changes (AC: 2.9.12)
  - [ ] Review all changes for completeness
  - [ ] Stage files:
    - [ ] `git add cmd/lithos/main.go`
    - [ ] `git add internal/app/command_orchestrator.go`
    - [ ] `git add tests/e2e/lithos_schema_test.go`
    - [ ] `git add tests/integration/schema_system_test.go`
    - [ ] `git add testdata/schemas/`
  - [ ] Commit with message: `feat(schema): wire schema system DI in main.go and add e2e tests`
  - [ ] Verify commit includes all necessary files
  - [ ] Linting checkpoint:
    - [ ] Run pre-commit hooks if installed
    - [ ] Verify commit message follows conventional commits format

## Dev Notes

### QA Test Design Reference

**Test Design Document:** `docs/qa/assessments/2.9-test-design-YYYYMMDD.md`

This story incorporates comprehensive test scenarios for schema system dependency injection and e2e testing:

- Unit tests for DI wiring, integration tests for schema loading, e2e tests for full workflow
- Test coverage ensures proper dependency injection, schema validation/resolution, and end-to-end functionality
- Error scenarios validate actionable error messages with remediation hints

### Architecture Alignment (v0.6.8)

From `docs/architecture/components.md#dependency-injection-pattern`:

**Updated Initialization Order:**

Dependencies are constructed in specific order to satisfy the dependency graph:

**1. Infrastructure Layer (bottom-up):**

- Logger (zero dependencies)
- Config via ViperAdapter (depends on Logger)

**2. SPI Adapters (driven):**

- TemplateLoaderAdapter (depends on Config, Logger)
- **SchemaLoaderAdapter (depends on Config, Logger)** ← NEW
- **SchemaRegistryAdapter (depends on Logger)** ← NEW

**3. Domain Services (core):**

- **SchemaEngine (depends on SchemaPort, SchemaRegistryPort, Logger)** ← NEW
  - Calls Load(ctx) to initialize schema system
  - Must complete before services that depend on schemas
- TemplateEngine (depends on TemplatePort, Config, Logger)

**4. API Adapters (driving):**

- CobraCLIAdapter (depends on Logger)

**5. CommandOrchestrator (application service):**

- CommandOrchestrator (depends on CLIPort, TemplateEngine, **SchemaEngine**, Config, Logger) ← UPDATED

**Example main.go Structure with Schema System:**

```go
func main() {
    ctx := context.Background()

    // 1. Infrastructure Layer
    log := logger.New(os.Stdout, "info")

    configAdapter := viper.NewAdapter(log)
    cfg, err := configAdapter.Load(ctx)
    if err != nil {
        log.Fatal().Err(err).Msg("failed to load configuration")
    }

    // Update logger from config
    log = logger.New(os.Stdout, cfg.LogLevel)

    // 2. SPI Adapters
    templateLoader := template.NewTemplateLoaderAdapter(cfg, log)
    schemaLoader := schema.NewLoaderAdapter(cfg, log)
    schemaRegistry := schema.NewRegistryAdapter(log)

    // 3. Domain Services
    // Schema system must load before services that depend on schemas
    schemaEngine := app.NewSchemaEngine(schemaLoader, schemaRegistry, log)
    if err := schemaEngine.Load(ctx); err != nil {
        log.Fatal().Err(err).Msg("failed to load schemas")
    }

    templateEngine := app.NewTemplateEngine(templateLoader, cfg, log)

    // 4. API Adapter
    cliAdapter := cli.NewCobraCLIAdapter(log)

    // 5. CommandOrchestrator
    orchestrator := app.NewCommandOrchestrator(
        cliAdapter,
        templateEngine,
        schemaEngine,  // Add schema engine
        cfg,
        log,
    )

    // Start the application
    if err := orchestrator.Run(ctx); err != nil {
        log.Fatal().Err(err).Msg("application failed")
    }
}
```

**Design Principles:**

- **No DI Framework:** Pure Go constructors sufficient for current scope
- **Explicit Dependencies:** All dependencies visible in constructor signatures
- **Fail Fast:** Schema loading errors terminate at startup (before command execution)
- **Single Instantiation:** Each component instantiated once, passed by reference
- **Constructor Injection:** All dependencies provided via `New*()` functions
- **Interface Types:** Services depend on port interfaces, not concrete adapters
- **Schema System Initialization:** Must complete before services that depend on schemas

### End-to-End Testing

From `docs/architecture/testing-strategy.md`:

**E2E Test Organization:**

- Tests in `tests/e2e/` directory
- Build actual binary from cmd/lithos/main.go
- Execute as subprocess with real filesystem
- Verify complete schema loading workflow end-to-end

**Test Pattern:**

```go
func TestLithos_SchemaLoading_Success(t *testing.T) {
    // Setup: Create temp vault with schemas
    tempDir, err := os.MkdirTemp("", "lithos-e2e-*")
    require.NoError(t, err)
    defer os.RemoveAll(tempDir)

    schemasDir := filepath.Join(tempDir, "schemas")
    require.NoError(t, os.MkdirAll(schemasDir, 0755))

    // Copy schema fixtures
    srcSchemas := filepath.Join("testdata", "schemas")
    copyDir(t, srcSchemas, schemasDir)

    // Copy property bank
    srcBank := filepath.Join("testdata", "schemas", "property_bank.json")
    dstBank := filepath.Join(schemasDir, "property_bank.json")
    copyFile(t, srcBank, dstBank)

    // Build binary
    binaryPath := filepath.Join(tempDir, "lithos")
    cmd := exec.Command("go", "build", "-o", binaryPath, "../../cmd/lithos")
    require.NoError(t, cmd.Run())

    // Execute: lithos version (triggers schema loading)
    cmd = exec.Command(binaryPath, "version")
    cmd.Env = append(os.Environ(), fmt.Sprintf("LITHOS_VAULT_PATH=%s", tempDir))
    output, err := cmd.CombinedOutput()
    require.NoError(t, err, "command output: %s", output)

    // Verify: Exit code 0 and logs show schema loading
    assert.Contains(t, string(output), "loading schemas")
    assert.Contains(t, string(output), "schemas registered")
}
```

**Prerequisites:** Stories 2.1-2.8 (Schema system components)

**Time Estimate:** 5-6 hours

**Architecture References:**

- Components: `docs/architecture/components.md#dependency-injection-pattern`
- Components: `docs/architecture/components.md#schemaengine`
- Testing: `docs/architecture/testing-strategy.md`
- Errors: `docs/architecture/error-handling-strategy.md`

### Refactoring Guidelines

**DI Wiring Guidelines:**

For this story (Schema System Dependency Injection), follow these patterns:

**Initialization Order (Updated 5 Layers):**

1. **Infrastructure:** Logger (zero deps), Config (depends on Logger)
2. **SPI Adapters:** TemplateLoaderAdapter, SchemaLoaderAdapter, SchemaRegistryAdapter
3. **Domain Services:** SchemaEngine (load schemas FIRST), TemplateEngine
4. **API Adapters:** CobraCLIAdapter
5. **Orchestrator:** CommandOrchestrator (updated with SchemaEngine dependency)

**Schema System DI Best Practices:**

- Schema system loads before services that depend on schemas
- SchemaEngine.Load() must complete successfully or application fails fast
- All schema dependencies injected via constructors
- SchemaValidator and SchemaResolver instantiated internally by SchemaEngine
- Fail fast: Schema loading errors terminate at startup with actionable messages
- Stage logging: All schema loading stages logged with durations (NFR3 observability)

**CommandOrchestrator Updates:**

```go
type CommandOrchestrator struct {
    cliPort        ports.CLIPort
    templateEngine *app.TemplateEngine
    schemaEngine   *app.SchemaEngine  // Add this
    config         domain.Config
    log            logger.Logger
}

func NewCommandOrchestrator(
    cliPort ports.CLIPort,
    templateEngine *app.TemplateEngine,
    schemaEngine *app.SchemaEngine,  // Add this
    config domain.Config,
    log logger.Logger,
) *CommandOrchestrator {
    return &CommandOrchestrator{
        cliPort:        cliPort,
        templateEngine: templateEngine,
        schemaEngine:   schemaEngine,  // Add this
        config:         config,
        log:            log,
    }
}
```

**Documentation Requirements:**

- Document updated initialization order with inline comments
- Document schema system initialization must complete before dependent services
- Document fail-fast strategy for schema load failures
- Document stage logging for NFR3 observability requirements
- Reference error-handling-strategy.md for remediation hints

**E2E Testing Patterns:**

- Build actual binary from cmd/lithos/main.go
- Execute as subprocess with real filesystem
- Test both success and error scenarios
- Verify error messages include remediation hints
- Use temp directories for vault and schema writes
- Environment variables for configuration
- Golden file comparison for error output verification

**Manual Testing Checklist:**

- Schema loading completes successfully with valid schemas
- Stage durations logged (loading, validation, resolution, registration)
- Schema load time <100ms for typical vault (NFR3)
- Error messages are actionable with remediation hints
- Missing property bank shows helpful error
- Invalid schema JSON shows file path context
- Circular inheritance detected with schema names
- Missing $ref shows property ID
- Duplicate schema names reported clearly

## Change Log

| Date       | Version | Description                                                                        | Author             |
| ---------- | ------- | ---------------------------------------------------------------------------------- | ------------------ |
| 2025-10-29 | 1.0     | Story created from Epic 2 requirements                                             | Sarah (PO)         |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
