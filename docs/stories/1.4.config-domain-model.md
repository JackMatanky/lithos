# Story 1.4: Config Domain Model

## Status

Draft

## Story

**As a** developer,
**I want** to implement the Config domain model as a value object,
**so that** configuration is represented in the domain layer.

## Acceptance Criteria

- 1.4.1: Create `internal/domain/config.go`:
  - Field: `VaultPath string` (default: ".")
  - Field: `TemplatesDir string` (default: "templates/")
  - Field: `SchemasDir string` (default: "schemas/")
  - Field: `PropertyBankFile string` (default: "property_bank.json")
  - Field: `CacheDir string` (default: ".lithos/cache/")
  - Field: `LogLevel string` (default: "info")
  - Constructor: `NewConfig(...)` with all fields
  - Constructor: `DefaultConfig()` using defaults

- 1.4.2: Create unit tests in `internal/domain/config_test.go`:
  - Test: NewConfig constructs with all fields
  - Test: DefaultConfig uses correct defaults
  - Test: Config is immutable (copy on modification pattern if needed)

- 1.4.3: All tests pass: `go test ./internal/domain`

- 1.4.4: All linting passes: `golangci-lint run --fix internal/domain`

- 1.4.5: Committed with message: `feat(domain): implement Config model`

## Tasks / Subtasks

- [ ] Task 1: Implement Config model in internal/domain/config.go (AC: 1.4.1)
  - [ ] RED: Write failing test for NewConfig constructor
    - [ ] Write test case in `internal/domain/config_test.go`
    - [ ] Verify test fails with expected error message
    - [ ] Run `go test ./internal/domain` and confirm failure
  - [ ] GREEN: Implement Config struct and NewConfig constructor
    - [ ] Implement Config struct with all fields
    - [ ] Implement NewConfig constructor
    - [ ] Run `go test ./internal/domain` and verify pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Verify Config struct has single responsibility (hold configuration data)
      - [ ] Verify NewConfig has single responsibility (create Config with all fields)
      - [ ] Verify DefaultConfig has single responsibility (create Config with defaults)
    - [ ] Review naming: Config (clear value object), NewConfig (idiomatic), DefaultConfig (clear intent)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add package comment at top of config.go if not present
      - [ ] Add GoDoc for Config struct explaining value object pattern
      - [ ] Add GoDoc for each field explaining purpose and default
      - [ ] Add GoDoc for NewConfig constructor
      - [ ] Add GoDoc for DefaultConfig constructor
    - [ ] Run `golangci-lint run --fix internal/domain`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/domain` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for Config
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/domain`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification
  - [ ] RED: Write failing test for DefaultConfig constructor
    - [ ] Write test case verifying all default values
    - [ ] Run `go test ./internal/domain` and confirm failure
  - [ ] GREEN: Implement DefaultConfig with correct defaults
    - [ ] Implement DefaultConfig() returning Config with all defaults
    - [ ] Run `go test ./internal/domain` and verify pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR: Extract default values as constants if appropriate
    - [ ] Consider extracting default constants if used in multiple places
    - [ ] Review if defaults should be public or private
    - [ ] Add documentation explaining default value choices
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/domain`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 2: Create comprehensive unit tests (AC: 1.4.2)
  - [ ] RED: Write test for NewConfig with all fields
    - [ ] Write test case in `internal/domain/config_test.go`
    - [ ] Verify test fails with expected error message
    - [ ] Run `go test ./internal/domain` and confirm failure
  - [ ] GREEN: Verify NewConfig constructs correctly
    - [ ] Implement test assertions for all fields
    - [ ] Run `go test ./internal/domain` and verify pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR: Use table-driven tests if multiple cases
    - [ ] Consider table-driven pattern for multiple config scenarios
    - [ ] Add test cases for different field combinations
    - [ ] Ensure test readability and maintainability
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/domain`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification
  - [ ] RED: Write test for DefaultConfig defaults
    - [ ] Write test case verifying each default value
    - [ ] Run `go test ./internal/domain` and confirm failure
  - [ ] GREEN: Verify all defaults match specification
    - [ ] Assert VaultPath = "."
    - [ ] Assert TemplatesDir = "templates/"
    - [ ] Assert SchemasDir = "schemas/"
    - [ ] Assert PropertyBankFile = "property_bank.json"
    - [ ] Assert CacheDir = ".lithos/cache/"
    - [ ] Assert LogLevel = "info"
    - [ ] Run `go test ./internal/domain` and verify pass
    - [ ] Verify no other tests broken
  - [ ] REFACTOR: Add test cases for field validation if needed
    - [ ] Consider if Config needs validation logic
    - [ ] Test immutability if applicable
    - [ ] Add edge case tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/domain`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 3: Verify tests and linting (AC: 1.4.3-1.4.4)
  - [ ] Run `go test ./internal/domain` - verify all pass
  - [ ] Run `golangci-lint run --fix internal/domain` - verify no warnings
  - [ ] Review test coverage for completeness
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/domain`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 4: Commit changes (AC: 1.4.5)
  - [ ] Stage changes: `git add internal/domain/config.go internal/domain/config_test.go`
  - [ ] Commit with message: `feat(domain): implement Config model`

## Dev Notes

### Config Model Architecture

From `docs/architecture/data-models.md#config`:

**Purpose:** Application configuration loaded from `lithos.json` and environment variables. Defines vault structure and operational settings. Immutable value object representing application configuration state.

**Architecture Layer:** Domain Core (Value Object)

**Rationale:** Config is a DDD value object—immutable configuration data identified by its attributes. While loaded by ConfigLoader adapter, the Config model itself represents domain knowledge about vault structure (where templates, schemas, property bank live). Domain services receive Config via dependency injection to locate resources.

**Key Attributes:**

- `VaultPath` (string) - Root directory of vault. Default: current working directory. All relative paths in config are resolved relative to this. Must exist and be readable. ConfigLoader searches upward from current directory to find `lithos.json`, then uses that directory as VaultPath.
- `TemplatesDir` (string) - Path to templates directory. Default: `{VaultPath}/templates/`. Can be absolute or relative to VaultPath. Must exist for `lithos new` and `lithos find` commands. TemplateLoader scans all `.md` files in this directory.
- `SchemasDir` (string) - Path to schemas directory. Default: `{VaultPath}/schemas/`. Can be absolute or relative to VaultPath. Must exist if schemas are used. SchemaLoader parses all schema JSON files in this directory at startup.
- `PropertyBankFile` (string) - Filename of property bank file within SchemasDir. Default: `property_bank.json`. Full path is `{SchemasDir}/{PropertyBankFile}`. Optional—if missing, schemas cannot use `$ref` references.
- `CacheDir` (string) - Path to index cache directory. Default: `{VaultPath}/.lithos/cache/`. Can be absolute or relative to VaultPath. Created automatically if missing. Must be writable. JSONFileCacheAdapter stores one `.json` file per indexed note.
- `LogLevel` (string) - Logging verbosity for zerolog. One of: "debug", "info", "warn", "error". Default: "info". Case-insensitive. Invalid values fall back to "info" with warning. Controls stdout/stderr output verbosity.

**Design Decisions:**

- **Value object (DDD):** Immutable configuration data identified by its attributes. Two Config instances with identical values are equivalent. Loaded once at startup, never modified.
- **Flat structure:** No nested config objects for MVP simplicity. All settings are top-level keys in JSON. This keeps config file simple and reduces unmarshaling complexity.
- **Sensible defaults:** Empty config file is valid - all paths default to sensible vault-relative locations. Enables quickstart: user can run `lithos index` with zero configuration if vault uses standard directory structure.
- **String paths:** Paths stored as strings, not file handles or custom Path types. Adapters resolve paths on demand using `filepath.Join` and `filepath.Abs`. This keeps config serializable and adapter-agnostic.
- **PropertyBankFile is filename only:** Not a full path. Always located in SchemasDir. SchemaLoader constructs full path: `filepath.Join(config.SchemasDir, config.PropertyBankFile)`.

[Source: docs/architecture/data-models.md#config]

### Testing Standards

From `docs/architecture/testing-strategy.md` and existing stories:

- Unit tests live beside code (`*_test.go`)
- Use table-driven tests for multiple cases
- Test constructors create valid instances
- Verify default values match specification
- Test immutability if applicable
- Ensure tests are deterministic and fast

### File Locations

- Model: `internal/domain/config.go`
- Tests: `internal/domain/config_test.go`

### Implementation Notes

**Constructor Pattern:**

```go
// NewConfig creates Config with all fields
func NewConfig(vaultPath, templatesDir, schemasDir, propertyBankFile, cacheDir, logLevel string) Config {
    return Config{
        VaultPath:        vaultPath,
        TemplatesDir:     templatesDir,
        SchemasDir:       schemasDir,
        PropertyBankFile: propertyBankFile,
        CacheDir:         cacheDir,
        LogLevel:         logLevel,
    }
}

// DefaultConfig returns Config with default values
func DefaultConfig() Config {
    return Config{
        VaultPath:        ".",
        TemplatesDir:     "templates/",
        SchemasDir:       "schemas/",
        PropertyBankFile: "property_bank.json",
        CacheDir:         ".lithos/cache/",
        LogLevel:         "info",
    }
}
```

**Value Object Characteristics:**
- Immutable (no setters, fields can be private with getters if desired)
- Equality based on field values
- No identity (two configs with same values are equivalent)

### Refactoring Guidelines

**SRP Decomposition Examples:**

For this story, the Config model is intentionally simple (value object pattern). SRP decomposition focuses on:

**Config Struct:**
- Single responsibility: Hold configuration data as immutable value object
- No behavior methods beyond construction
- Pure data structure

**NewConfig Constructor:**
- Single responsibility: Create Config with explicit field values
- No validation in Epic 1 (validation added in adapter layer)
- Direct field assignment

**DefaultConfig Constructor:**
- Single responsibility: Create Config with sensible defaults
- No conditional logic
- Returns pre-defined default values

**When to Decompose:**
- If validation logic added, extract to `validateConfig(cfg Config) error`
- If path resolution logic added, extract to helper functions
- If default calculation becomes complex, extract to individual default functions

**Naming Standards:**
- Exported type: PascalCase (Config)
- Constructors: NewTypeName, DefaultTypeName (NewConfig, DefaultConfig)
- Fields: PascalCase for exported (VaultPath, TemplatesDir, etc.)
- Keep field names descriptive and unambiguous

**Documentation Requirements:**
- Package comment at top of config.go explaining value object pattern
- Config struct GoDoc explaining immutability and use as value object
- Each field has GoDoc explaining purpose, default, and constraints
- Constructors have GoDoc explaining when to use each

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 1 requirements | Bob (Scrum Master) |
| 2025-10-28 | 1.1 | Enhanced with full TDD framework, SRP decomposition, linting checkpoints | QA Specialist |

## Dev Agent Record

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
