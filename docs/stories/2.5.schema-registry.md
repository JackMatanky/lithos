# Story 2.5: SchemaRegistryPort & Adapter

## Status

Draft

## Story

**As a** developer,
**I want** an in-memory schema registry adapter,
**so that** resolved schemas and properties are accessible to downstream services.

## Acceptance Criteria

**SchemaRegistryPort Interface:**

- 2.5.1: Create or extend `internal/ports/spi/schema.go` with SchemaRegistryPort interface per `docs/architecture/components.md#schemaregistryport`:
  - `GetSchema(ctx context.Context, name string) (Schema, error)` - Retrieve schema by name
  - `GetProperty(ctx context.Context, name string) (Property, error)` - Retrieve property from bank by name
  - `HasSchema(ctx context.Context, name string) bool` - Check if schema exists
  - `HasProperty(ctx context.Context, name string) bool` - Check if property exists in bank
  - `RegisterAll(ctx context.Context, schemas []Schema, bank PropertyBank) error` - Register resolved schemas and property bank

- 2.5.2: Add comprehensive GoDoc referencing architecture section and FR5/FR7 from `docs/prd/requirements.md`

- 2.5.3: Document that GetSchema/GetProperty return SchemaError with ErrNotFound classification when lookups fail

**SchemaRegistryAdapter Structure:**

- 2.5.4: Create `internal/adapters/spi/schema/registry.go` with SchemaRegistryAdapter implementing SchemaRegistryPort

- 2.5.5: SchemaRegistryAdapter depends only on Logger (constructor injection)

- 2.5.6: Internal storage uses two maps:
  - `schemas map[string]Schema` - Schema registry keyed by name
  - `properties map[string]Property` - Property bank keyed by property ID

**Thread Safety:**

- 2.5.7: Use `sync.RWMutex` for concurrent read access

- 2.5.8: RegisterAll() acquires write lock, read methods acquire read locks

- 2.5.9: Thread safety unit tests verify concurrent reads are safe

**Defensive Copying:**

- 2.5.10: RegisterAll() stores defensive copies of schemas and properties (not original references)

- 2.5.11: GetSchema() and GetProperty() return defensive copies (not internal references)

- 2.5.12: Unit tests verify returned schemas/properties cannot mutate internal state

**Idempotent Registration:**

- 2.5.13: RegisterAll() clears existing entries before registration (idempotent behavior)

- 2.5.14: Enables re-registration without stale data (aligns with FR9)

- 2.5.15: Log registration at info level: "registered N schemas and M properties"

**Lookup Behavior:**

- 2.5.16: GetSchema() returns SchemaError with ErrNotFound when schema doesn't exist

- 2.5.17: GetProperty() returns SchemaError with ErrNotFound when property doesn't exist

- 2.5.18: HasSchema() and HasProperty() never error, return bool only

**Error Handling:**

- 2.5.19: Use SchemaError types per `docs/architecture/error-handling-strategy.md`

- 2.5.20: Include contextual information (schema/property name) in error messages

**Unit Tests:**

- 2.5.21: Create `internal/adapters/spi/schema/registry_test.go` with tests covering:
  - RegisterAll() success with multiple schemas and properties
  - RegisterAll() idempotency (clear before register)
  - GetSchema() success path
  - GetSchema() not found error
  - GetProperty() success path
  - GetProperty() not found error
  - HasSchema() returns true when exists, false when not
  - HasProperty() returns true when exists, false when not
  - Concurrent read access is safe (multiple goroutines calling Get methods)
  - Defensive copying: returned schemas cannot mutate internal state

- 2.5.22: Run `golangci-lint run ./internal/ports/spi ./internal/adapters/spi/schema` and verify zero errors

- 2.5.23: Run `go test ./internal/adapters/spi/schema -v` and verify all tests pass

- 2.5.24: Run race detector: `go test ./internal/adapters/spi/schema -race` and verify no race conditions

**Documentation:**

- 2.5.25: Committed with message: `feat(schema): add SchemaRegistryPort and thread-safe in-memory adapter`

## Tasks / Subtasks

- [ ] Task 1: Create SchemaRegistryPort interface (AC: 2.5.1-2.5.3)
  - [ ] Extend `internal/ports/spi/schema.go`
  - [ ] Define SchemaRegistryPort interface with five methods
  - [ ] Add comprehensive GoDoc with architecture references
  - [ ] Document error behavior (ErrNotFound)

- [ ] Task 2: Create SchemaRegistryAdapter structure (AC: 2.5.4-2.5.6)
  - [ ] Create `registry.go` in schema adapter package
  - [ ] Define SchemaRegistryAdapter struct with maps and mutex
  - [ ] Add Logger dependency
  - [ ] Implement NewSchemaRegistryAdapter() constructor

- [ ] Task 3: Implement thread safety (AC: 2.5.7-2.5.9)
  - [ ] Add sync.RWMutex field to adapter
  - [ ] RegisterAll() uses write lock
  - [ ] Read methods (Get/Has) use read locks
  - [ ] Plan concurrent read tests

- [ ] Task 4: Implement defensive copying (AC: 2.5.10-2.5.12)
  - [ ] RegisterAll() deep copies schemas and properties
  - [ ] GetSchema() returns copy, not reference
  - [ ] GetProperty() returns copy, not reference
  - [ ] Plan mutation tests

- [ ] Task 5: Implement idempotent registration (AC: 2.5.13-2.5.15)
  - [ ] RegisterAll() clears maps before registering
  - [ ] Add info-level logging
  - [ ] Document idempotency behavior

- [ ] Task 6: Implement lookup methods (AC: 2.5.16-2.5.18)
  - [ ] Implement GetSchema() with ErrNotFound on miss
  - [ ] Implement GetProperty() with ErrNotFound on miss
  - [ ] Implement HasSchema() returning bool
  - [ ] Implement HasProperty() returning bool

- [ ] Task 7: Implement error handling (AC: 2.5.19-2.5.20)
  - [ ] Use SchemaError types
  - [ ] Include schema/property name in errors
  - [ ] Add contextual error messages

- [ ] Task 8: Write unit tests (AC: 2.5.21)
  - [ ] Create registry_test.go
  - [ ] Test RegisterAll() success
  - [ ] Test idempotency (register twice)
  - [ ] Test Get methods (success and not found)
  - [ ] Test Has methods (true and false)
  - [ ] Test concurrent reads (multiple goroutines)
  - [ ] Test defensive copying (mutations don't affect internal state)

- [ ] Task 9: Run linting and tests (AC: 2.5.22-2.5.24)
  - [ ] Run `golangci-lint run --fix` and fix any issues
  - [ ] Run tests and verify all pass
  - [ ] Run race detector and verify no races
  - [ ] Verify test coverage is comprehensive

- [ ] Task 10: Commit changes (AC: 2.5.25)
  - [ ] Review all code and documentation
  - [ ] Commit with full and proper conventional commit style message

## Dev Notes

### Architecture References

From `docs/architecture/components.md#schemaregistryport`:

**SchemaRegistryPort Responsibility:**

- Provide fast in-memory access to loaded and resolved schemas and properties
- Acts as registry for schema lookups by FrontmatterService and QueryService
- Populated by SchemaEngine at startup from SchemaPort.Load() results
- Thread-safe for concurrent reads

**SchemaEngine Integration:**
SchemaEngine wraps this port with generic API:

- `Get[T Schema | Property](name)` - Type-safe generic access
- `Has[T Schema | Property](name)` - Type-safe existence check
- Engine translates generic calls to specific port methods (GetSchema/GetProperty)

**Defensive Copying Rationale:**

- Prevents external code from mutating internal registry state
- Schemas and Properties are value types (can be safely copied)
- Small overhead acceptable for safety guarantees

### Implementation Guidance

**Adapter Structure:**

```go
type SchemaRegistryAdapter struct {
    schemas    map[string]Schema
    properties map[string]Property
    mu         sync.RWMutex
    log        Logger
}

func NewSchemaRegistryAdapter(log Logger) *SchemaRegistryAdapter {
    return &SchemaRegistryAdapter{
        schemas:    make(map[string]Schema),
        properties: make(map[string]Property),
        log:        log,
    }
}
```

**RegisterAll Implementation:**

```go
func (a *SchemaRegistryAdapter) RegisterAll(
    ctx context.Context,
    schemas []Schema,
    bank PropertyBank,
) error {
    a.mu.Lock()
    defer a.mu.Unlock()

    // Clear existing (idempotent)
    a.schemas = make(map[string]Schema)
    a.properties = make(map[string]Property)

    // Register schemas (defensive copy)
    for _, schema := range schemas {
        a.schemas[schema.Name] = schema // Go copies by value
    }

    // Register properties (defensive copy)
    for id, prop := range bank.Properties {
        a.properties[id] = prop // Go copies by value
    }

    a.log.Info().
        Int("schemas", len(schemas)).
        Int("properties", len(bank.Properties)).
        Msg("registered schemas and properties")

    return nil
}
```

**GetSchema Implementation:**

```go
func (a *SchemaRegistryAdapter) GetSchema(
    ctx context.Context,
    name string,
) (Schema, error) {
    a.mu.RLock()
    defer a.mu.RUnlock()

    schema, exists := a.schemas[name]
    if !exists {
        return Schema{}, &SchemaNotFoundError{
            SchemaName: name,
        }
    }

    return schema, nil // Returns copy (Go value semantics)
}
```

**HasSchema Implementation:**

```go
func (a *SchemaRegistryAdapter) HasSchema(
    ctx context.Context,
    name string,
) bool {
    a.mu.RLock()
    defer a.mu.RUnlock()

    _, exists := a.schemas[name]
    return exists
}
```

### Testing Strategy

From `docs/architecture/testing-strategy.md`:

**Thread Safety Testing:**

```go
func TestSchemaRegistryAdapter_ConcurrentReads(t *testing.T) {
    registry := NewSchemaRegistryAdapter(logger.NewTest())

    // Register test data
    schemas := []Schema{{Name: "test"}}
    bank := PropertyBank{Properties: map[string]Property{"test": {}}}
    registry.RegisterAll(context.Background(), schemas, bank)

    // Concurrent reads
    var wg sync.WaitGroup
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            schema, err := registry.GetSchema(context.Background(), "test")
            require.NoError(t, err)
            assert.Equal(t, "test", schema.Name)
        }()
    }
    wg.Wait()
}
```

**Defensive Copying Test:**

```go
func TestSchemaRegistryAdapter_DefensiveCopying(t *testing.T) {
    registry := NewSchemaRegistryAdapter(logger.NewTest())

    // Register schema
    original := Schema{Name: "test", Properties: []Property{{Name: "field"}}}
    registry.RegisterAll(context.Background(), []Schema{original}, PropertyBank{})

    // Get schema and mutate
    retrieved, _ := registry.GetSchema(context.Background(), "test")
    retrieved.Name = "mutated"

    // Verify internal state unchanged
    internal, _ := registry.GetSchema(context.Background(), "test")
    assert.Equal(t, "test", internal.Name) // Not "mutated"
}
```

**Idempotency Test:**

```go
func TestSchemaRegistryAdapter_Idempotency(t *testing.T) {
    registry := NewSchemaRegistryAdapter(logger.NewTest())

    // First registration
    schemas1 := []Schema{{Name: "schema1"}}
    registry.RegisterAll(context.Background(), schemas1, PropertyBank{})

    assert.True(t, registry.HasSchema(context.Background(), "schema1"))

    // Second registration with different data
    schemas2 := []Schema{{Name: "schema2"}}
    registry.RegisterAll(context.Background(), schemas2, PropertyBank{})

    // Only schema2 should exist (schema1 cleared)
    assert.False(t, registry.HasSchema(context.Background(), "schema1"))
    assert.True(t, registry.HasSchema(context.Background(), "schema2"))
}
```

### Refactoring Guidelines

**SRP Decomposition Examples:**

For this story, SchemaRegistryAdapter provides thread-safe registry. SRP decomposition focuses on:

**SchemaRegistryAdapter:**

- RegisterAll() method: Single responsibility = register all schemas and properties
  - If >20 lines, extract clearRegistry() and populateRegistry() helpers
- GetSchema() method: Single responsibility = retrieve schema with defensive copy
- GetProperty() method: Single responsibility = retrieve property with defensive copy
- HasSchema() method: Single responsibility = check schema existence
- HasProperty() method: Single responsibility = check property existence

**When to Decompose:**

- If any method exceeds 15 lines, consider extraction
- If constructor has >2 initialization concerns, extract helpers
- If validation logic mixes with business logic, extract validators

**Naming Standards:**

- Exported types: PascalCase
- Constructors: NewTypeName
- Private helpers: camelCase, specific action verbs
- Methods: PascalCase for exported, match Go conventions
- Boolean helpers (if added): is, has, can prefix

**Documentation Requirements:**

- Package comment at top of file explaining domain models/services
- All exported types have GoDoc comments
- Constructors have GoDoc explaining parameters and return values
- Methods have GoDoc explaining behavior
- Complex logic has inline comments for clarity

### Related Components

From `docs/architecture/components.md`:

**SchemaEngine (Story 2.8):**

- Wraps SchemaRegistryPort with generic API
- Translates `Get[Schema](name)` → `GetSchema(name)`
- Translates `Get[Property](name)` → `GetProperty(name)`
- Provides type-safe access for domain services

**FrontmatterService (Epic 3):**

- Calls SchemaEngine.Get[Schema](fileClass) to get schema for validation
- Relies on registry for fast schema lookups during validation

**Consumers:**

- FrontmatterService - Schema lookups for validation
- QueryService - Schema-aware queries (post-MVP)
- TemplateEngine - Schema lookups for suggestions (post-MVP)

## Change Log

| Date       | Version | Description                                                              | Author             |
| ---------- | ------- | ------------------------------------------------------------------------ | ------------------ |
| 2025-10-28 | 1.0     | Story created from Epic 2 requirements                                   | Bob (Scrum Master) |
| 2025-10-28 | 1.1     | Enhanced with full TDD framework, SRP decomposition, linting checkpoints | QA Specialist      |
| 2025-10-28 | 1.0     | Story created from Epic 2 requirements                                   | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## Testing

**Test Design:** `docs/qa/assessments/2.5-test-design-20251029.md`

## QA Results

_To be completed by QA agent after implementation_
