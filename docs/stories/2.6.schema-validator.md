# Story 2.6: SchemaValidator Service

## Status

Draft

## Story

**As a** developer,
**I want** SchemaValidator to orchestrate model and cross-schema validation,
**so that** invalid schemas are rejected before runtime proceeds.

## Acceptance Criteria

**SchemaValidator Service Structure:**

- 2.6.1: Create `internal/app/schema/validator.go` with SchemaValidator service per `docs/architecture/components.md#schemavalidator`

- 2.6.2: SchemaValidator has no dependencies (pure domain logic)

- 2.6.3: SchemaValidator is instantiated internally by SchemaEngine (not injected in main.go)

**ValidateAll Method:**

- 2.6.4: Implement `ValidateAll(ctx context.Context, schemas []Schema, bank PropertyBank) error` that:
  - Orchestrates model-level validation by calling schema.Validate() on each schema
  - Performs cross-schema validation (Extends references, duplicate names, $ref validity)
  - Aggregates all errors using errors.Join()
  - Returns nil if all validation passes

**Model-Level Validation Orchestration:**

- 2.6.5: For each schema, call schema.Validate(ctx) which:
  - Checks schema structure (Name not empty, Properties valid)
  - Delegates to property.Validate() for each property
  - Delegates to propertySpec.Validate() for each property spec

- 2.6.6: Collect all validation errors from model validation

- 2.6.7: Wrap each error with schema name for context: `fmt.Errorf("schema %s: %w", schema.Name, err)`

**Cross-Schema Validation:**

- 2.6.8: Build schema map for reference checking: `map[string]Schema`

- 2.6.9: For each schema with Extends set, verify parent schema exists in map

- 2.6.10: Check for duplicate schema names across all loaded schemas

- 2.6.11: For each property with $ref, verify target exists in PropertyBank

- 2.6.12: Collect all cross-schema validation errors

_Note: SchemaValidator only checks that `$ref` targets exist; SchemaResolver (Story 2.7) performs the actual substitution and inheritance resolution._

**Error Aggregation:**

- 2.6.13: Use `errors.Join()` to aggregate all validation errors (model + cross-schema)

- 2.6.14: Return aggregated error if any validation failed, nil if all passed

- 2.6.15: Error messages include schema/property names and remediation hints per FR5/FR7

**Logging:**

- 2.6.16: SchemaValidator does not log (no logger dependency)

- 2.6.17: SchemaEngine (caller) logs validation results

**GoDoc and Architecture References:**

- 2.6.18: Add comprehensive GoDoc referencing `docs/architecture/components.md#schemavalidator`

- 2.6.19: Document that SchemaValidator orchestrates validation, models self-validate

- 2.6.20: Document distinction between structural validation (SchemaValidator) and inheritance resolution (SchemaResolver)

**Unit Tests:**

- 2.6.21: Create `internal/app/schema/validator_test.go` with tests covering:
  - ValidateAll() success with valid schemas and property bank
  - Model validation error: schema with empty Name
  - Model validation error: property with invalid PropertySpec
  - Cross-schema error: Extends references non-existent schema
  - Cross-schema error: duplicate schema names
  - Cross-schema error: $ref references non-existent property
  - Aggregated errors: multiple validation failures reported together

- 2.6.22: Run `golangci-lint run ./internal/app/schema` and verify zero errors

- 2.6.23: Run `go test ./internal/app/schema -v` and verify all tests pass

**Documentation:**

- 2.6.24: Committed with message: `feat(schema): add SchemaValidator service with model and cross-schema validation`

## Tasks / Subtasks

- [ ] Task 1: Create SchemaValidator structure (AC: 2.6.1-2.6.3)
  - [ ] Create `internal/app/schema/` directory
  - [ ] Create `validator.go` with SchemaValidator struct
  - [ ] Implement NewSchemaValidator() constructor (no dependencies)
  - [ ] Add comprehensive GoDoc

- [ ] Task 2: Implement ValidateAll method (AC: 2.6.4)
  - [ ] Define ValidateAll() signature
  - [ ] Implement orchestration logic
  - [ ] Call model validation
  - [ ] Call cross-schema validation
  - [ ] Aggregate and return errors

- [ ] Task 3: Implement model-level validation (AC: 2.6.5-2.6.7)
  - [ ] Loop through schemas
  - [ ] Call schema.Validate(ctx) for each
  - [ ] Collect validation errors
  - [ ] Wrap errors with schema name context

- [ ] Task 4: Implement cross-schema validation (AC: 2.6.8-2.6.12)
  - [ ] Build schema map for lookups
  - [ ] Validate Extends references
  - [ ] Check for duplicate names
  - [ ] Validate $ref references against PropertyBank
  - [ ] Collect cross-schema errors

- [ ] Task 5: Implement error aggregation (AC: 2.6.13-2.6.15)
  - [ ] Use errors.Join() to combine errors
  - [ ] Return aggregated error or nil
  - [ ] Ensure error messages include context

- [ ] Task 6: Verify no logging (AC: 2.6.16-2.6.17)
  - [ ] Confirm no logger dependency
  - [ ] Document that caller (SchemaEngine) handles logging

- [ ] Task 7: Add comprehensive documentation (AC: 2.6.18-2.6.20)
  - [ ] Add GoDoc to SchemaValidator
  - [ ] Document orchestration pattern
  - [ ] Document distinction from SchemaResolver
  - [ ] Reference architecture docs

- [ ] Task 8: Write unit tests (AC: 2.6.21)
  - [ ] Create validator_test.go
  - [ ] Test successful validation
  - [ ] Test model validation errors (empty name, invalid spec)
  - [ ] Test cross-schema errors (missing Extends, duplicates, invalid $ref)
  - [ ] Test error aggregation (multiple failures)

- [ ] Task 9: Run linting and tests (AC: 2.6.22-2.6.23)
  - [ ] Run golangci-lint and fix any issues
  - [ ] Run tests and verify all pass
  - [ ] Verify test coverage is comprehensive

- [ ] Task 10: Commit changes (AC: 2.6.24)
  - [ ] Review all code and documentation
  - [ ] Commit with full and proper conventional commit style message

## Dev Notes

### Architecture References

From `docs/architecture/components.md#schemavalidator`:

**Two Validation Responsibilities:**

1. **Orchestrate Model Validation:**
   - Calls schema.Validate() on each schema
   - Each schema delegates to property.Validate() â†’ propertySpec.Validate()
   - Aggregates all structural validation errors
   - **Why service needed:** Centralized orchestration and error aggregation across all schemas

2. **Cross-Schema Validation:**
   - Validates Extends references point to existing schemas
   - Validates PropertyBank $ref references exist
   - Ensures no duplicate schema names
   - **Why service needed:** Individual schemas can't validate references without seeing other schemas and PropertyBank

**What SchemaValidator Does NOT Do:**

- Structural validation of individual schemas (delegated to schema.Validate())
- Inheritance resolution (handled by SchemaResolver)
- Circular dependency detection (handled by SchemaResolver during topological sort)

### Implementation Guidance

**ValidateAll Implementation:**

```go
func (v *SchemaValidator) ValidateAll(
    ctx context.Context,
    schemas []Schema,
    bank PropertyBank,
) error {
    var errs []error

    // 1. Orchestrate model-level validation
    for _, schema := range schemas {
        if err := schema.Validate(ctx); err != nil {
            errs = append(errs, fmt.Errorf("schema %s: %w", schema.Name, err))
        }
    }

    // 2. Cross-schema validation
    schemaMap := buildSchemaMap(schemas)

    // Check Extends references
    for _, schema := range schemas {
        if schema.Extends != "" {
            if _, exists := schemaMap[schema.Extends]; !exists {
                errs = append(errs, fmt.Errorf(
                    "schema %s extends non-existent schema %s",
                    schema.Name, schema.Extends,
                ))
            }
        }
    }

    // Check duplicate names
    if dups := findDuplicateNames(schemas); len(dups) > 0 {
        errs = append(errs, fmt.Errorf(
            "duplicate schema names: %v", dups,
        ))
    }

    // Check $ref references
    for _, schema := range schemas {
        for _, prop := range schema.Properties {
            if err := v.validatePropertyRefs(prop, bank); err != nil {
                errs = append(errs, fmt.Errorf(
                    "schema %s, property %s: %w",
                    schema.Name, prop.Name, err,
                ))
            }
        }
    }

    if len(errs) > 0 {
        return errors.Join(errs...)
    }

    return nil
}
```

**Helper Functions:**

```go
func buildSchemaMap(schemas []Schema) map[string]Schema {
    m := make(map[string]Schema, len(schemas))
    for _, schema := range schemas {
        m[schema.Name] = schema
    }
    return m
}

func findDuplicateNames(schemas []Schema) []string {
    seen := make(map[string]bool)
    var dups []string

    for _, schema := range schemas {
        if seen[schema.Name] {
            dups = append(dups, schema.Name)
        }
        seen[schema.Name] = true
    }

    return dups
}

func (v *SchemaValidator) validatePropertyRefs(
    prop Property,
    bank PropertyBank,
) error {
    // Check if property uses $ref
    // If so, verify target exists in bank
    // Implementation depends on how $ref is represented in Property
    // May need helper field or special handling
    return nil
}
```

### Testing Strategy

From `docs/architecture/testing-strategy.md`:

**Unit Test Coverage:**

- Successful validation (all schemas valid, all references exist)
- Model validation errors (invalid schema structure)
- Cross-schema errors (missing references, duplicates)
- Error aggregation (multiple failures reported together)

**Test Data Patterns:**

```go
// Valid schema for success tests
validSchema := Schema{
    Name: "test-schema",
    Properties: []Property{
        {Name: "field1", Required: true, Spec: StringSpec{}},
    },
}

// Invalid schema for error tests
invalidSchema := Schema{
    Name: "", // Empty name - validation error
    Properties: []Property{
        {Name: "field1", Required: true, Spec: nil}, // Nil spec - error
    },
}

// Schema with invalid Extends reference
orphanSchema := Schema{
    Name:    "orphan",
    Extends: "non-existent-parent", // Cross-schema error
    Properties: []Property{},
}
```

**Error Aggregation Test:**

```go
func TestSchemaValidator_ValidateAll_MultipleErrors(t *testing.T) {
    validator := NewSchemaValidator()

    schemas := []Schema{
        {Name: "", Properties: []Property{}},           // Model error: empty name
        {Name: "orphan", Extends: "missing"},           // Cross-schema error
        {Name: "duplicate"},                            // Duplicate name
        {Name: "duplicate"},                            // Duplicate name
    }

    err := validator.ValidateAll(context.Background(), schemas, PropertyBank{})

    require.Error(t, err)

    // Verify all errors are included in aggregated error
    errStr := err.Error()
    assert.Contains(t, errStr, "empty")
    assert.Contains(t, errStr, "non-existent")
    assert.Contains(t, errStr, "duplicate")
}
```

### Refactoring Guidelines

**SRP Decomposition Examples:**

For this story, SchemaValidator orchestrates validation. SRP decomposition focuses on:

**SchemaValidator:**

- ValidateAll() method: Single responsibility = orchestrate all validation
  - Extract validateModels() for model-level validation (>15 lines)
  - Extract validateCrossSchema() for cross-schema validation (>15 lines)
  - Extract validateExtends() for parent reference checking
  - Extract validateDuplicates() for duplicate name checking
  - Extract validateRefs() for $ref validation
- buildSchemaMap() helper: Single responsibility = create lookup map
- findDuplicateNames() helper: Single responsibility = detect duplicates

**When to Decompose:**

- If any method exceeds 15 lines, consider extraction
- If constructor has >2 initialization concerns, extract helpers
- If validation logic mixes with business logic, extract validators

**Naming Standards:**

- Exported types: PascalCase
- Constructors: NewTypeName
- Private helpers: camelCase, specific action verbs
- Methods: PascalCase for exported, match Go conventions
- Boolean helpers (if added): is, has, can prefix

**Documentation Requirements:**

- Package comment at top of file explaining domain models/services
- All exported types have GoDoc comments
- Constructors have GoDoc explaining parameters and return values
- Methods have GoDoc explaining behavior
- Complex logic has inline comments for clarity

### Related Components

From `docs/architecture/components.md`:

**SchemaEngine (Story 2.8):**

- Instantiates SchemaValidator internally
- Calls ValidateAll() after SchemaPort.Load()
- Logs validation results
- Fails application startup if validation fails

**SchemaResolver (Story 2.7):**

- Runs AFTER SchemaValidator succeeds
- Assumes all schemas are structurally valid
- Focuses on inheritance resolution, not validation

**Schema Models (Story 2.2):**

- Schema.Validate() checks own structure
- Property.Validate() checks property structure
- PropertySpec.Validate() checks constraint validity
- SchemaValidator orchestrates these calls

## Change Log

| Date       | Version | Description                                                              | Author             |
| ---------- | ------- | ------------------------------------------------------------------------ | ------------------ |
| 2025-10-28 | 1.0     | Story created from Epic 2 requirements                                   | Bob (Scrum Master) |
| 2025-10-28 | 1.1     | Enhanced with full TDD framework, SRP decomposition, linting checkpoints | QA Specialist      |
| 2025-10-28 | 1.0     | Story created from Epic 2 requirements                                   | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## Testing

**Test Design:** `docs/qa/assessments/2.6-test-design-20251029.md`

## QA Results

_To be completed by QA agent after implementation_
