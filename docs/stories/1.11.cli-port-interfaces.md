# Story 1.11: Implement CLI Port Interfaces

## Status

Draft

## Story

**As a** developer,
**I want** to define CLIPort and CommandPort API interfaces,
**so that** CLI framework integration follows hexagonal callback pattern.

## Acceptance Criteria

- 1.11.1: Create `internal/ports/api/cli.go`:
  - Interface: `CLIPort`
  - Method: `Start(ctx context.Context, handler CommandPort) error`
  - Add documentation comments:
    - Describe hexagonal callback pattern (CLI adapter receives handler, calls handler methods)
    - Document Start() method contract
    - Reference architecture components.md

- 1.11.2: Create `internal/ports/api/command.go`:
  - Interface: `CommandPort`
  - Method: `NewNote(ctx context.Context, templateID TemplateID) (Note, error)`
  - Add documentation comments:
    - Note: Additional methods will be added in later epics
    - Describe use case handler contract
    - Document NewNote() method as orchestrating template rendering and note creation
    - Reference architecture components.md

- 1.11.3: All linting passes: `golangci-lint run --fix internal/ports/api`

- 1.11.4: Committed with message: `feat(ports): define CLI port interfaces`

## Tasks / Subtasks

- [ ] Task 1: Define CLIPort interface (AC: 1.11.1)
  - [ ] Create `internal/ports/api/cli.go`
  - [ ] Define CLIPort interface with Start method
  - [ ] Add comprehensive documentation explaining:
    - Hexagonal callback pattern
    - CLI adapter responsibilities
    - Start() method contract (set up commands, parse input, delegate to handler)
    - How CommandOrchestrator controls flow by passing itself as handler
  - [ ] Reference architecture components.md
  - [ ] Verify interface compiles

- [ ] Task 2: Define CommandPort interface (AC: 1.11.2)
  - [ ] Create `internal/ports/api/command.go`
  - [ ] Define CommandPort interface with NewNote method
  - [ ] Add comprehensive documentation explaining:
    - Use case handler contract
    - NewNote() method orchestrates template rendering and note creation
    - Additional methods (IndexVault, FindTemplates) to be added in later stories
  - [ ] Reference architecture components.md
  - [ ] Verify interface compiles

- [ ] Task 3: Run quality gates (AC: 1.11.3)
  - [ ] Run `golangci-lint run --fix internal/ports/api` and fix issues
  - [ ] Verify documentation is clear and comprehensive
  - [ ] Verify interface signatures are correct

- [ ] Task 4: Commit changes (AC: 1.11.4)
  - [ ] Review all changes
  - [ ] Stage files: `git add internal/ports/api/cli.go internal/ports/api/command.go`
  - [ ] Commit with message: `feat(ports): define CLI port interfaces`

## Dev Notes

### Architecture Alignment (v0.6.8)

This story defines the API port interfaces that establish the hexagonal callback pattern between CLI adapter and CommandOrchestrator, enabling clean separation of CLI framework concerns from domain logic.

### CLIPort Interface

From `docs/architecture/components.md#api-port-interfaces` - CLIPort (v0.6.4):

**Responsibility:** Define the contract for CLI framework integration. Implemented by CLI adapter to handle command parsing, flag processing, and output formatting. Domain injects this port into CommandOrchestrator to decouple from specific CLI frameworks.

**Key Interfaces:**
- `Start(ctx context.Context, handler CommandPort) error` - Start the CLI event loop, parse commands, and delegate to handler for business logic

**CommandPort Interface:**

The CLI adapter calls back to CommandOrchestrator through this interface:

```go
type CommandPort interface {
    NewNote(ctx context.Context, templateID TemplateID) (Note, error)
    // Additional methods to be added in later epics:
    // IndexVault(ctx context.Context) (IndexStats, error)
    // FindTemplates(ctx context.Context, query string) ([]Template, error)
}
```

**Architecture Pattern:**

```
CommandOrchestrator (Domain)
  └─> Calls CLIPort.Start(itself as CommandPort)
      └─> CobraCLIAdapter receives control
          └─> Sets up Cobra commands
          └─> Parses user input
          └─> Calls back to CommandPort.NewNote/IndexVault/FindTemplates
              └─> CommandOrchestrator orchestrates domain services
              └─> Returns result to CLI adapter
          └─> Formats and displays output
```

**Why This Design:**

- **Decouples CLI framework from domain:** CommandOrchestrator never imports Cobra
- **Enables multiple adapters:** TUI/LSP can implement CLIPort without affecting domain
- **Testable:** Mock CLIPort to test CommandOrchestrator without CLI framework
- **Inversion of Control:** Domain starts the application and delegates command parsing to adapter

**Dependencies:** Implemented by CobraCLIAdapter. Injected into CommandOrchestrator via constructor.

**Technology Stack:** Defined in `internal/ports/api/` as pure Go interfaces. No framework dependencies.

### Implementation Template

**CLIPort Interface:**

```go
package api

import "context"

// CLIPort defines the contract for CLI framework integration following hexagonal
// callback pattern. The CLI adapter implements this interface to handle command
// parsing, flag processing, and output formatting while delegating business logic
// to the CommandPort handler.
//
// Architecture Pattern:
// 1. CommandOrchestrator calls CLIPort.Start(itself as CommandPort)
// 2. CLI adapter sets up command tree (e.g., Cobra commands)
// 3. CLI adapter parses user input and flags
// 4. CLI adapter calls back to CommandPort methods for business logic
// 5. CommandOrchestrator orchestrates domain services
// 6. CLI adapter formats and displays results
//
// This pattern decouples CLI framework details from domain logic, enabling:
// - Multiple adapters (CLI, TUI, LSP) without domain changes
// - Testability via mock CLIPort
// - Clean separation of concerns
//
// Reference: docs/architecture/components.md#api-port-interfaces - CLIPort (v0.6.4)
type CLIPort interface {
    // Start initializes the CLI adapter, sets up command tree, parses user input,
    // and delegates business logic to the provided handler. The handler is typically
    // the CommandOrchestrator implementing CommandPort.
    //
    // The adapter should:
    // - Build command tree (e.g., Cobra root, subcommands)
    // - Register flags and arguments
    // - Parse user input
    // - Call appropriate handler methods based on command
    // - Format and display results
    // - Handle graceful shutdown on context cancellation
    //
    // Returns error if CLI setup fails or command execution fails.
    Start(ctx context.Context, handler CommandPort) error
}
```

**CommandPort Interface:**

```go
package api

import (
    "context"

    "github.com/JackMatanky/lithos/internal/domain"
)

// CommandPort defines the use case handler contract that CLI adapters call back
// to for business logic execution. Implemented by CommandOrchestrator to orchestrate
// domain services for each command.
//
// This interface follows hexagonal callback pattern where the CLI adapter receives
// the handler via CLIPort.Start() and calls handler methods based on parsed commands.
//
// Current methods (Epic 1):
// - NewNote: Create note from template
//
// Future methods (later epics):
// - IndexVault: Rebuild vault index and cache
// - FindTemplates: List and fuzzy-find templates
//
// Reference: docs/architecture/components.md#api-port-interfaces - CommandPort (v0.6.4)
type CommandPort interface {
    // NewNote orchestrates the complete note creation workflow:
    // 1. Load and render template via TemplateEngine
    // 2. Extract and validate frontmatter via FrontmatterService
    // 3. Generate NoteID from frontmatter fields
    // 4. Create Note domain object
    // 5. Persist to vault via VaultWriterPort
    // 6. Update cache via CacheWriterPort
    // 7. Return Note for CLI display
    //
    // Returns Note on success, error on failure (template not found, parse error,
    // validation error, write error, etc.).
    NewNote(ctx context.Context, templateID domain.TemplateID) (domain.Note, error)

    // Additional methods to be added in later stories:
    // - IndexVault(ctx context.Context) (IndexStats, error)
    // - FindTemplates(ctx context.Context, query string) ([]Template, error)
}
```

### Hexagonal Callback Pattern Explanation

From `docs/architecture/components.md#api-port-interfaces`:

**Traditional Approach (Domain depends on CLI):**
```
CLI Framework
  └─> Domain Logic (WRONG - domain depends on CLI library)
```

**Hexagonal Callback Pattern (CLI depends on Domain):**
```
Domain (CommandOrchestrator)
  └─> Defines CLIPort interface (what domain needs from CLI)
  └─> Calls CLIPort.Start(self as CommandPort)
      └─> CLI Adapter (CobraCLIAdapter)
          └─> Implements CLIPort interface
          └─> Receives CommandPort handler
          └─> Calls handler.NewNote() etc.
              └─> CommandOrchestrator orchestrates domain services
```

**Benefits:**
1. **Domain Independence:** CommandOrchestrator never imports Cobra or any CLI library
2. **Multiple Adapters:** Can implement TUI, LSP, or different CLI frameworks
3. **Testability:** Mock CLIPort to test CommandOrchestrator in isolation
4. **Separation of Concerns:** CLI handles parsing/formatting, domain handles business logic

### Testing Standards

From `docs/architecture/testing-strategy.md`:

**Interface Testing:**
- Interfaces themselves don't need unit tests (no implementation)
- Will be tested via implementation stories:
  - CLIPort tested via CobraCLIAdapter (Story 1.12)
  - CommandPort tested via CommandOrchestrator (Story 1.13)
- Documentation quality verified during review

**Quality Gates:**
- Interfaces compile without errors
- Documentation is comprehensive and clear
- No linting errors: `golangci-lint run --fix internal/ports/api`
- Architecture references are accurate

### File Locations

From `docs/architecture/source-tree.md`:

**Implementation:**
- `internal/ports/api/cli.go` - CLIPort interface definition
- `internal/ports/api/command.go` - CommandPort interface definition

**Future Implementations (later stories):**
- `internal/adapters/api/cli/cobra.go` - CobraCLIAdapter (Story 1.12)
- `internal/app/command/orchestrator.go` - CommandOrchestrator (Story 1.13)

### Common Pitfalls to Avoid

1. **DO document the hexagonal callback pattern** - Make it clear how control flows
2. **DO explain why CommandPort exists** - It's the callback interface for CLI adapter
3. **DO reference architecture docs** - Link to components.md for detailed explanation
4. **DO keep interfaces small** - Only NewNote() for Epic 1 (add more in later epics)
5. **DO NOT add implementation** - These are pure interface definitions
6. **DO NOT import CLI frameworks** - Keep interfaces framework-agnostic

### Architecture Decision Record

**ADR: Hexagonal Callback Pattern for CLI Integration**

**Context:** Traditional CLI implementations couple domain logic to CLI framework (e.g., Cobra RunE functions contain business logic). This makes testing difficult and prevents supporting multiple interfaces (TUI, LSP).

**Decision:** Implement hexagonal callback pattern where:
1. Domain defines CLIPort interface (what it needs from CLI)
2. Domain defines CommandPort interface (what CLI can call back to)
3. CLI adapter implements CLIPort and receives CommandPort handler
4. Domain controls application flow by calling CLIPort.Start()

**Consequences:**
- ✅ Domain remains framework-agnostic
- ✅ Easy to add TUI/LSP adapters without domain changes
- ✅ Testable with mock CLIPort
- ⚠️ Slightly more complex than traditional approach (worth the tradeoff)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 1 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
