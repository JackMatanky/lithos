# Story 1.11: Implement CLI Port Interfaces

## Status

Ready for Review

## Story

**As a** developer,
**I want** to define CLIPort and CommandPort API interfaces,
**so that** CLI framework integration follows hexagonal callback pattern.

## Acceptance Criteria

- 1.11.1: Create `internal/ports/api/cli.go`:
  - Interface: `CLIPort`
  - Method: `Start(ctx context.Context, handler CommandPort) error`
  - Add documentation comments:
    - Describe hexagonal callback pattern (CLI adapter receives handler, calls handler methods)
    - Document Start() method contract
    - Reference architecture components.md

- 1.11.2: Create `internal/ports/api/command.go`:
  - Interface: `CommandPort`
  - Method: `NewNote(ctx context.Context, templateID TemplateID) (Note, error)`
  - Add documentation comments:
    - Note: Additional methods will be added in later epics
    - Describe use case handler contract
    - Document NewNote() method as orchestrating template rendering and note creation
    - Reference architecture components.md

- 1.11.3: All linting passes: `golangci-lint run --fix internal/ports/api`

- 1.11.4: Committed with message: `feat(ports): define CLI port interfaces`

## Tasks / Subtasks

- [x] Task 1: Define CLIPort interface (AC: 1.11.1)
  - [x] Create `internal/ports/api/cli.go`
  - [x] Define CLIPort interface with Start method
  - [x] Add comprehensive documentation explaining:
    - Hexagonal callback pattern with detailed control flow diagram
    - CLI adapter responsibilities (command parsing, flag processing, output formatting)
    - Start() method contract (set up commands, parse input, delegate to handler)
    - How CommandOrchestrator controls flow by passing itself as handler
    - Why this pattern decouples domain from CLI framework
  - [x] Reference architecture components.md#api-port-interfaces
  - [x] Verify interface compiles
  - [x] Follow Port Interface Documentation Standards (see Dev Notes)
  - [x] Linting checkpoint:
    - [x] Run `golangci-lint run --fix internal/ports/api`
    - [x] Fix ALL warnings (no nolint unless absolutely necessary)
    - [x] Document any unavoidable nolint with clear justification

- [x] Task 2: Define CommandPort interface (AC: 1.11.2)
  - [x] Create `internal/ports/api/command.go`
  - [x] Define CommandPort interface with NewNote method
  - [x] Add comprehensive documentation explaining:
    - Use case handler contract with clear callback semantics
    - NewNote() method workflow (template → frontmatter → note → persist)
    - Additional methods (IndexVault, FindTemplates) to be added in later stories
    - How CLI adapter calls back to CommandPort methods
    - Separation of concerns (CLI handles UI, CommandPort handles business logic)
  - [x] Reference architecture components.md#api-port-interfaces
  - [x] Verify interface compiles
  - [x] Follow Port Interface Documentation Standards (see Dev Notes)
  - [x] Linting checkpoint:
    - [x] Run `golangci-lint run --fix internal/ports/api`
    - [x] Fix ALL warnings (no nolint unless absolutely necessary)
    - [x] Document any unavoidable nolint with clear justification

- [x] Task 3: Run quality gates (AC: 1.11.3)
  - [x] Run `golangci-lint run --fix internal/ports/api` and fix issues
  - [x] Verify documentation is clear and comprehensive
  - [x] Verify interface signatures are correct
  - [x] Verify no framework dependencies imported
  - [x] Verify interfaces compile without errors
  - [x] Linting checkpoint:
    - [x] Final sweep: `golangci-lint run --fix internal/ports/api`
    - [x] Verify ALL warnings resolved
    - [x] Verify zero linting warnings

- [x] Task 4: Commit changes (AC: 1.11.4)
  - [x] Review all changes for completeness
  - [x] Verify documentation quality and clarity
  - [x] Stage files:
    - [x] `git add internal/ports/api/cli.go`
    - [x] `git add internal/ports/api/command.go`
  - [x] Commit with message: `feat(ports): define CLI port interfaces`
  - [x] Verify commit includes all necessary files
  - [x] Linting checkpoint:
    - [x] Run pre-commit hooks if installed
    - [x] Verify commit message follows conventional commits format

## Dev Notes

### QA Test Design Reference

**Test Design Document:** `docs/qa/assessments/1.11-test-design-20251028.md`

This story incorporates all 6 test scenarios identified in the QA test design:

- 4 unit tests, 1 integration test, 1 e2e test covering CLIPort and CommandPort interfaces
- 5 P0 priority scenarios for critical CLI interface functionality, 1 P1 for standard features
- Test coverage ensures proper interface compilation and hexagonal callback pattern

**Note:** The detailed test scenarios in AC1.11.3-1.11.5 and Tasks 1-3 are derived from this QA analysis.

### Architecture Alignment (v0.6.8)

This story defines the API port interfaces that establish the hexagonal callback pattern between CLI adapter and CommandOrchestrator, enabling clean separation of CLI framework concerns from domain logic.

### CLIPort Interface

From `docs/architecture/components.md#api-port-interfaces` - CLIPort (v0.6.4):

**Responsibility:** Define the contract for CLI framework integration. Implemented by CLI adapter to handle command parsing, flag processing, and output formatting. Domain injects this port into CommandOrchestrator to decouple from specific CLI frameworks.

**Key Interfaces:**

- `Start(ctx context.Context, handler CommandPort) error` - Start the CLI event loop, parse commands, and delegate to handler for business logic

**CommandPort Interface:**

The CLI adapter calls back to CommandOrchestrator through this interface:

```go
type CommandPort interface {
    NewNote(ctx context.Context, templateID TemplateID) (Note, error)
    // Additional methods to be added in later epics:
    // IndexVault(ctx context.Context) (IndexStats, error)
    // FindTemplates(ctx context.Context, query string) ([]Template, error)
}
```

**Architecture Pattern:**

```
CommandOrchestrator (Domain)
  └─> Calls CLIPort.Start(itself as CommandPort)
      └─> CobraCLIAdapter receives control
          └─> Sets up Cobra commands
          └─> Parses user input
          └─> Calls back to CommandPort.NewNote/IndexVault/FindTemplates
              └─> CommandOrchestrator orchestrates domain services
              └─> Returns result to CLI adapter
          └─> Formats and displays output
```

**Why This Design:**

- **Decouples CLI framework from domain:** CommandOrchestrator never imports Cobra
- **Enables multiple adapters:** TUI/LSP can implement CLIPort without affecting domain
- **Testable:** Mock CLIPort to test CommandOrchestrator without CLI framework
- **Inversion of Control:** Domain starts the application and delegates command parsing to adapter

**Dependencies:** Implemented by CobraCLIAdapter. Injected into CommandOrchestrator via constructor.

**Technology Stack:** Defined in `internal/ports/api/` as pure Go interfaces. No framework dependencies.

### Implementation Template

**CLIPort Interface:**

```go
package api

import "context"

// CLIPort defines the contract for CLI framework integration following hexagonal
// callback pattern. The CLI adapter implements this interface to handle command
// parsing, flag processing, and output formatting while delegating business logic
// to the CommandPort handler.
//
// Architecture Pattern:
// 1. CommandOrchestrator calls CLIPort.Start(itself as CommandPort)
// 2. CLI adapter sets up command tree (e.g., Cobra commands)
// 3. CLI adapter parses user input and flags
// 4. CLI adapter calls back to CommandPort methods for business logic
// 5. CommandOrchestrator orchestrates domain services
// 6. CLI adapter formats and displays results
//
// This pattern decouples CLI framework details from domain logic, enabling:
// - Multiple adapters (CLI, TUI, LSP) without domain changes
// - Testability via mock CLIPort
// - Clean separation of concerns
//
// Reference: docs/architecture/components.md#api-port-interfaces - CLIPort (v0.6.4)
type CLIPort interface {
    // Start initializes the CLI adapter, sets up command tree, parses user input,
    // and delegates business logic to the provided handler. The handler is typically
    // the CommandOrchestrator implementing CommandPort.
    //
    // The adapter should:
    // - Build command tree (e.g., Cobra root, subcommands)
    // - Register flags and arguments
    // - Parse user input
    // - Call appropriate handler methods based on command
    // - Format and display results
    // - Handle graceful shutdown on context cancellation
    //
    // Returns error if CLI setup fails or command execution fails.
    Start(ctx context.Context, handler CommandPort) error
}
```

**CommandPort Interface:**

```go
package api

import (
    "context"

    "github.com/JackMatanky/lithos/internal/domain"
)

// CommandPort defines the use case handler contract that CLI adapters call back
// to for business logic execution. Implemented by CommandOrchestrator to orchestrate
// domain services for each command.
//
// This interface follows hexagonal callback pattern where the CLI adapter receives
// the handler via CLIPort.Start() and calls handler methods based on parsed commands.
//
// Current methods (Epic 1):
// - NewNote: Create note from template
//
// Future methods (later epics):
// - IndexVault: Rebuild vault index and cache
// - FindTemplates: List and fuzzy-find templates
//
// Reference: docs/architecture/components.md#api-port-interfaces - CommandPort (v0.6.4)
type CommandPort interface {
    // NewNote orchestrates the complete note creation workflow:
    // 1. Load and render template via TemplateEngine
    // 2. Extract and validate frontmatter via FrontmatterService
    // 3. Generate NoteID from frontmatter fields
    // 4. Create Note domain object
    // 5. Persist to vault via VaultWriterPort
    // 6. Update cache via CacheWriterPort
    // 7. Return Note for CLI display
    //
    // Returns Note on success, error on failure (template not found, parse error,
    // validation error, write error, etc.).
    NewNote(ctx context.Context, templateID domain.TemplateID) (domain.Note, error)

    // Additional methods to be added in later stories:
    // - IndexVault(ctx context.Context) (IndexStats, error)
    // - FindTemplates(ctx context.Context, query string) ([]Template, error)
}
```

### Hexagonal Callback Pattern Explanation

From `docs/architecture/components.md#api-port-interfaces`:

**Traditional Approach (Domain depends on CLI):**

```
CLI Framework
  └─> Domain Logic (WRONG - domain depends on CLI library)
```

**Hexagonal Callback Pattern (CLI depends on Domain):**

```
Domain (CommandOrchestrator)
  └─> Defines CLIPort interface (what domain needs from CLI)
  └─> Calls CLIPort.Start(self as CommandPort)
      └─> CLI Adapter (CobraCLIAdapter)
          └─> Implements CLIPort interface
          └─> Receives CommandPort handler
          └─> Calls handler.NewNote() etc.
              └─> CommandOrchestrator orchestrates domain services
```

**Benefits:**

1. **Domain Independence:** CommandOrchestrator never imports Cobra or any CLI library
2. **Multiple Adapters:** Can implement TUI, LSP, or different CLI frameworks
3. **Testability:** Mock CLIPort to test CommandOrchestrator in isolation
4. **Separation of Concerns:** CLI handles parsing/formatting, domain handles business logic

### Testing Standards

From `docs/architecture/testing-strategy.md`:

**Interface Testing:**

- Interfaces themselves don't need unit tests (no implementation)
- Will be tested via implementation stories:
  - CLIPort tested via CobraCLIAdapter (Story 1.12)
  - CommandPort tested via CommandOrchestrator (Story 1.13)
- Documentation quality verified during review

**Quality Gates:**

- Interfaces compile without errors
- Documentation is comprehensive and clear
- No linting errors: `golangci-lint run --fix internal/ports/api`
- Architecture references are accurate

### File Locations

From `docs/architecture/source-tree.md`:

**Implementation:**

- `internal/ports/api/cli.go` - CLIPort interface definition
- `internal/ports/api/command.go` - CommandPort interface definition

**Future Implementations (later stories):**

- `internal/adapters/api/cli/cobra.go` - CobraCLIAdapter (Story 1.12)
- `internal/app/command/orchestrator.go` - CommandOrchestrator (Story 1.13)

### Common Pitfalls to Avoid

1. **DO document the hexagonal callback pattern** - Make it clear how control flows
2. **DO explain why CommandPort exists** - It's the callback interface for CLI adapter
3. **DO reference architecture docs** - Link to components.md for detailed explanation
4. **DO keep interfaces small** - Only NewNote() for Epic 1 (add more in later epics)
5. **DO NOT add implementation** - These are pure interface definitions
6. **DO NOT import CLI frameworks** - Keep interfaces framework-agnostic

### Port Interface Documentation Standards

**Interface-Only Story Pattern:**

This story defines port interfaces WITHOUT implementation (no TDD cycle). Quality comes from documentation excellence and architectural clarity.

**Documentation Requirements for Port Interfaces:**

1. **Package-Level Comment:**
   - Explain purpose of port package (API vs SPI)
   - Describe hexagonal architecture role
   - Reference relevant architecture documentation

2. **Interface GoDoc:**
   - Clear, concise purpose statement
   - Architectural context (where it fits in hexagonal architecture)
   - Responsibility description (what it does, what it doesn't do)
   - Reference to architecture components.md section

3. **Method GoDoc:**
   - Complete method contract (inputs, outputs, errors)
   - Behavior specification (what the method must do)
   - Error conditions documented
   - Context usage explained
   - Examples where helpful

4. **Architecture Pattern Documentation:**
   - Explain hexagonal callback pattern with ASCII diagram
   - Show control flow between components
   - Explain why this pattern is used (benefits)
   - Document any non-obvious design decisions

**CLIPort Specific Standards:**

```go
// CLIPort defines the contract for CLI framework integration following hexagonal
// callback pattern. The CLI adapter implements this interface to handle command
// parsing, flag processing, and output formatting while delegating business logic
// to the CommandPort handler.
//
// Architecture Pattern:
// 1. CommandOrchestrator calls CLIPort.Start(itself as CommandPort)
// 2. CLI adapter sets up command tree (e.g., Cobra commands)
// 3. CLI adapter parses user input and flags
// 4. CLI adapter calls back to CommandPort methods for business logic
// 5. CommandOrchestrator orchestrates domain services
// 6. CLI adapter formats and displays results
//
// This pattern decouples CLI framework details from domain logic, enabling:
// - Multiple adapters (CLI, TUI, LSP) without domain changes
// - Testability via mock CLIPort
// - Clean separation of concerns
//
// Reference: docs/architecture/components.md#api-port-interfaces - CLIPort (v0.6.4)
type CLIPort interface {
    // Start initializes the CLI adapter, sets up command tree, parses user input,
    // and delegates business logic to the provided handler.
    //
    // [Complete method documentation here...]
    Start(ctx context.Context, handler CommandPort) error
}
```

**CommandPort Specific Standards:**

```go
// CommandPort defines the use case handler contract that CLI adapters call back
// to for business logic execution. Implemented by CommandOrchestrator to orchestrate
// domain services for each command.
//
// This interface follows hexagonal callback pattern where the CLI adapter receives
// the handler via CLIPort.Start() and calls handler methods based on parsed commands.
//
// [Additional documentation here...]
//
// Reference: docs/architecture/components.md#api-port-interfaces - CommandPort (v0.6.4)
type CommandPort interface {
    // NewNote orchestrates the complete note creation workflow:
    // 1. Load and render template via TemplateEngine
    // 2. Extract and validate frontmatter via FrontmatterService
    // 3. Generate NoteID from frontmatter fields
    // 4. Create Note domain object
    // 5. Persist to vault via VaultWriterPort
    // 6. Update cache via CacheWriterPort
    // 7. Return Note for CLI display
    //
    // [Complete method documentation here...]
    NewNote(ctx context.Context, templateID TemplateID) (Note, error)
}
```

**Quality Gates for Interface-Only Stories:**

1. **Compilation:** Interfaces must compile without errors
2. **Documentation:** GoDoc for all interfaces and methods
3. **Linting:** Zero warnings from golangci-lint
4. **No Dependencies:** Pure Go interfaces, no framework imports
5. **Architecture Alignment:** References to components.md are accurate
6. **Pattern Clarity:** Hexagonal callback pattern clearly explained
7. **Future-Proofing:** Future methods documented (IndexVault, FindTemplates)

**What NOT to Include:**

- No implementation code (that's in adapter/orchestrator stories)
- No test files (interfaces tested via implementations)
- No mocks (created when needed by implementation stories)
- No TODO comments (be explicit about future methods)

### Architecture Decision Record

**ADR: Hexagonal Callback Pattern for CLI Integration**

**Context:** Traditional CLI implementations couple domain logic to CLI framework (e.g., Cobra RunE functions contain business logic). This makes testing difficult and prevents supporting multiple interfaces (TUI, LSP).

**Decision:** Implement hexagonal callback pattern where:

1. Domain defines CLIPort interface (what it needs from CLI)
2. Domain defines CommandPort interface (what CLI can call back to)
3. CLI adapter implements CLIPort and receives CommandPort handler
4. Domain controls application flow by calling CLIPort.Start()

**Consequences:**

- ✅ Domain remains framework-agnostic
- ✅ Easy to add TUI/LSP adapters without domain changes
- ✅ Testable with mock CLIPort
- ⚠️ Slightly more complex than traditional approach (worth the tradeoff)

## Change Log

| Date       | Version | Description                                                               | Author             |
| ---------- | ------- | ------------------------------------------------------------------------- | ------------------ |
| 2025-10-28 | 1.0     | Story created from Epic 1 requirements                                    | Bob (Scrum Master) |
| 2025-10-28 | 1.1     | Enhanced with Port Interface Documentation Standards, linting checkpoints | QA Specialist      |
| 2025-10-29 | 1.2     | Implemented CLIPort and CommandPort interfaces with hexagonal callback pattern | James (Dev)       |

## Dev Agent Record

### Agent Model Used

Full Stack Developer (dev) - Interface definition and hexagonal architecture implementation

### Debug Log References

- golangci-lint run --fix internal/ports/api
- go test ./... (blocked by vendor sync mismatch; reran with -mod=mod)
- go test -mod=mod ./...
- git status -sb
- git add internal/ports/api/cli.go internal/ports/api/command.go docs/stories/1.11.cli-port-interfaces.md
- git commit -m "feat(ports): define CLI port interfaces" (pre-commit hooks executed)

### Completion Notes List

- CLIPort interface defined with comprehensive hexagonal callback pattern documentation
- CommandPort interface defined with NewNote method and future method placeholders
- All interfaces compile without errors and pass golangci-lint
- Hexagonal architecture pattern properly implemented for CLI integration
- Vendor mismatch noted when running go test; resolved by executing suite with -mod=mod (no code changes required)
- No framework dependencies imported - pure Go interfaces
- Documentation follows Port Interface Documentation Standards
- Story DoD checklist reviewed; all applicable items confirmed as complete

### File List

- `internal/ports/api/cli.go` - CLIPort interface definition with hexagonal callback pattern documentation
- `internal/ports/api/command.go` - CommandPort interface definition with NewNote method and future placeholders

## QA Results

_To be completed by QA agent after implementation_
