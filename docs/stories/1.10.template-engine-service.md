# Story 1.10: Implement TemplateEngine Service

## Status

Draft

## Story

**As a** developer,
**I want** to implement complete TemplateEngine domain service with Load, Render, and all template functions,
**so that** templates can be loaded from port, parsed with Go text/template, and rendered with custom functions.

## Acceptance Criteria

**TemplateEngine Setup and Load:**

- 1.10.1: Create `internal/app/template/service.go`:
  - Constructor: `NewTemplateEngine(templatePort TemplatePort, config Config, log zerolog.Logger) *TemplateEngine`
  - Dependencies: TemplatePort (injected), Config (injected), Logger (injected)

- 1.10.2: Implement `Load(ctx context.Context, templateID TemplateID) (Template, error)`:
  - Delegates to TemplatePort.Load()
  - Logs loading operation with template ID
  - Returns Template or error

**Function Map Setup:**

- 1.10.3: Implement private method `buildFuncMap() template.FuncMap`:
  - Returns template.FuncMap with all custom functions
  - Registers all functions described below

**Basic Template Functions:**

- 1.10.4: Implement basic functions in buildFuncMap():
  - `now(format string) string` - current timestamp with Go time layout (e.g., "2006-01-02")
  - `toLower(s string) string` - lowercase conversion using strings.ToLower
  - `toUpper(s string) string` - uppercase conversion using strings.ToUpper

**File Path Control Functions (v0.6.3):**

- 1.10.5: Implement file path control functions in buildFuncMap():
  - `path() string` - returns target file path (empty for MVP, used in Epic 3 for vault operations)
  - `folder(p string) string` - returns parent directory using filepath.Dir()
  - `basename(p string) string` - returns filename without extension (strips path and extension)
  - `extension(p string) string` - returns file extension using filepath.Ext() (includes dot)
  - `join(parts ...string) string` - joins path segments using filepath.Join() (OS-appropriate separator)
  - `vaultPath() string` - returns Config.VaultPath

**Render Method:**

- 1.10.6: Implement `Render(ctx context.Context, templateID TemplateID) (string, error)`:
  - Step 1: Load template via Load(ctx, templateID)
  - Step 2: Create `text/template` instance with template.ID as name
  - Step 3: Register function map via buildFuncMap()
  - Step 4: Parse template.Content using template.Parse()
  - Step 5: Execute template with empty data context (static rendering for Epic 1)
  - Step 6: Return rendered string
  - Error handling:
    - Template not found → ResourceError from Load()
    - Parse error → TemplateError with line/column info and template name
    - Execute error → TemplateError with template name and error details

**Testing:**

- 1.10.7: Add mock to `tests/utils/mocks.go`:
  - `MockTemplatePort` struct implementing TemplatePort interface
  - Internal storage: `map[TemplateID]Template`
  - Method: `SetTemplates(templates map[TemplateID]Template)` - configure mock responses
  - Method: `SetLoadError(err error)` - configure error response
  - Implements: List() returns keys from internal storage
  - Implements: Load() returns template from storage or configured error

- 1.10.8: Create unit tests in `internal/app/template/service_test.go`:
  - Test: Load() delegates to TemplatePort correctly
  - Test: Load() logs operation
  - Test: Load() propagates errors from port
  - Test: now() function returns formatted timestamp
  - Test: toLower() converts to lowercase
  - Test: toUpper() converts to uppercase
  - Test: folder() returns parent directory
  - Test: basename() strips path and extension
  - Test: extension() returns extension with dot
  - Test: join() uses OS-appropriate path separator
  - Test: vaultPath() returns config value
  - Test: Render() executes static template
  - Test: Render() uses now() function correctly
  - Test: Render() uses path control functions correctly
  - Test: Parse error returns TemplateError with details
  - Test: Execute error returns TemplateError with context
  - All tests use MockTemplatePort from tests/utils/mocks.go

- 1.10.9: Create integration test in `tests/integration/template_engine_test.go`:
  - Use existing testdata/templates/static-template.md
  - Compare rendered output to testdata/golden/static-template-expected.md
  - Verify all template functions work end-to-end:
    - now() with various format strings
    - toLower() and toUpper()
    - File path control functions (folder, basename, extension, join, vaultPath)
  - Test: Template composition works ({{template "name"}})

- 1.10.10: All tests pass: `go test ./internal/app ./tests/integration`

- 1.10.11: All linting passes: `golangci-lint run --fix internal/app`

- 1.10.12: Committed with message: `feat(app): implement TemplateEngine service with all functions`

## Tasks / Subtasks

- [ ] Task 1: Implement TemplateEngine struct and constructor (AC: 1.10.1)
  - [ ] Create `internal/app/template/service.go`
  - [ ] Define TemplateEngine struct with dependencies
  - [ ] Implement NewTemplateEngine constructor
  - [ ] Verify struct compiles

- [ ] Task 2: Implement Load method (AC: 1.10.2)
  - [ ] RED: Write failing test for Load() delegation
    - [ ] Write test case verifying Load() calls TemplatePort.Load()
    - [ ] Verify test fails with expected compilation error
    - [ ] Run `go test ./internal/app/template` and confirm failure
  - [ ] RED: Write failing test for Load() logging
    - [ ] Write test case verifying debug log with templateID
    - [ ] Verify test fails
  - [ ] RED: Write failing test for Load() error propagation
    - [ ] Write test case with TemplatePort returning error
    - [ ] Verify Load() propagates error correctly
    - [ ] Verify test fails
  - [ ] GREEN: Implement Load() method
    - [ ] Delegate to templatePort.Load(ctx, templateID)
    - [ ] Add logging with template ID
    - [ ] Propagate errors from port
    - [ ] Run `go test ./internal/app/template` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components (Load is already simple delegation):
      - [ ] Verify Load() has single responsibility (delegate to port)
      - [ ] Verify logging is minimal and non-intrusive
      - [ ] Verify no business logic in delegation method
    - [ ] Review naming: Load (clear intent, matches port method)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for Load() method documenting delegation pattern
      - [ ] Document error propagation behavior
      - [ ] Document logging level (debug) and content
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/template` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 3: Implement basic template functions (AC: 1.10.3-1.10.4)
  - [ ] RED: Write failing test for now() function
    - [ ] Write test case for now() with various time formats
    - [ ] Verify test fails (function not registered)
    - [ ] Run `go test ./internal/app/template` and confirm failure
  - [ ] RED: Write failing test for toLower() function
    - [ ] Write test case for toLower("HELLO") → "hello"
    - [ ] Verify test fails
  - [ ] RED: Write failing test for toUpper() function
    - [ ] Write test case for toUpper("hello") → "HELLO"
    - [ ] Verify test fails
  - [ ] GREEN: Implement buildFuncMap() private method
    - [ ] Create buildFuncMap() returning template.FuncMap
    - [ ] Register now() function using time.Now().Format()
    - [ ] Register toLower() using strings.ToLower
    - [ ] Register toUpper() using strings.ToUpper
    - [ ] Run `go test ./internal/app/template` and verify all tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract registerBasicFuncs(fm template.FuncMap) for basic functions
      - [ ] Extract registerPathFuncs(fm template.FuncMap, cfg Config) for path functions
      - [ ] Verify buildFuncMap() orchestrates registration cleanly
    - [ ] Review naming: now, toLower, toUpper (clear, descriptive)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for buildFuncMap() explaining function registration
      - [ ] Document each function's purpose and parameters inline
      - [ ] Reference PRD for function specifications
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/template` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for function registration
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 4: Implement file path control functions (AC: 1.10.5)
  - [ ] RED: Write failing test for path() function
    - [ ] Write test case verifying path() returns empty string (Epic 1)
    - [ ] Verify test fails (function not registered)
    - [ ] Run `go test ./internal/app/template` and confirm failure
  - [ ] RED: Write failing test for folder() function
    - [ ] Write test case for folder("/vault/notes/contact.md") → "/vault/notes"
    - [ ] Verify test fails
  - [ ] RED: Write failing test for basename() function
    - [ ] Write test case for basename("/vault/notes/contact.md") → "contact"
    - [ ] Verify test fails
  - [ ] RED: Write failing test for extension() function
    - [ ] Write test case for extension("/vault/notes/contact.md") → ".md"
    - [ ] Verify test fails
  - [ ] RED: Write failing test for join() function
    - [ ] Write test case for join(vaultPath(), "templates", "contact.md")
    - [ ] Verify test fails
  - [ ] RED: Write failing test for vaultPath() function
    - [ ] Write test case verifying vaultPath() returns Config.VaultPath
    - [ ] Verify test fails
  - [ ] GREEN: Implement file path control functions
    - [ ] Implement path() returning empty string (Epic 1 MVP placeholder)
    - [ ] Implement folder() using filepath.Dir()
    - [ ] Implement basename() stripping path and extension using strings.TrimSuffix
    - [ ] Implement extension() using filepath.Ext()
    - [ ] Implement join() using filepath.Join()
    - [ ] Implement vaultPath() as closure accessing e.config.VaultPath
    - [ ] Run `go test ./internal/app/template` and verify all tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components (already handled in buildFuncMap):
      - [ ] Verify each function has single responsibility
      - [ ] Verify functions are pure where possible (no side effects)
      - [ ] Verify closure pattern for vaultPath() accessing config
    - [ ] Review naming: path, folder, basename, extension, join, vaultPath (clear, descriptive)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Document each function's purpose and use cases
      - [ ] Document path() as placeholder for Epic 3
      - [ ] Document filepath operations (cross-platform behavior)
      - [ ] Reference architecture file path control functions spec
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/template` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for all path functions
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 5: Implement Render method (AC: 1.10.6)
  - [ ] RED: Write failing test for Render() success case
    - [ ] Write test case with valid template
    - [ ] Verify test fails (Render method not implemented)
    - [ ] Run `go test ./internal/app/template` and confirm failure
  - [ ] RED: Write failing test for Render() with template not found
    - [ ] Write test case with non-existent templateID
    - [ ] Expect ResourceError from Load()
    - [ ] Verify test fails
  - [ ] RED: Write failing test for Render() with parse error
    - [ ] Write test case with invalid template syntax
    - [ ] Expect TemplateError with parse details
    - [ ] Verify test fails
  - [ ] RED: Write failing test for Render() with execute error
    - [ ] Write test case with runtime execution error
    - [ ] Expect TemplateError with execute context
    - [ ] Verify test fails
  - [ ] GREEN: Implement Render() method
    - [ ] Load template via Load(ctx, templateID)
    - [ ] Create text/template instance with template.ID as name
    - [ ] Register buildFuncMap() function map using template.Funcs()
    - [ ] Parse template.Content using template.Parse()
    - [ ] Execute template with empty data context (nil for Epic 1)
    - [ ] Capture output to bytes.Buffer
    - [ ] Implement error handling with TemplateError wrapping
    - [ ] Run `go test ./internal/app/template` and verify all tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract createTemplate(id TemplateID) *template.Template for template initialization
      - [ ] Extract parseTemplate(tmpl *template.Template, content string) error for parsing
      - [ ] Extract executeTemplate(tmpl *template.Template, data interface{}) (string, error) for execution
      - [ ] Verify Render() orchestrates these steps cleanly
    - [ ] Review naming: Render (clear public method), helper methods descriptive
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for Render() documenting 6-step workflow
      - [ ] Document error types returned (ResourceError, TemplateError)
      - [ ] Document empty data context for Epic 1 static rendering
      - [ ] Add inline comments explaining each step
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/template` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90% for Render and helpers
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/template`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 6: Create MockTemplatePort (AC: 1.10.7)
  - [ ] Add MockTemplatePort to `tests/utils/mocks.go`
  - [ ] Implement internal storage map
  - [ ] Implement SetTemplates() configuration method
  - [ ] Implement SetLoadError() configuration method
  - [ ] Implement List() method
  - [ ] Implement Load() method
  - [ ] Verify mock compiles and satisfies interface

- [ ] Task 7: Create integration tests (AC: 1.10.9)
  - [ ] Create `tests/integration/template_engine_test.go`
  - [ ] Test: Render static-template.md
  - [ ] Test: Compare output to golden file
  - [ ] Test: Verify now() function works
  - [ ] Test: Verify string functions (toLower, toUpper)
  - [ ] Test: Verify file path functions
  - [ ] Test: Template composition works
  - [ ] Verify all integration tests pass

- [ ] Task 8: Run quality gates (AC: 1.10.10-1.10.11)
  - [ ] Run `go test ./internal/app` and verify 100% pass
  - [ ] Run `go test ./tests/integration` and verify 100% pass
  - [ ] Run `golangci-lint run --fix internal/app` and fix issues
  - [ ] Verify test coverage >85% for service code
  - [ ] Linting checkpoint:
    - [ ] Final sweep: `golangci-lint run --fix internal/app/template`
    - [ ] Verify ALL warnings resolved
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 9: Commit changes (AC: 1.10.12)
  - [ ] Review all changes for completeness
  - [ ] Stage files:
    - [ ] `git add internal/app/template/service.go`
    - [ ] `git add internal/app/template/service_test.go`
    - [ ] `git add tests/utils/mocks.go`
    - [ ] `git add tests/integration/template_engine_test.go`
  - [ ] Commit with message: `feat(app): implement TemplateEngine service with all functions`
  - [ ] Verify commit includes all necessary files
  - [ ] Linting checkpoint:
    - [ ] Run pre-commit hooks if installed
    - [ ] Verify commit message follows conventional commits format

## Dev Notes

### Architecture Alignment (v0.6.8)

This story implements the TemplateEngine domain service per architecture v0.6.8, providing template rendering capabilities with custom function map for Epic 1's static template features.

### TemplateEngine Service

From `docs/architecture/components.md#domain-services` - TemplateEngine (v0.1.0, updated v0.6.2):

**Responsibility:** Execute template rendering for `lithos new`/`find`, wiring together interactive prompts, lookups, and frontmatter validation. Pure domain service orchestrating template execution with custom function map for user interaction and file path control.

**Key Interfaces:**
- `Render(ctx context.Context, templateID TemplateID) (string, error)` - Render template to markdown string
- `Load(ctx context.Context, templateID TemplateID) (Template, error)` - Load template via TemplateLoader port

**Dependencies:** TemplatePort (injected), Config (injected), Logger (injected).

**Technology Stack:** Go `text/template`, custom function map with file path control functions, closures wrapping port calls for dependency injection, zerolog for instrumentation.

### Custom Template Functions

From `docs/architecture/components.md#domain-services` - Custom Template Functions section:

**Basic Functions:**
- `now(format string) string` - Current timestamp with Go time layout format (e.g., "2006-01-02")
- `toLower(s string) string` - Lowercase conversion
- `toUpper(s string) string` - Uppercase conversion

**File Path Control Functions** (inspired by Templater file module, v0.6.3):
- `path() string` - Returns target file path (empty for Epic 1, used in Epic 3 for vault operations)
- `folder(path string) string` - Returns parent directory using filepath.Dir()
- `basename(path string) string` - Returns filename without extension (strips path and extension)
- `extension(path string) string` - Returns file extension with dot using filepath.Ext()
- `join(parts ...string) string` - Joins path segments using filepath.Join() (OS-appropriate separator)
- `vaultPath() string` - Returns Config.VaultPath from configuration

**Implementation Pattern:**

```go
type TemplateEngine struct {
    templatePort TemplatePort
    config       Config
    log          zerolog.Logger
}

func NewTemplateEngine(templatePort TemplatePort, config Config, log zerolog.Logger) *TemplateEngine {
    return &TemplateEngine{
        templatePort: templatePort,
        config:       config,
        log:          log,
    }
}

func (e *TemplateEngine) Load(ctx context.Context, templateID TemplateID) (Template, error) {
    e.log.Debug().Str("templateID", string(templateID)).Msg("loading template")
    return e.templatePort.Load(ctx, templateID)
}

func (e *TemplateEngine) buildFuncMap() template.FuncMap {
    return template.FuncMap{
        // Basic functions
        "now":     func(format string) string { return time.Now().Format(format) },
        "toLower": strings.ToLower,
        "toUpper": strings.ToUpper,

        // File path control functions
        "path":      func() string { return "" }, // Empty for Epic 1
        "folder":    filepath.Dir,
        "basename":  func(p string) string {
            base := filepath.Base(p)
            return strings.TrimSuffix(base, filepath.Ext(base))
        },
        "extension": filepath.Ext,
        "join":      filepath.Join,
        "vaultPath": func() string { return e.config.VaultPath },
    }
}

func (e *TemplateEngine) Render(ctx context.Context, templateID TemplateID) (string, error) {
    // Step 1: Load template
    tmpl, err := e.Load(ctx, templateID)
    if err != nil {
        return "", err // ResourceError from Load()
    }

    // Step 2-3: Create text/template with function map
    t := template.New(string(tmpl.ID)).Funcs(e.buildFuncMap())

    // Step 4: Parse template content
    t, err = t.Parse(tmpl.Content)
    if err != nil {
        return "", NewTemplateError(
            fmt.Sprintf("parse error in template '%s'", tmpl.ID),
            string(tmpl.ID),
            err,
        )
    }

    // Step 5-6: Execute with empty data context and return
    var buf bytes.Buffer
    if err := t.Execute(&buf, nil); err != nil {
        return "", NewTemplateError(
            fmt.Sprintf("execute error in template '%s'", tmpl.ID),
            string(tmpl.ID),
            err,
        )
    }

    e.log.Info().Str("templateID", string(templateID)).Msg("template rendered successfully")
    return buf.String(), nil
}
```

### Template Function Examples

**Basic Functions:**

```go
// now() - Current timestamp
{{ now "2006-01-02" }}           // Output: 2025-10-28
{{ now "2006-01-02T15:04:05Z" }} // Output: 2025-10-28T14:30:00Z

// String manipulation
{{ toLower "HELLO WORLD" }}      // Output: hello world
{{ toUpper "hello world" }}      // Output: HELLO WORLD
```

**File Path Control Functions:**

```go
// path() - Target file path (empty for Epic 1)
{{ path }}                       // Output: "" (Epic 1), "/vault/notes/contact.md" (Epic 3)

// folder() - Parent directory
{{ folder "/vault/notes/contact.md" }} // Output: /vault/notes
{{ folder (path) }}                    // Output: parent of current note

// basename() - Filename without extension
{{ basename "/vault/notes/contact.md" }} // Output: contact
{{ basename (path) }}                    // Output: note name

// extension() - File extension with dot
{{ extension "/vault/notes/contact.md" }} // Output: .md

// join() - Join path segments (OS-appropriate)
{{ join (vaultPath) "templates" "contact.md" }} // Output: /vault/templates/contact.md

// vaultPath() - Vault root directory
{{ vaultPath }}                  // Output: /vault (from Config.VaultPath)
```

### Error Handling

From `docs/architecture/components.md#shared-internal-packages` - Error Package:

**TemplateError** - Template-specific errors:
```go
// Parse error
NewTemplateError(
    fmt.Sprintf("parse error in template '%s'", templateID),
    string(templateID),
    err,
)

// Execute error
NewTemplateError(
    fmt.Sprintf("execute error in template '%s'", templateID),
    string(templateID),
    err,
)
```

**ResourceError** - Propagated from TemplatePort.Load():
```go
// Template not found (from port)
NewResourceError("template", "load", string(templateID),
    fmt.Errorf("template not found"))
```

### Testing Standards

From `docs/architecture/testing-strategy.md`:

**Unit Test Organization:**
- Unit tests in `internal/app/template/service_test.go`
- Use MockTemplatePort from `tests/utils/mocks.go`
- Table-driven tests for template functions
- Test both success and error paths

**MockTemplatePort Implementation:**

```go
type MockTemplatePort struct {
    templates map[TemplateID]Template
    loadError error
}

func (m *MockTemplatePort) SetTemplates(templates map[TemplateID]Template) {
    m.templates = templates
}

func (m *MockTemplatePort) SetLoadError(err error) {
    m.loadError = err
}

func (m *MockTemplatePort) List(ctx context.Context) ([]TemplateID, error) {
    var ids []TemplateID
    for id := range m.templates {
        ids = append(ids, id)
    }
    return ids, nil
}

func (m *MockTemplatePort) Load(ctx context.Context, id TemplateID) (Template, error) {
    if m.loadError != nil {
        return Template{}, m.loadError
    }
    tmpl, exists := m.templates[id]
    if !exists {
        return Template{}, fmt.Errorf("template not found: %s", id)
    }
    return tmpl, nil
}
```

**Integration Test Setup:**
- Use existing `testdata/templates/` directory
- Create golden files in `testdata/golden/` for expected output
- Verify all template functions work with real filesystem
- Test template composition with `{{template "name"}}` directive

**Quality Gates:**
- All unit tests pass: `go test ./internal/app`
- All integration tests pass: `go test ./tests/integration`
- No linting errors: `golangci-lint run --fix internal/app`
- Test coverage >85% for service code

### File Locations

From `docs/architecture/source-tree.md`:

**Implementation:**
- `internal/app/template/service.go` - TemplateEngine service
- `internal/app/template/service_test.go` - Unit tests
- `tests/utils/mocks.go` - MockTemplatePort (shared test utility)
- `tests/integration/template_engine_test.go` - Integration tests

**Test Data:**
- `testdata/templates/static-template.md` - Test template
- `testdata/golden/static-template-expected.md` - Expected rendered output

### Technology Stack

From `docs/architecture/tech-stack.md`:

**Template Engine:**
- `text/template` (stdlib) - Go template engine for rendering
- Template functions registered via `template.FuncMap`
- Template composition via `{{define}}` and `{{template}}`

**String Operations:**
- `strings.ToLower`, `strings.ToUpper` - String manipulation
- `strings.TrimSuffix` - Basename extraction

**File Path Operations:**
- `filepath.Dir` - Parent directory extraction
- `filepath.Ext` - File extension extraction
- `filepath.Base` - Filename extraction
- `filepath.Join` - OS-appropriate path joining

**Time Operations:**
- `time.Now().Format()` - Current timestamp formatting with Go time layout

### Common Pitfalls to Avoid

1. **DO use closures for functions needing dependencies** - vaultPath() uses closure to access config
2. **DO parse error messages with context** - Include template name in TemplateError
3. **DO test all template functions** - Each function needs unit test
4. **DO use empty data context for Epic 1** - Template.Execute(buf, nil) for static rendering
5. **DO log template operations** - Debug level for Load(), Info level for successful Render()
6. **DO return proper error types** - TemplateError for parse/execute, ResourceError from Load()
7. **DO implement path() as empty for Epic 1** - Will be populated in Epic 3 for vault operations

### Refactoring Guidelines

**SRP Decomposition Examples:**

For this story (template engine service), functions should be decomposed into focused helpers following SRP:

**buildFuncMap() Decomposition:**
- `registerBasicFuncs(fm template.FuncMap)` - Register basic string/time functions (now, toLower, toUpper)
- `registerPathFuncs(fm template.FuncMap, cfg Config)` - Register file path control functions (path, folder, basename, extension, join, vaultPath)
- `buildFuncMap()` orchestrates registration of all function categories

**Render() Method Decomposition:**
- `createTemplate(id TemplateID) *template.Template` - Initialize text/template with ID and function map
- `parseTemplate(tmpl *template.Template, content string) error` - Parse template content
- `executeTemplate(tmpl *template.Template, data interface{}) (string, error)` - Execute template to string
- `Render()` orchestrates load → create → parse → execute workflow

**Load() Method (Simple Delegation):**
- Already focused: delegates to TemplatePort.Load()
- No decomposition needed (single responsibility: delegate to port)

**When to Decompose:**
- If any method exceeds 15 lines, consider extraction
- If a method has >2 concerns, extract helpers (e.g., Render handles load, create, parse, execute → extract each)
- Extract template initialization, parsing, and execution for easier testing
- Function registration should be categorized (basic vs path functions)

**Naming Standards:**
- Exported types: PascalCase (TemplateEngine)
- Constructors: NewTypeName (NewTemplateEngine)
- Public methods: PascalCase (Load, Render)
- Private helpers: camelCase (buildFuncMap, createTemplate, registerBasicFuncs)
- Template functions: camelCase (now, toLower, folder, basename)

**Documentation Requirements:**
- Package comment at top of service.go explaining TemplateEngine purpose
- All exported types and methods have GoDoc comments
- Private helpers have GoDoc or inline comments explaining purpose
- Document each template function's signature and use cases
- Document error types returned (ResourceError, TemplateError)
- Reference architecture docs for template function specifications
- Document empty data context for Epic 1 static rendering

**Error Handling Patterns:**
- Template not found: Propagate ResourceError from Load()
- Parse error: Return TemplateError with template name and parse details
- Execute error: Return TemplateError with template name and execution context
- Function registration errors: None expected (pure functions)

**Testing Decomposition:**
- Each helper function should have dedicated unit tests
- Test helpers in isolation before testing orchestrating methods
- Use MockTemplatePort for Load() delegation testing
- Test all template functions individually
- Integration tests verify end-to-end rendering with real templates

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 1 requirements | Bob (Scrum Master) |
| 2025-10-28 | 1.1 | Enhanced with full TDD framework, SRP decomposition, linting checkpoints | QA Specialist |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
