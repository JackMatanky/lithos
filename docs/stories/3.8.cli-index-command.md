# Story 3.8: CLI Index Command

## Status

Draft

## Story

**As a** developer,
**I want** the CLI to trigger vault indexing via CommandOrchestrator,
**so that** users can rebuild the cache and indices on demand.

## Acceptance Criteria

1. `internal/app/command/orchestrator.go` implements `IndexVault(ctx context.Context) (IndexStats, error)` delegating to `VaultIndexer.Build`, logging summary statistics per `components.md#commandorchestrator`, and wrapping errors per the error strategy.

2. The CLI adapter registers an `index` command mirroring the architecture workflow: parse flags, call CommandPort, print stats, return non-zero exit code on failure.

3. Integration or end-to-end tests execute `lithos index` against fixtures, verify cache files, CLI output, and satisfaction of FR9.

4. Documentation or help output references the new command consistent with `docs/prd/requirements.md#functional` entries.

5. `golangci-lint run ./internal/app/command ./internal/adapters/api/cli` and `go test ./...` succeed.

## Tasks / Subtasks

- [ ] Task 1: Implement IndexVault() in CommandOrchestrator (AC: 1)
  - [ ] RED: Write failing tests for IndexVault delegation
  - [ ] RED: Test stats logging
  - [ ] RED: Test error wrapping
  - [ ] GREEN: Implement IndexVault() delegating to VaultIndexer.Build()
  - [ ] GREEN: Log summary statistics (indexed, failures, duration)
  - [ ] GREEN: Wrap errors with context
  - [ ] REFACTOR: Add structured logging

- [ ] Task 2: Add IndexVault to CommandPort interface (AC: 1)
  - [ ] RED: Write test verifying interface definition
  - [ ] GREEN: Add `IndexVault(ctx context.Context) (IndexStats, error)` to CommandPort
  - [ ] GREEN: Update CommandOrchestrator to implement new method
  - [ ] REFACTOR: Update interface documentation

- [ ] Task 3: Implement CLI `index` command (AC: 2)
  - [ ] RED: Write failing tests for CLI command registration
  - [ ] RED: Test stats output formatting
  - [ ] RED: Test error exit codes
  - [ ] GREEN: Add buildIndexCommand() to CobraCLI adapter
  - [ ] GREEN: Implement handleIndexCommand() calling CommandPort.IndexVault()
  - [ ] GREEN: Format and print IndexStats to stdout
  - [ ] GREEN: Return exit code 1 on failure
  - [ ] REFACTOR: Add command help text

- [ ] Task 4: Integration/E2E testing (AC: 3)
  - [ ] Create integration test with test vault fixtures
  - [ ] Test `lithos index` command execution
  - [ ] Verify cache files created in .lithos/cache/
  - [ ] Verify CLI output shows correct stats
  - [ ] Test error scenarios (invalid vault path)
  - [ ] Verify FR9 query capabilities after indexing

- [ ] Task 5: Update documentation (AC: 4)
  - [ ] Update README with `lithos index` command
  - [ ] Add command to CLI help output
  - [ ] Document index rebuild workflow
  - [ ] Reference FR9 in command description

- [ ] Task 6: Quality gates (AC: 5)
  - [ ] Run `golangci-lint run --fix internal/app/command internal/adapters/api/cli`
  - [ ] Run `go test ./...` - verify all tests pass
  - [ ] Run integration tests
  - [ ] Verify test coverage >85%

## Dev Notes

### CommandOrchestrator Integration

From `docs/architecture/components.md#commandorchestrator` (v0.6.4):

**Purpose:** Orchestrates use case workflows, delegating to domain services.

**IndexVault Implementation:**

```go
func (c *CommandOrchestrator) IndexVault(ctx context.Context) (IndexStats, error) {
    c.log.Info().Msg("starting vault indexing")

    // Delegate to VaultIndexer
    stats, err := c.vaultIndexer.Build(ctx)
    if err != nil {
        return stats, fmt.Errorf("vault indexing failed: %w", err)
    }

    // Log summary statistics
    c.log.Info().
        Int("scanned", stats.ScannedCount).
        Int("indexed", stats.IndexedCount).
        Int("validation_failures", stats.ValidationFailures).
        Int("cache_failures", stats.CacheFailures).
        Dur("duration", stats.Duration).
        Msg("vault indexing complete")

    return stats, nil
}
```

**Dependencies:**
- VaultIndexer injected in constructor
- Logger for structured logging
- Returns IndexStats for CLI display

### CommandPort Interface Update

```go
// CommandPort defines use case orchestration interface
type CommandPort interface {
    // NewNote creates note from template (Epic 1)
    NewNote(ctx context.Context, templateID TemplateID) (Note, error)

    // IndexVault rebuilds cache and query indices (Epic 3)
    IndexVault(ctx context.Context) (IndexStats, error)

    // Future: Additional use cases added in later epics
}
```

### CLI Index Command

**Command Registration in CobraCLI:**

```go
func (c *CobraCLIAdapter) buildIndexCommand() *cobra.Command {
    cmd := &cobra.Command{
        Use:   "index",
        Short: "Rebuild vault cache and query indices",
        Long: `Scans the vault, extracts frontmatter, validates against schemas,
and updates the cache and in-memory query indices.

Use this command after:
- Adding or modifying notes in the vault
- Changing schema definitions
- Manual cache corruption recovery`,
        RunE: c.handleIndexCommand,
    }

    // Future: Add flags like --incremental, --verbose

    return cmd
}
```

**Command Handler:**

```go
func (c *CobraCLIAdapter) handleIndexCommand(cmd *cobra.Command, args []string) error {
    ctx := cmd.Context()

    // Call CommandPort
    stats, err := c.handler.IndexVault(ctx)
    if err != nil {
        c.log.Error().Err(err).Msg("indexing failed")
        return c.formatError(err)
    }

    // Display statistics
    c.displayIndexStats(cmd, stats)

    return nil
}
```

**Stats Display:**

```go
func (c *CobraCLIAdapter) displayIndexStats(cmd *cobra.Command, stats IndexStats) {
    fmt.Fprintf(cmd.OutOrStdout(), "✓ Vault indexed successfully\n\n")
    fmt.Fprintf(cmd.OutOrStdout(), "Statistics:\n")
    fmt.Fprintf(cmd.OutOrStdout(), "  Scanned:    %d files\n", stats.ScannedCount)
    fmt.Fprintf(cmd.OutOrStdout(), "  Indexed:    %d notes\n", stats.IndexedCount)

    if stats.ValidationFailures > 0 {
        fmt.Fprintf(cmd.OutOrStdout(), "  ⚠ Validation failures: %d\n", stats.ValidationFailures)
    }

    if stats.CacheFailures > 0 {
        fmt.Fprintf(cmd.OutOrStdout(), "  ⚠ Cache failures:      %d\n", stats.CacheFailures)
    }

    fmt.Fprintf(cmd.OutOrStdout(), "  Duration:   %v\n", stats.Duration)
}
```

### FR9: Cache and Query Requirements

From `docs/prd/requirements.md#fr9`:

**Indexing Requirements:**
- Scan vault for markdown files
- Extract and validate frontmatter
- Persist to cache (.lithos/cache/)
- Build in-memory query indices
- Support incremental updates (future)

**Cache Location:**
- Config.CacheDir (default: .lithos/cache/)
- One JSON file per note
- Atomic writes using moby/sys/atomicwriter

### Integration Testing

**Test Structure:**

```go
func TestIndexCommand_Integration(t *testing.T) {
    // Setup test vault
    tempDir := t.TempDir()
    createTestVault(t, tempDir)
    os.Setenv("LITHOS_VAULT_PATH", tempDir)
    defer os.Unsetenv("LITHOS_VAULT_PATH")

    // Build binary
    buildLithos(t, tempDir)

    // Execute: lithos index
    cmd := exec.Command(filepath.Join(tempDir, "lithos"), "index")
    output, err := cmd.CombinedOutput()
    require.NoError(t, err)

    // Verify output
    assert.Contains(t, string(output), "✓ Vault indexed successfully")
    assert.Contains(t, string(output), "Scanned:")
    assert.Contains(t, string(output), "Indexed:")

    // Verify cache files created
    cacheDir := filepath.Join(tempDir, ".lithos", "cache")
    files, err := os.ReadDir(cacheDir)
    require.NoError(t, err)
    assert.Greater(t, len(files), 0, "cache should contain note files")

    // Verify cache file structure
    cacheFile := filepath.Join(cacheDir, files[0].Name())
    content, err := os.ReadFile(cacheFile)
    require.NoError(t, err)

    var note Note
    err = json.Unmarshal(content, &note)
    require.NoError(t, err)
    assert.NotEmpty(t, note.ID)
}
```

**Test Fixtures:**
- Create temporary vault with sample .md files
- Include valid and invalid frontmatter for testing
- Verify stats report correct counts

### File Locations

**Implementation:**
- `internal/app/command/orchestrator.go` - Add IndexVault() method
- `internal/ports/api/command.go` - Add IndexVault to CommandPort interface
- `internal/adapters/api/cli/cobra.go` - Add buildIndexCommand() and handleIndexCommand()
- `tests/integration/index_command_test.go` - Integration test

**Dependencies:**
- `internal/app/vault/indexer.go` - VaultIndexer.Build()
- `internal/shared/logger` - Structured logging
- `github.com/spf13/cobra` - CLI framework

### Common Pitfalls

1. **DO NOT block on long indexing** - Ensure context cancellation works
2. **DO handle partial failures** - Display stats even with some errors
3. **DO provide clear output** - Users need to understand what happened
4. **DO update help text** - Document new command clearly
5. **DO test cache persistence** - Verify files written to correct location

### Example Output

```bash
$ lithos index
✓ Vault indexed successfully

Statistics:
  Scanned:    150 files
  Indexed:    142 notes
  ⚠ Validation failures: 5
  ⚠ Cache failures:      3
  Duration:   234ms
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 3 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## QA Results

_To be completed by QA agent after implementation_
