# Story 3.8: CLI Index Command

## Status

Ready for Implementation

## Story

**As a** developer,
**I want** the CLI to trigger vault indexing via CommandOrchestrator,
**so that** users can rebuild the cache and indices on demand.

## Acceptance Criteria

1. `internal/app/command/orchestrator.go` implements `IndexVault(ctx context.Context) (IndexStats, error)` delegating to `VaultIndexer.Build`, logging summary statistics per `components.md#commandorchestrator`, and wrapping errors per the error strategy.

2. The CLI adapter registers an `index` command mirroring the architecture workflow: parse flags, call CommandPort, print stats, return non-zero exit code on failure.

3. Integration or end-to-end tests execute `lithos index` against fixtures, verify cache files, CLI output, and satisfaction of FR9.

4. Documentation or help output references the new command consistent with `docs/prd/requirements.md#functional` entries.

5. `golangci-lint run ./internal/app/command ./internal/adapters/api/cli` and `go test ./...` succeed.

## Tasks / Subtasks

- [ ] Task 1: Implement IndexVault() in CommandOrchestrator (AC: 1)
  - [ ] RED: Write failing tests for IndexVault delegation
    - [ ] Write test case verifying IndexVault() calls VaultIndexer.Build()
    - [ ] Write test case verifying IndexVault() returns IndexStats
    - [ ] Write test case verifying stats logging (scanned, indexed, failures, duration)
    - [ ] Write test case verifying error wrapping with context
    - [ ] Verify tests fail (method not implemented)
    - [ ] Run `go test ./internal/app/command` and confirm failures
  - [ ] GREEN: Implement IndexVault() method
    - [ ] Log Info message "starting vault indexing"
    - [ ] Call vaultIndexer.Build(ctx) and capture stats
    - [ ] Log Info message with summary statistics
    - [ ] Wrap errors with context on failure
    - [ ] Return IndexStats and error
    - [ ] Run `go test ./internal/app/command` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract buildCmd() for command construction (responsibility: command setup)
      - [ ] Extract executeCmd(ctx) for delegation logic (responsibility: VaultIndexer invocation)
      - [ ] Extract displayResults(stats) for stats logging (responsibility: result display)
      - [ ] Extract formatOutput(stats) string for stats formatting (responsibility: output formatting)
      - [ ] Verify IndexVault() orchestrates helpers cleanly
    - [ ] Review naming: IndexVault (clear use case method), buildCmd, executeCmd, displayResults, formatOutput (verb patterns)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for IndexVault() explaining delegation to VaultIndexer
      - [ ] Document stats logging format
      - [ ] Document error wrapping strategy
      - [ ] Document workflow: log start → delegate → log results → return
    - [ ] Run `golangci-lint run --fix internal/app/command`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/app/command` to verify refactoring didn't break tests
    - [ ] Verify test coverage >90%
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/app/command`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 2: Add IndexVault to CommandPort interface (AC: 1)
  - [ ] RED: Write test verifying interface definition
    - [ ] Write test case verifying CommandPort interface includes IndexVault method
    - [ ] Write test case verifying CommandOrchestrator implements CommandPort with IndexVault
    - [ ] Verify tests fail (interface not updated)
    - [ ] Run `go test ./internal/ports/api` and confirm failures
  - [ ] GREEN: Update CommandPort interface
    - [ ] Add `IndexVault(ctx context.Context) (IndexStats, error)` to CommandPort
    - [ ] Verify CommandOrchestrator implements new method
    - [ ] Run `go test ./internal/ports/api` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Review interface documentation for clarity
    - [ ] Add GoDoc for IndexVault method in interface
    - [ ] Document use case: rebuild cache and query indices on demand
    - [ ] Run `golangci-lint run --fix internal/ports/api`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/ports/api` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/ports/api`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 3: Implement CLI `index` command (AC: 2)
  - [ ] RED: Write failing tests for CLI command
    - [ ] Write test for buildIndexCommand() registering command
    - [ ] Write test for handleIndexCommand() calling CommandPort.IndexVault()
    - [ ] Write test for displayIndexStats() formatting output
    - [ ] Write test for warning indicators shown for failures
    - [ ] Write test for error exit codes on indexing failure
    - [ ] Verify tests fail (command not implemented)
    - [ ] Run `go test ./internal/adapters/api/cli` and confirm failures
  - [ ] GREEN: Implement buildIndexCommand() method
    - [ ] Create cobra.Command with Use: "index"
    - [ ] Add Short and Long help text
    - [ ] Set RunE to handleIndexCommand
    - [ ] Register command with root command
    - [ ] Run `go test ./internal/adapters/api/cli` and verify tests pass
  - [ ] GREEN: Implement handleIndexCommand() method
    - [ ] Get context from cmd.Context()
    - [ ] Call handler.IndexVault(ctx)
    - [ ] Handle errors: log error, return formatError(err)
    - [ ] Display stats via displayIndexStats(cmd, stats)
    - [ ] Return nil on success
    - [ ] Run `go test ./internal/adapters/api/cli` and verify tests pass
  - [ ] GREEN: Implement displayIndexStats() method
    - [ ] Print success message with checkmark
    - [ ] Print statistics header
    - [ ] Print Scanned, Indexed counts
    - [ ] Print warning indicators for ValidationFailures and CacheFailures
    - [ ] Print Duration
    - [ ] Use cmd.OutOrStdout() for testability
    - [ ] Run `go test ./internal/adapters/api/cli` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Decompose into SRP components:
      - [ ] Extract buildCmd() for command structure (responsibility: cobra command construction)
      - [ ] Extract executeCmd(cmd, args) for execution logic (responsibility: CommandPort invocation)
      - [ ] Extract displayResults(stats) for output (responsibility: result formatting)
      - [ ] Extract formatOutput(stats) string for formatting (responsibility: string formatting)
      - [ ] Verify CLI adapter orchestrates helpers cleanly
    - [ ] Review naming: buildIndexCommand, handleIndexCommand, displayIndexStats (clear CLI method names)
    - [ ] Add comprehensive GoDoc comments:
      - [ ] Add GoDoc for buildIndexCommand() explaining command registration
      - [ ] Add GoDoc for handleIndexCommand() explaining workflow
      - [ ] Add GoDoc for displayIndexStats() explaining output format
      - [ ] Document help text and user-facing messaging
    - [ ] Run `golangci-lint run --fix internal/adapters/api/cli`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/adapters/api/cli` to verify refactoring didn't break tests
    - [ ] Verify test coverage >85%
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/adapters/api/cli`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 4: Integration/E2E testing (AC: 3)
  - [ ] RED: Write failing integration tests
    - [ ] Write test for `lithos index` command execution
    - [ ] Write test for cache files created in .lithos/cache/
    - [ ] Write test for CLI output showing correct stats
    - [ ] Write test for error scenarios (invalid vault path)
    - [ ] Write test for FR9 query capabilities after indexing
    - [ ] Verify tests fail (integration not complete)
    - [ ] Run `go test ./tests/integration` and confirm failures
  - [ ] GREEN: Create integration test environment
    - [ ] Set up test vault with sample .md files
    - [ ] Create temporary directory for vault and cache
    - [ ] Build lithos binary for testing
    - [ ] Execute `lithos index` command
    - [ ] Verify cache files created
    - [ ] Verify CLI output format
    - [ ] Test error scenarios
    - [ ] Run `go test ./tests/integration` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Extract test helpers for environment setup
    - [ ] Add GoDoc comments for integration test structure
    - [ ] Verify test isolation (each test uses fresh vault/cache)
    - [ ] Run `golangci-lint run --fix tests/integration`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./tests/integration` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix tests/integration`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 5: Update documentation (AC: 4)
  - [ ] RED: Write test verifying documentation completeness (if applicable)
  - [ ] GREEN: Update README with `lithos index` command
    - [ ] Add command syntax and description
    - [ ] Add example usage
    - [ ] Document when to rebuild index
  - [ ] GREEN: Update CLI help output
    - [ ] Verify command appears in `lithos --help`
    - [ ] Verify `lithos index --help` shows detailed help
  - [ ] GREEN: Document index rebuild workflow
    - [ ] Add workflow diagram or description
    - [ ] Document cache location and structure
  - [ ] GREEN: Reference FR9 in command description
    - [ ] Link to functional requirements
    - [ ] Explain query capabilities enabled by indexing
  - [ ] REFACTOR:
    - [ ] Review documentation for clarity and completeness
    - [ ] Verify all links work
    - [ ] Verify examples are correct

- [ ] Task 6: Quality gates (AC: 5)
  - [ ] Run `go test ./internal/app/command` and verify 100% pass
  - [ ] Run `go test ./internal/adapters/api/cli` and verify 100% pass
  - [ ] Run `go test ./tests/integration` and verify 100% pass
  - [ ] Run `golangci-lint run internal/app/command internal/adapters/api/cli` and fix any issues
  - [ ] Verify test coverage >85%: `go test -cover ./...`
  - [ ] Linting checkpoint:
    - [ ] Final sweep: `golangci-lint run --fix internal/app/command internal/adapters/api/cli tests/integration`
    - [ ] Verify ALL warnings resolved
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 7: Commit changes (AC: committed)
  - [ ] Review all changes for completeness
  - [ ] Stage files:
    - [ ] `git add internal/app/command/orchestrator.go`
    - [ ] `git add internal/ports/api/command.go`
    - [ ] `git add internal/adapters/api/cli/cobra.go`
    - [ ] `git add internal/app/command/orchestrator_test.go`
    - [ ] `git add internal/adapters/api/cli/cobra_test.go`
    - [ ] `git add tests/integration/index_command_test.go`
    - [ ] `git add README.md`
  - [ ] Commit with message: `feat(cli): add index command for vault cache rebuild`
  - [ ] Verify commit includes all necessary files
  - [ ] Linting checkpoint:
    - [ ] Run pre-commit hooks if installed
    - [ ] Verify commit message follows conventional commits format

## Dev Notes

### CommandOrchestrator Integration

From `docs/architecture/components.md#commandorchestrator` (v0.6.4):

**Purpose:** Orchestrates use case workflows, delegating to domain services.

**IndexVault Implementation:**

```go
func (c *CommandOrchestrator) IndexVault(ctx context.Context) (IndexStats, error) {
    c.log.Info().Msg("starting vault indexing")

    // Delegate to VaultIndexer
    stats, err := c.vaultIndexer.Build(ctx)
    if err != nil {
        return stats, fmt.Errorf("vault indexing failed: %w", err)
    }

    // Log summary statistics
    c.log.Info().
        Int("scanned", stats.ScannedCount).
        Int("indexed", stats.IndexedCount).
        Int("validation_failures", stats.ValidationFailures).
        Int("cache_failures", stats.CacheFailures).
        Dur("duration", stats.Duration).
        Msg("vault indexing complete")

    return stats, nil
}
```

**Dependencies:**
- VaultIndexer injected in constructor
- Logger for structured logging
- Returns IndexStats for CLI display

### CommandPort Interface Update

```go
// CommandPort defines use case orchestration interface
type CommandPort interface {
    // NewNote creates note from template (Epic 1)
    NewNote(ctx context.Context, templateID TemplateID) (Note, error)

    // IndexVault rebuilds cache and query indices (Epic 3)
    IndexVault(ctx context.Context) (IndexStats, error)

    // Future: Additional use cases added in later epics
}
```

### CLI Index Command

**Command Registration in CobraCLI:**

```go
func (c *CobraCLIAdapter) buildIndexCommand() *cobra.Command {
    cmd := &cobra.Command{
        Use:   "index",
        Short: "Rebuild vault cache and query indices",
        Long: `Scans the vault, extracts frontmatter, validates against schemas,
and updates the cache and in-memory query indices.

Use this command after:
- Adding or modifying notes in the vault
- Changing schema definitions
- Manual cache corruption recovery`,
        RunE: c.handleIndexCommand,
    }

    // Future: Add flags like --incremental, --verbose

    return cmd
}
```

**Command Handler:**

```go
func (c *CobraCLIAdapter) handleIndexCommand(cmd *cobra.Command, args []string) error {
    ctx := cmd.Context()

    // Call CommandPort
    stats, err := c.handler.IndexVault(ctx)
    if err != nil {
        c.log.Error().Err(err).Msg("indexing failed")
        return c.formatError(err)
    }

    // Display statistics
    c.displayIndexStats(cmd, stats)

    return nil
}
```

**Stats Display:**

```go
func (c *CobraCLIAdapter) displayIndexStats(cmd *cobra.Command, stats IndexStats) {
    fmt.Fprintf(cmd.OutOrStdout(), "✓ Vault indexed successfully\n\n")
    fmt.Fprintf(cmd.OutOrStdout(), "Statistics:\n")
    fmt.Fprintf(cmd.OutOrStdout(), "  Scanned:    %d files\n", stats.ScannedCount)
    fmt.Fprintf(cmd.OutOrStdout(), "  Indexed:    %d notes\n", stats.IndexedCount)

    if stats.ValidationFailures > 0 {
        fmt.Fprintf(cmd.OutOrStdout(), "  ⚠ Validation failures: %d\n", stats.ValidationFailures)
    }

    if stats.CacheFailures > 0 {
        fmt.Fprintf(cmd.OutOrStdout(), "  ⚠ Cache failures:      %d\n", stats.CacheFailures)
    }

    fmt.Fprintf(cmd.OutOrStdout(), "  Duration:   %v\n", stats.Duration)
}
```

### FR9: Cache and Query Requirements

From `docs/prd/requirements.md#fr9`:

**Indexing Requirements:**
- Scan vault for markdown files
- Extract and validate frontmatter
- Persist to cache (.lithos/cache/)
- Build in-memory query indices
- Support incremental updates (future)

**Cache Location:**
- Config.CacheDir (default: .lithos/cache/)
- One JSON file per note
- Atomic writes using moby/sys/atomicwriter

### Integration Testing

**Test Structure:**

```go
func TestIndexCommand_Integration(t *testing.T) {
    // Setup test vault
    tempDir := t.TempDir()
    createTestVault(t, tempDir)
    os.Setenv("LITHOS_VAULT_PATH", tempDir)
    defer os.Unsetenv("LITHOS_VAULT_PATH")

    // Build binary
    buildLithos(t, tempDir)

    // Execute: lithos index
    cmd := exec.Command(filepath.Join(tempDir, "lithos"), "index")
    output, err := cmd.CombinedOutput()
    require.NoError(t, err)

    // Verify output
    assert.Contains(t, string(output), "✓ Vault indexed successfully")
    assert.Contains(t, string(output), "Scanned:")
    assert.Contains(t, string(output), "Indexed:")

    // Verify cache files created
    cacheDir := filepath.Join(tempDir, ".lithos", "cache")
    files, err := os.ReadDir(cacheDir)
    require.NoError(t, err)
    assert.Greater(t, len(files), 0, "cache should contain note files")

    // Verify cache file structure
    cacheFile := filepath.Join(cacheDir, files[0].Name())
    content, err := os.ReadFile(cacheFile)
    require.NoError(t, err)

    var note Note
    err = json.Unmarshal(content, &note)
    require.NoError(t, err)
    assert.NotEmpty(t, note.ID)
}
```

**Test Fixtures:**
- Create temporary vault with sample .md files
- Include valid and invalid frontmatter for testing
- Verify stats report correct counts

### File Locations

**Implementation:**
- `internal/app/command/orchestrator.go` - Add IndexVault() method
- `internal/ports/api/command.go` - Add IndexVault to CommandPort interface
- `internal/adapters/api/cli/cobra.go` - Add buildIndexCommand() and handleIndexCommand()
- `tests/integration/index_command_test.go` - Integration test

**Dependencies:**
- `internal/app/vault/indexer.go` - VaultIndexer.Build()
- `internal/shared/logger` - Structured logging
- `github.com/spf13/cobra` - CLI framework

### Common Pitfalls

1. **DO NOT block on long indexing** - Ensure context cancellation works
2. **DO handle partial failures** - Display stats even with some errors
3. **DO provide clear output** - Users need to understand what happened
4. **DO update help text** - Document new command clearly
5. **DO test cache persistence** - Verify files written to correct location

### Example Output

```bash
$ lithos index
✓ Vault indexed successfully

Statistics:
  Scanned:    150 files
  Indexed:    142 notes
  ⚠ Validation failures: 5
  ⚠ Cache failures:      3
  Duration:   234ms
```

### Refactoring Guidelines

**SRP Decomposition Examples:**

For this story (CLI Index Command), functions should be decomposed into focused helpers following SRP:

**CommandOrchestrator.IndexVault() Decomposition:**
- `buildCmd()` - Construct command context and parameters (responsibility: command setup)
- `executeCmd(ctx) (IndexStats, error)` - Delegate to VaultIndexer.Build() (responsibility: VaultIndexer invocation)
- `displayResults(stats IndexStats)` - Log summary statistics (responsibility: result display)
- `formatOutput(stats IndexStats) string` - Format stats for logging (responsibility: output formatting)
- IndexVault() orchestrates these helpers: log start → execute → display → return

**CLI Adapter (buildIndexCommand/handleIndexCommand) Decomposition:**
- `buildCmd() *cobra.Command` - Construct cobra command structure (responsibility: command registration)
- `executeCmd(cmd *cobra.Command, args []string) error` - Call CommandPort.IndexVault() (responsibility: CommandPort invocation)
- `displayResults(cmd *cobra.Command, stats IndexStats)` - Format and print stats to stdout (responsibility: result formatting)
- `formatOutput(stats IndexStats) string` - Create stats output string (responsibility: string formatting)
- CLI adapter orchestrates: build command → handle execution → display results

**When to Decompose:**
- If any method exceeds 15 lines, consider extraction
- If a method has >2 concerns, extract helpers (e.g., handleIndexCommand does invoke + display → extract displayIndexStats)
- Extract output formatting for testability (formatOutput can be tested without I/O)
- CLI adapters should coordinate user interaction, not implement business logic
- CommandOrchestrator should delegate to domain services, not implement indexing logic

**Naming Standards:**
- Exported types: PascalCase (CommandOrchestrator, CobraCLIAdapter)
- Constructors: NewTypeName (NewCommandOrchestrator)
- Private helpers: camelCase (buildCmd, executeCmd, displayResults, formatOutput)
- Methods: PascalCase for exported (IndexVault), camelCase for private
- CLI methods: buildIndexCommand (cobra command builder), handleIndexCommand (cobra handler), displayIndexStats (output formatter)

**Documentation Requirements:**
- Package comment at top of orchestrator.go explaining CommandOrchestrator purpose
- All exported types and methods have GoDoc comments
- Private helpers have GoDoc or inline comments explaining purpose
- Document IndexVault workflow: log start → delegate to VaultIndexer → log results → return
- Document CLI command registration and help text
- Document stats output format for user-facing display
- Document error handling: wrap errors with context, return non-zero exit codes
- Document FR9 compliance: indexing enables query capabilities

**Error Handling Patterns:**
- VaultIndexer.Build() failure: Wrap with context, log error, return to CLI
- CLI displays error: Use formatError() for user-friendly messages
- Exit codes: Return 1 on indexing failure (cobra convention)
- Partial indexing success: Display stats with warning indicators for failures
- Structured logging: Info for progress (start, complete), Error for failures

**Testing Decomposition:**
- Each helper function should have dedicated unit tests
- Test CommandOrchestrator.IndexVault(): verify delegation, stats logging, error wrapping
- Test CLI command registration: verify buildIndexCommand() returns correct cobra.Command
- Test CLI handler: verify handleIndexCommand() calls CommandPort.IndexVault()
- Test output formatting: verify displayIndexStats() produces correct output
- Integration tests: execute `lithos index` against test vault, verify cache files created
- Test error scenarios: invalid vault path, cache write failures, CLI exit codes

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Story created from Epic 3 requirements | Bob (Scrum Master) |
| 2025-10-29 | 1.1 | Enhanced with full TDD framework, SRP decomposition, linting checkpoints | QA Specialist |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5

### Debug Log References

N/A - No blocking issues encountered

### Completion Notes List

1. CommandOrchestrator.IndexVault() implemented delegating to VaultIndexer.Build()
2. IndexVault() added to CommandPort interface alongside NewNote()
3. CLI `index` command registered via buildIndexCommand() in CobraCLIAdapter
4. handleIndexCommand() calls CommandPort.IndexVault() and displays stats
5. displayIndexStats() formats output: Scanned, Indexed, Failures, Duration
6. Warning indicators for ValidationFailures and CacheFailures in output
7. Error handling: Non-zero exit code on indexing failure
8. Integration test: Executes `lithos index` against test vault, verifies cache files created
9. Documentation: README updated with `lithos index` command and rebuild workflow
10. FR9 compliance: Cache and query indices rebuilt on demand
11. Quality gates: All tests pass (unit + integration), linting clean, architecture compliant

### File List

#### Primary Implementation
- `/Users/jack/Documents/41_personal/lithos/internal/app/command/orchestrator.go` (IndexVault method)
- `/Users/jack/Documents/41_personal/lithos/internal/ports/api/command.go` (CommandPort interface update)
- `/Users/jack/Documents/41_personal/lithos/internal/adapters/api/cli/cobra.go` (buildIndexCommand, handleIndexCommand)

#### Test Files
- `/Users/jack/Documents/41_personal/lithos/internal/app/command/orchestrator_test.go` (IndexVault tests)
- `/Users/jack/Documents/41_personal/lithos/internal/adapters/api/cli/cobra_test.go` (index command tests)
- `/Users/jack/Documents/41_personal/lithos/tests/integration/index_command_test.go`

#### Documentation
- `/Users/jack/Documents/41_personal/lithos/README.md` (index command documentation)

## Testing

**Test Design:** `docs/qa/assessments/3-test-design-20251029.md`

## Testing

**Test Design:** `docs/qa/assessments/3.8-test-design-20251029.md`

## QA Results

### Test Coverage Summary

**Unit Tests - CommandOrchestrator.IndexVault():**
- ✅ Delegates to VaultIndexer.Build()
- ✅ Returns IndexStats with correct counts
- ✅ Logs summary statistics (scanned, indexed, failures, duration)
- ✅ Wraps errors with context on failure

**Unit Tests - CLI Index Command:**
- ✅ buildIndexCommand() registers command with correct structure
- ✅ handleIndexCommand() calls CommandPort.IndexVault()
- ✅ displayIndexStats() formats output with all fields
- ✅ Warning indicators shown for failures
- ✅ Error exit codes on indexing failure

**Integration Tests:**
- ✅ `lithos index` executes against test vault fixtures
- ✅ Cache files created in .lithos/cache/ directory
- ✅ CLI output shows correct statistics
- ✅ JSON cache files have valid Note structure
- ✅ Partial failures handled gracefully (some notes indexed despite errors)

**Quality Gates:**
- ✅ `go test ./internal/app/command` - All tests pass
- ✅ `go test ./internal/adapters/api/cli` - All tests pass
- ✅ `go test ./tests/integration` - All tests pass
- ✅ `golangci-lint run` - No warnings or errors
- ✅ Test coverage >85%
- ✅ Architecture compliant

### Key Validations

1. **CommandPort Extension:** IndexVault() method added alongside NewNote() in interface
2. **Use Case Orchestration:** CommandOrchestrator delegates to VaultIndexer without business logic
3. **CLI Integration:** `lithos index` command properly wired and registered
4. **Stats Display:** User-friendly output with counts, warnings, and duration
5. **FR9 Compliance:** Vault cache and query indices rebuilt on demand
6. **Error Handling:** Clear error messages with non-zero exit codes on failure
