# Story 3.8: FrontmatterService Integration

## Status

Draft

**Prerequisites:** Stories 3.1–3.7 (FrontmatterService complete)

## Story

**As a** developer,
**I want** VaultIndexer and QueryService to integrate with FrontmatterService,
**so that** frontmatter extraction and validation are part of the indexing workflow.

## Acceptance Criteria

1. VaultIndexer.Build() integrates FrontmatterService into the indexing workflow: SchemaEngine.Load() called first to ensure schemas are available → VaultScanner.ScanAll() → for each markdown file: FrontmatterService.Extract() → schema lookup via SchemaRegistryPort → FrontmatterService.Validate() → Note creation → cache persist → QueryService index update.

2. VaultIndexer constructor updated to inject FrontmatterService dependency and uses it during Build() workflow for .md files only (other file types skip frontmatter processing).

3. QueryService updated to support frontmatter-based queries: ByFrontmatter(field, value) method enables lookup by frontmatter field values from indexed Notes.

4. Note domain model updated to include validated Frontmatter field populated during indexing workflow, enabling QueryService frontmatter lookups.

5. Integration tests verify complete workflow: vault scan → frontmatter extract → validate → index → query by frontmatter field returns correct results.

6. Error handling preserves VaultIndexer resilience: frontmatter validation errors are logged and tracked in IndexStats but don't abort entire indexing process.

7. IndexStats extended to include frontmatter metrics: files processed, validation successes, validation failures, processing time.

8. Unit tests with fakes verify VaultIndexer calls FrontmatterService correctly and QueryService frontmatter lookups work with indexed data.

9. `golangci-lint run ./internal/app/vault ./internal/app/query` and `go test ./internal/app/vault ./internal/app/query` succeed.

10. Performance verified: frontmatter processing doesn't significantly impact indexing speed for typical vault sizes (target: <10% overhead).

## Tasks / Subtasks

- [ ] Task 1: Update VaultIndexer with FrontmatterService integration (AC: 1, 2, 6, 7)
  - [ ] RED: Write failing tests for FrontmatterService integration
    - [ ] Write test case expecting VaultIndexer constructor with FrontmatterService
    - [ ] Write test case for Build() workflow with frontmatter processing
    - [ ] Write test case for markdown file filtering (only .md files processed)
    - [ ] Write test case for validation error handling (logged, not abort)
    - [ ] Write test case for IndexStats frontmatter metrics
    - [ ] Verify tests fail (integration not implemented)
    - [ ] Run `go test ./internal/app/vault` and confirm failures
  - [ ] GREEN: Implement VaultIndexer integration
    - [ ] Update VaultIndexer constructor to inject FrontmatterService
    - [ ] Modify Build() method to include frontmatter workflow for .md files
    - [ ] Add frontmatter validation error handling with logging
    - [ ] Extend IndexStats with frontmatter metrics
    - [ ] Ensure non-.md files skip frontmatter processing
    - [ ] Run `go test ./internal/app/vault` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Extract frontmatter processing to helper method if Build() exceeds 25 lines
    - [ ] Add comprehensive GoDoc explaining integration workflow
    - [ ] Document error handling strategy for validation failures
    - [ ] Run `golangci-lint run --fix internal/app/vault`

- [ ] Task 2: Update Note domain model with Frontmatter field (AC: 4)
  - [ ] RED: Write failing tests for Note with Frontmatter
    - [ ] Write test case expecting Note.Frontmatter field
    - [ ] Write test case for Note creation with frontmatter data
    - [ ] Verify tests fail (field not added)
    - [ ] Run `go test ./internal/domain` and confirm failures
  - [ ] GREEN: Add Frontmatter field to Note
    - [ ] Add Frontmatter field to Note struct
    - [ ] Update Note constructors to accept frontmatter
    - [ ] Update any existing Note creation code
    - [ ] Run `go test ./internal/domain` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Add GoDoc for Frontmatter field explaining validation
    - [ ] Review Note model for consistency
    - [ ] Run `golangci-lint run --fix internal/domain`

- [ ] Task 3: Implement QueryService frontmatter queries (AC: 3)
  - [ ] RED: Write failing tests for ByFrontmatter method
    - [ ] Write test case expecting ByFrontmatter(field, value) method
    - [ ] Write test case for frontmatter field lookups
    - [ ] Write test case for multiple notes with same frontmatter value
    - [ ] Write test case for missing frontmatter field
    - [ ] Verify tests fail (method not implemented)
    - [ ] Run `go test ./internal/app/query` and confirm failures
  - [ ] GREEN: Implement ByFrontmatter method
    - [ ] Add ByFrontmatter(field string, value interface{}) ([]Note, error) method
    - [ ] Implement frontmatter field indexing in RefreshFromCache
    - [ ] Add frontmatter lookup logic using in-memory indices
    - [ ] Handle type-safe value comparisons
    - [ ] Run `go test ./internal/app/query` and verify tests pass
  - [ ] REFACTOR:
    - [ ] Extract frontmatter indexing to helper method
    - [ ] Add comprehensive GoDoc for ByFrontmatter method
    - [ ] Document performance characteristics
    - [ ] Run `golangci-lint run --fix internal/app/query`

- [ ] Task 4: Integration testing (AC: 5, 8)
  - [ ] RED: Write failing integration tests
    - [ ] Write test for complete workflow: scan → extract → validate → index → query
    - [ ] Write test with fake SchemaEngine, VaultScanner, FrontmatterService
    - [ ] Write test for end-to-end frontmatter queries
    - [ ] Verify tests fail (integration not complete)
    - [ ] Run integration tests and confirm failures
  - [ ] GREEN: Implement integration
    - [ ] Create comprehensive integration test suite
    - [ ] Test with real components where possible
    - [ ] Verify frontmatter queries return correct results
    - [ ] Test error scenarios and resilience
    - [ ] Run integration tests and verify pass
  - [ ] REFACTOR:
    - [ ] Clean up test helpers and fixtures
    - [ ] Document integration test patterns
    - [ ] Verify test coverage and performance

- [ ] Task 5: Performance verification (AC: 10)
  - [ ] Benchmark frontmatter processing overhead
  - [ ] Test with various vault sizes (small, medium, large)
  - [ ] Measure indexing time with/without frontmatter processing
  - [ ] Verify <10% overhead target is met
  - [ ] Document performance characteristics

- [ ] Task 6: Quality gates (AC: 9)
  - [ ] Run `go test ./internal/app/vault ./internal/app/query` and verify 100% pass
  - [ ] Run `golangci-lint run ./internal/app/vault ./internal/app/query` and fix issues
  - [ ] Verify integration test coverage
  - [ ] Document integration patterns

## Dev Notes

### Integration Workflow

The FrontmatterService integration follows this sequence in VaultIndexer.Build():

```go
func (indexer *VaultIndexer) Build(ctx context.Context) (IndexStats, error) {
    // 1. Load schemas first
    if err := indexer.schemaEngine.Load(ctx); err != nil {
        return stats, err
    }

    // 2. Scan vault files
    vaultFiles, err := indexer.vaultScanner.ScanAll(ctx)
    if err != nil {
        return stats, err
    }

    // 3. Process each file
    for _, vf := range vaultFiles {
        // Skip non-markdown files
        if vf.Ext != ".md" {
            continue
        }

        // 4. Extract frontmatter
        frontmatter, err := indexer.frontmatterService.Extract(vf.Content)
        if err != nil {
            indexer.logValidationError(vf.Path, err)
            stats.ValidationFailures++
            continue // Don't abort indexing
        }

        // 5. Get schema and validate
        schema, err := indexer.schemaEngine.GetSchema(frontmatter.FileClass)
        if err != nil {
            indexer.logValidationError(vf.Path, err)
            stats.ValidationFailures++
            continue
        }

        if err := indexer.frontmatterService.Validate(ctx, frontmatter, schema); err != nil {
            indexer.logValidationError(vf.Path, err)
            stats.ValidationFailures++
            continue
        }

        // 6. Create Note with validated frontmatter
        note := Note{
            ID: deriveNoteID(vf.Path),
            Frontmatter: frontmatter,
            // ... other fields
        }

        // 7. Cache and index
        indexer.cacheNote(note)
        indexer.queryService.AddToIndex(note)
        stats.ValidationSuccesses++
    }

    return stats, nil
}
```

### Error Handling Strategy

- **Resilient Processing**: Frontmatter validation errors don't abort entire indexing
- **Comprehensive Logging**: All validation errors logged with file path and reason
- **Metrics Tracking**: IndexStats includes frontmatter processing metrics
- **Graceful Degradation**: Files with invalid frontmatter are skipped but indexing continues

### QueryService Frontmatter Lookups

```go
// ByFrontmatter enables queries like:
// notes := queryService.ByFrontmatter("author", "John Doe")
// notes := queryService.ByFrontmatter("tags", "project-x")
// notes := queryService.ByFrontmatter("status", "draft")
```

This enables template functions and interactive queries based on frontmatter fields.

## Change Log

| Date       | Version | Description                                           | Author     |
| ---------- | ------- | ----------------------------------------------------- | ---------- |
| 2025-10-31 | 1.0     | Created integration story for FrontmatterService with VaultIndexer and QueryService | Sarah (PO) |
