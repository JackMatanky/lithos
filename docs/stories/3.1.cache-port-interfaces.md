# Story 3.1: Define Cache Port Interfaces (CacheWriterPort and CacheReaderPort)

## Status

Draft

## Story

**As a** developer,
**I want** CacheWriterPort and CacheReaderPort defined per the architecture,
**so that** cache operations follow the CQRS pattern with clear contracts.

## Acceptance Criteria

**CacheWriterPort Interface:**

- 3.1.1: Create `internal/ports/spi/cache.go` with CacheWriterPort interface:
  - Method: `Persist(ctx context.Context, note Note) error` - Persist note to cache
  - Method: `Delete(ctx context.Context, id NoteID) error` - Remove note from cache
  - GoDoc: Reference error wrapping requirements from `docs/architecture/error-handling-strategy.md` and FR9 in `docs/prd/requirements.md`

**CacheReaderPort Interface:**

- 3.1.2: Add CacheReaderPort interface to `internal/ports/spi/cache.go`:
  - Method: `Read(ctx context.Context, id NoteID) (Note, error)` - Fetch single note from cache
  - Method: `List(ctx context.Context) ([]Note, error)` - List all cached notes
  - GoDoc: Reference error wrapping requirements and preservation of unknown JSON fields (FR6)

**Documentation:**

- 3.1.3: Port definitions explicitly state thread-safety expectations:
  - Document that implementations must be safe for concurrent reads
  - Document cache directory usage (`.lithos/cache/` by default from Config.CacheDir)
  - Reference CQRS pattern separation between write and read concerns

**Testing:**

- 3.1.4: Create `internal/ports/spi/cache_test.go` with interface compliance tests:
  - Define mock implementations of CacheWriterPort and CacheReaderPort
  - Test that mock implementations satisfy interface contracts
  - Verify context cancellation is properly supported in signatures

- 3.1.5: All linting passes: `golangci-lint run ./internal/ports/spi`

- 3.1.6: Committed with message: `feat(ports): define CacheWriterPort and CacheReaderPort interfaces per CQRS pattern`

## Tasks / Subtasks

- [ ] Task 1: Define CacheWriterPort interface (AC: 3.1.1)
  - [ ] RED: Write failing test for CacheWriterPort interface compliance
    - [ ] Write test case in `internal/ports/spi/cache_test.go`
    - [ ] Create MockCacheWriter struct
    - [ ] Verify interface compliance with type assertion: `var _ CacheWriterPort = (*MockCacheWriter)(nil)`
    - [ ] Run `go test ./internal/ports/spi` and confirm compilation failure
  - [ ] RED: Write failing test for Persist method signature
    - [ ] Write test verifying context.Context is first parameter
    - [ ] Write test verifying Note parameter and error return
    - [ ] Run `go test ./internal/ports/spi` and confirm failure
  - [ ] RED: Write failing test for Delete method signature
    - [ ] Write test verifying context.Context is first parameter
    - [ ] Write test verifying NoteID parameter and error return
    - [ ] Run `go test ./internal/ports/spi` and confirm failure
  - [ ] GREEN: Create `internal/ports/spi/cache.go`
    - [ ] Add package comment explaining cache port pattern
    - [ ] Define CacheWriterPort interface with Persist and Delete methods
    - [ ] Run `go test ./internal/ports/spi` and verify all tests pass
  - [ ] REFACTOR:
    - [ ] Add comprehensive GoDoc to CacheWriterPort interface:
      - [ ] Explain CQRS write-side responsibility
      - [ ] Reference atomic write requirements
      - [ ] Reference FR9 error wrapping requirements
      - [ ] Document thread-safety expectations
    - [ ] Add comprehensive GoDoc to Persist method:
      - [ ] Explain atomic write semantics
      - [ ] Document cache directory creation behavior
      - [ ] Reference error handling strategy
    - [ ] Add comprehensive GoDoc to Delete method:
      - [ ] Explain idempotent delete semantics
      - [ ] Document behavior when file doesn't exist
      - [ ] Reference error handling strategy
    - [ ] Run `golangci-lint run --fix internal/ports/spi`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/ports/spi` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/ports/spi`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 2: Define CacheReaderPort interface (AC: 3.1.2)
  - [ ] RED: Write failing test for CacheReaderPort interface compliance
    - [ ] Create MockCacheReader struct in cache_test.go
    - [ ] Verify interface compliance with type assertion: `var _ CacheReaderPort = (*MockCacheReader)(nil)`
    - [ ] Run `go test ./internal/ports/spi` and confirm compilation failure
  - [ ] RED: Write failing test for Read method signature
    - [ ] Write test verifying context.Context is first parameter
    - [ ] Write test verifying NoteID parameter, Note and error return
    - [ ] Run `go test ./internal/ports/spi` and confirm failure
  - [ ] RED: Write failing test for List method signature
    - [ ] Write test verifying context.Context is first parameter
    - [ ] Write test verifying []Note and error return
    - [ ] Run `go test ./internal/ports/spi` and confirm failure
  - [ ] GREEN: Add CacheReaderPort interface to cache.go
    - [ ] Define CacheReaderPort interface with Read and List methods
    - [ ] Run `go test ./internal/ports/spi` and verify all tests pass
  - [ ] REFACTOR:
    - [ ] Add comprehensive GoDoc to CacheReaderPort interface:
      - [ ] Explain CQRS read-side responsibility
      - [ ] Reference FR6 unknown field preservation
      - [ ] Document thread-safety expectations for concurrent reads
      - [ ] Explain optional memoization strategy
    - [ ] Add comprehensive GoDoc to Read method:
      - [ ] Document return of ErrNotFound when note doesn't exist
      - [ ] Explain unknown field preservation requirement
      - [ ] Reference error handling strategy
    - [ ] Add comprehensive GoDoc to List method:
      - [ ] Explain return of all cached notes
      - [ ] Document partial failure tolerance (warnings, not errors)
      - [ ] Reference FR6 preservation requirement
    - [ ] Run `golangci-lint run --fix internal/ports/spi`
    - [ ] Fix ALL linter warnings without using nolint
    - [ ] Run `go test ./internal/ports/spi` to verify refactoring didn't break tests
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/ports/spi`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 3: Add comprehensive port documentation (AC: 3.1.3)
  - [ ] Add package-level comment explaining cache port pattern:
    - [ ] Explain CQRS separation (write vs read)
    - [ ] Reference architecture components document
    - [ ] Document cache directory structure
  - [ ] Document thread-safety requirements in both interfaces
  - [ ] Document cache directory usage from Config.CacheDir
  - [ ] Add code examples in GoDoc showing typical usage patterns
  - [ ] Reference error wrapping expectations for implementations
  - [ ] Document context cancellation requirements
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/ports/spi`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 4: Create mock implementations for testing (AC: 3.1.4)
  - [ ] RED: Write failing test using MockCacheWriter
    - [ ] Create test that exercises mock Persist and Delete
    - [ ] Verify mock behavior is controllable via function fields
    - [ ] Run `go test ./internal/ports/spi` and confirm test logic works
  - [ ] RED: Write failing test using MockCacheReader
    - [ ] Create test that exercises mock Read and List
    - [ ] Verify mock behavior is controllable via function fields
    - [ ] Run `go test ./internal/ports/spi` and confirm test logic works
  - [ ] GREEN: Implement MockCacheWriter in cache_test.go
    - [ ] Add PersistFunc and DeleteFunc fields
    - [ ] Implement Persist method delegating to PersistFunc
    - [ ] Implement Delete method delegating to DeleteFunc
    - [ ] Add compile-time interface check
    - [ ] Run `go test ./internal/ports/spi` and verify tests pass
  - [ ] GREEN: Implement MockCacheReader in cache_test.go
    - [ ] Add ReadFunc and ListFunc fields
    - [ ] Implement Read method delegating to ReadFunc
    - [ ] Implement List method delegating to ListFunc
    - [ ] Add compile-time interface check
    - [ ] Run `go test ./internal/ports/spi` and verify tests pass
  - [ ] GREEN: Add tests verifying context.Context is first parameter in all methods
    - [ ] Test CacheWriterPort methods accept context
    - [ ] Test CacheReaderPort methods accept context
    - [ ] Verify context can be used for cancellation
  - [ ] REFACTOR:
    - [ ] Add GoDoc to MockCacheWriter explaining test usage
    - [ ] Add GoDoc to MockCacheReader explaining test usage
    - [ ] Add example test showing typical mock usage patterns
    - [ ] Run `golangci-lint run --fix internal/ports/spi`
    - [ ] Fix ALL linter warnings without using nolint
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/ports/spi`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 5: Run quality gates (AC: 3.1.5)
  - [ ] Run `go test ./internal/ports/spi` and verify 100% pass
  - [ ] Run `golangci-lint run --fix internal/ports/spi` and fix any issues
  - [ ] Verify all interface documentation is complete
  - [ ] Verify all GoDoc follows standards (complete sentences, examples where helpful)
  - [ ] Linting checkpoint:
    - [ ] Run `golangci-lint run --fix internal/ports/spi`
    - [ ] Fix ALL warnings (no nolint unless absolutely necessary)
    - [ ] Document any unavoidable nolint with clear justification

- [ ] Task 6: Commit changes (AC: 3.1.6)
  - [ ] Review all changes
  - [ ] Stage files: `git add internal/ports/spi/cache.go internal/ports/spi/cache_test.go`
  - [ ] Commit with message: `feat(ports): define CacheWriterPort and CacheReaderPort interfaces per CQRS pattern`

## Dev Notes

### Architecture Alignment (v0.6.8)

From `docs/architecture/components.md#cachewriterport` and `#cachereaderport`:

**CQRS Pattern Separation:**

The cache ports implement Command Query Responsibility Segregation (CQRS) pattern with clear separation:

- **CacheWriterPort (Write Side):** Handles cache persistence concerns (atomicity, consistency, error handling)
- **CacheReaderPort (Read Side):** Handles cache retrieval concerns (lazy loading, query performance, memoization)

This separation enables:

- Independent optimization (write uses atomic writes, read can add caching layers)
- Interface Segregation Principle (ISP) compliance - adapters implement only what they need
- Different failure modes (write failure = hard error, read failure = cache miss)

### CacheWriterPort Interface

From `docs/architecture/components.md#cachewriterport`:

**Purpose:** Persist indexed notes to on-disk cache (CQRS write side).

**Key Interfaces:**

- `Persist(ctx context.Context, note Note) error` - Persist note to cache with atomic guarantees
- `Delete(ctx context.Context, id NoteID) error` - Remove note from cache

**Implementation Expectations:**

- Atomic writes using `moby/sys/atomicwriter` (temp + rename pattern)
- Cache directory from Config.CacheDir (default: `.lithos/cache/`)
- One JSON file per note (filename: `{NoteID}.json`)
- Wrap filesystem errors with structured error types per error handling strategy
- Thread-safe for concurrent operations

**Error Handling:**

- Wrap all errors with context (operation, path, note ID)
- Use structured error types from `internal/shared/errors`
- Preserve error chains with `fmt.Errorf("%w", err)`

### CacheReaderPort Interface

From `docs/architecture/components.md#cachereaderport`:

**Purpose:** Read indexed notes from on-disk cache (CQRS read side).

**Key Interfaces:**

- `Read(ctx context.Context, id NoteID) (Note, error)` - Fetch single note from cache
- `List(ctx context.Context) ([]Note, error)` - List all cached notes

**Implementation Expectations:**

- JSON deserialization with `encoding/json`
- Preserve unknown JSON fields (FR6 requirement)
- Optional in-memory memoization with `sync.RWMutex`
- Lazy loading for performance
- Thread-safe for concurrent reads

**Unknown Field Preservation (FR6):**

- Implementations MUST preserve all JSON fields during deserialization
- Use `json.Unmarshal` with `map[string]interface{}` for flexible field handling
- Unknown fields in frontmatter must round-trip through cache unchanged
- This supports user-defined fields not in schema definitions

### Cache Directory Structure

From `docs/architecture/components.md` and `docs/architecture/data-models.md#config`:

**Default Cache Location:** `{VaultPath}/.lithos/cache/`

**Structure:**

```
.lithos/
  cache/
    {noteid1}.json
    {noteid2}.json
    ...
```

**File Format:** JSON serialization of Note model (NoteID + Frontmatter)

**Adapter Responsibilities:**

- Create cache directory if missing (mkdir -p semantics)
- Handle file paths using `filepath.Join` for OS compatibility
- Use atomic writes (temp + rename) to prevent partial writes
- Ignore cache directory during vault scanning (VaultReaderPort)

### Thread Safety Requirements

**Concurrent Access Patterns:**

- Multiple readers may access cache simultaneously (QueryService, FrontmatterService)
- Writers and readers may operate concurrently (indexing + template rendering)
- Implementations MUST be thread-safe for these patterns

**Implementation Strategies:**

- Filesystem operations are naturally concurrent (OS-level locking)
- Optional in-memory caches require `sync.RWMutex`
- Atomic writes prevent partial reads

### Context Cancellation Support

From Go best practices and `docs/architecture/coding-standards.md`:

**All methods accept context.Context as first parameter:**

- Enables cancellation of long-running operations
- Supports timeout enforcement
- Provides trace context for logging

**Implementation Requirements:**

- Check `ctx.Err()` before starting operations
- Respect cancellation during I/O operations
- Return `ctx.Err()` if context is cancelled

### Error Wrapping Strategy

From `docs/architecture/error-handling-strategy.md`:

**Structured Error Types:**

- Use domain-specific error types from `internal/shared/errors`
- Wrap infrastructure errors with context (operation, path, note ID)
- Preserve error chains for debugging

**Example Error Wrapping:**

```go
if err := os.WriteFile(path, data, 0644); err != nil {
    return fmt.Errorf("cache write failed for note %s at %s: %w", noteID, path, err)
}
```

### Functional Requirements Traceability

**FR6: Preserve Unknown Fields**

- CacheReaderPort implementations MUST preserve all JSON fields
- Unknown frontmatter fields must round-trip unchanged
- Enables user-defined fields not in schemas

**FR9: Error Context**

- All errors must include operation context (persist, delete, read, list)
- Include resource identifiers (note ID, file path) in error messages
- Preserve error chains with `%w` for debugging

### YAGNI Decisions

From `docs/architecture/components.md`:

**No separate FileWriterPort/FileReaderPort:**

- Cache adapters use Go stdlib (`os.ReadFile`, `os.WriteFile`, `atomicwriter.WriteFile`) directly
- No need for abstraction - we don't have multiple file storage implementations for MVP
- If future needs arise (S3, HTTP, embedded), ports can be added then
- Keeps architecture simple and avoids premature abstraction

### Testing Strategy

From `docs/architecture/testing-strategy.md`:

**Interface Compliance Tests:**

- Mock implementations verify interface contracts
- Type assertions ensure mocks satisfy interfaces
- Test context.Context as first parameter in all methods

**Test Organization:**

- Interface definitions: `internal/ports/spi/cache.go`
- Interface tests: `internal/ports/spi/cache_test.go`
- Adapter implementation tests: `internal/adapters/spi/cache/*_test.go` (Story 3.2)

**Example Mock Implementation:**

```go
type MockCacheWriter struct {
    PersistFunc func(ctx context.Context, note Note) error
    DeleteFunc  func(ctx context.Context, id NoteID) error
}

func (m *MockCacheWriter) Persist(ctx context.Context, note Note) error {
    if m.PersistFunc != nil {
        return m.PersistFunc(ctx, note)
    }
    return nil
}

// Compile-time interface compliance check
var _ CacheWriterPort = (*MockCacheWriter)(nil)
```

### Port Interface Documentation Standards

**Since this story defines interfaces (not implementations), special documentation requirements apply:**

**Interface Documentation Must Include:**

- Purpose statement explaining the port's role in hexagonal architecture
- CQRS pattern designation (write-side or read-side)
- Thread-safety expectations for implementations
- Error handling requirements (what errors to return, how to wrap)
- Functional requirements traceability (FR6, FR9 references)
- Context cancellation behavior expectations

**Method Documentation Must Include:**

- Parameter descriptions (especially context.Context usage)
- Return value descriptions (including error conditions)
- Behavioral contracts (idempotency, atomicity, etc.)
- Examples of typical error wrapping patterns
- References to related architecture documentation

**Example GoDoc Pattern:**

```go
// CacheWriterPort defines the CQRS write-side contract for cache persistence.
// Implementations must provide atomic write guarantees and thread-safe concurrent
// access. All errors must be wrapped per error-handling-strategy.md with operation
// context and resource identifiers (FR9).
//
// See docs/architecture/components.md#cachewriterport for implementation guidance.
type CacheWriterPort interface {
    // Persist atomically writes note to cache using temp-file + rename pattern.
    // Creates cache directory if missing. Overwrites existing cache entry.
    // Returns error wrapped with operation context if write fails.
    //
    // Thread-safe: Safe for concurrent calls.
    // Context: Respects ctx cancellation, returns ctx.Err() if cancelled.
    Persist(ctx context.Context, note Note) error

    // Delete removes note from cache. Idempotent: returns nil if note doesn't exist.
    // Returns error wrapped with operation context if deletion fails (e.g., permissions).
    //
    // Thread-safe: Safe for concurrent calls.
    // Context: Respects ctx cancellation, returns ctx.Err() if cancelled.
    Delete(ctx context.Context, id NoteID) error
}
```

**No TDD for Interface Definitions:**
Port interfaces are contracts, not implementations. TDD applies to:

- Mock implementations (verify they satisfy interface)
- Interface compliance tests (verify method signatures)
- Adapter implementations (Story 3.2 - full TDD workflow)

But NOT to the interface definitions themselves.

### File Locations

From `docs/architecture/source-tree.md`:

**Port Definitions:**

- `internal/ports/spi/cache.go` - CacheWriterPort and CacheReaderPort interfaces
- `internal/ports/spi/cache_test.go` - Interface compliance tests and mocks

**Adapter Implementations (Story 3.2):**

- `internal/adapters/spi/cache/json_writer.go` - JSONCacheWriteAdapter
- `internal/adapters/spi/cache/json_reader.go` - JSONCacheReadAdapter
- `internal/adapters/spi/cache/helper.go` - Shared helpers (path construction, directory creation)

### Common Pitfalls to Avoid

1. **DO NOT add business logic to port definitions** - Ports are pure interfaces
2. **DO ensure context.Context is first parameter** - Go best practice
3. **DO document thread-safety requirements** - Implementations must know expectations
4. **DO reference functional requirements (FR6, FR9)** - Traceability to PRD
5. **DO keep interfaces focused** - CQRS separation, ISP compliance
6. **DO NOT create implementations in this story** - Only interfaces and mocks

## Change Log

| Date       | Version | Description                                                                                           | Author             |
| ---------- | ------- | ----------------------------------------------------------------------------------------------------- | ------------------ |
| 2025-10-28 | 1.0     | Story created from Epic 3 requirements                                                                | Bob (Scrum Master) |
| 2025-10-28 | 1.1     | Applied quality fixes: enhanced TDD tasks, linting checkpoints, comprehensive documentation standards | QA Specialist      |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent during implementation_

### Debug Log References

_To be completed by dev agent during implementation_

### Completion Notes List

_To be completed by dev agent during implementation_

### File List

_To be completed by dev agent during implementation_

## Testing

**Test Design:** `docs/qa/assessments/3.1-test-design-20251029.md`

## QA Results

_To be completed by QA agent after implementation_
