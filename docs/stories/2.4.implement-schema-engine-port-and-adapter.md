# Story 2.4: Implement Schema Engine Port and Adapter

## Status

Approved

## Story

As a developer, I want to implement the SchemaEnginePort and SchemaLoaderAdapter, so that schemas can be loaded from JSON files following the architecture.

## Acceptance Criteria

2.4.1: `internal/ports/spi/` contains SchemaEnginePort interface with LoadSchemas and LoadPropertyBank methods.
2.4.2: `internal/adapters/spi/schema/` contains SchemaLoaderAdapter implementing SchemaEnginePort.
2.4.3: Adapter scans for `.json` files in `schemas/` directory per `docs/architecture/tech-stack.md#json-processing`.
2.4.4: Property bank files are loaded from `schemas/properties/` directory with `$ref` resolution.
2.4.5: JSON parsing uses Go stdlib `encoding/json` with structured error handling.

## Tasks / Subtasks

- [ ] Task 1: Define SchemaEnginePort interface (AC: 2.4.1)
  - [ ] Create `internal/ports/spi/schema.go` with SchemaEnginePort interface
  - [ ] Define LoadSchemas method: `LoadSchemas(ctx context.Context) ([]Schema, error)` - returns domain Schema objects
  - [ ] Define LoadPropertyBank method: `LoadPropertyBank(ctx context.Context) (PropertyBank, error)` - returns domain PropertyBank
  - [ ] Remove separate DTO types - adapter should return domain objects directly
  - [ ] Ensure interface follows hexagonal architecture patterns per components.md
  - [ ] Document adapter responsibility for JSON parsing and domain object instantiation

- [ ] Task 2: Implement SchemaLoaderAdapter - JSON parsing and domain object creation (AC: 2.4.2, 2.4.3)
  - [ ] Create `internal/adapters/spi/schema/loader_adapter.go` implementing SchemaEnginePort
  - [ ] Implement constructor with dependency injection for FileSystemPort and ConfigPort
  - [ ] Implement LoadSchemas method:
    - Use ConfigPort.Config() to get schema directory path
    - Use FileSystemPort.Walk() to scan for .json files in schemas/ directory
    - Parse each JSON file using Go stdlib encoding/json into intermediate DTOs
    - Use domain constructors from Stories 2.2 and 2.3 to create Schema/Property objects
    - Handle PropertySpec discriminator logic at adapter level (determine type from JSON "type" field)
    - Return []Schema with fully constructed domain objects
    - Handle file access errors with SchemaError wrapping
  - [ ] Add security validation for file paths within configured schema directory bounds
  - [ ] Follow adapter patterns from existing adapters (LocalFileSystemAdapter, ConfigViperAdapter)

- [ ] Task 3: Implement property bank loading with $ref resolution (AC: 2.4.4)
  - [ ] Implement LoadPropertyBank method scanning schemas/properties/ directory using FileSystemPort.Walk
  - [ ] Parse property bank JSON files using Go stdlib encoding/json
  - [ ] Implement $ref resolution algorithm at adapter level:
    - Parse JSON and detect $ref attributes using JSON pointer syntax (#/properties/propertyId)
    - Resolve references by looking up property ID in loaded property bank registry
    - Substitute reference with actual property definition before creating domain objects
    - Handle nested references and circular reference detection (max depth: 10 levels)
    - Use domain PropertyBank constructor to create final domain object
  - [ ] Return PropertyBank domain object for SchemaRegistry consumption
  - [ ] Add specific $ref resolution examples:
    - Simple reference: `{"$ref": "#/properties/common-email"}` → resolved to actual EmailProperty
    - Nested reference: property bank containing properties that reference other properties
    - Cross-file reference: `{"$ref": "common.json#/properties/timestamp"}`

- [ ] Task 4: Add JSON processing and error handling (AC: 2.4.5)
  - [ ] Use Go stdlib encoding/json for schema file parsing per tech-stack.md
  - [ ] Implement PropertySpec discriminator handling at adapter level based on JSON "type" field
  - [ ] Implement structured error handling using shared errors package:
    - SchemaError for schema loading/resolution errors (schema name, message)
    - FileSystemError for file I/O failures (operation, path, cause)
    - ValidationError for malformed schema structure
    - Use error wrapping functions: Wrap(), WrapWithContext()
  - [ ] Handle missing files with clear error messages including file path context
  - [ ] Validate JSON schema structure and provide detailed error messages for malformed JSON
  - [ ] Add comprehensive security validation:
    - Path traversal prevention: reject paths containing ".." or absolute paths
    - Directory bounds checking: ensure all file access is within configured schema directory
    - File extension validation: only allow .json files
    - File size limits: reject files larger than 10MB to prevent DoS
    - Input sanitization: validate JSON structure before parsing
  - [ ] Add enhanced error messaging with examples:
    - "Schema file 'user.json' has malformed JSON at line 15: missing closing brace"
    - "Property reference '$ref: #/properties/invalid-prop' not found in property bank"
    - "Circular reference detected: user → profile → user (max depth: 10)"

- [ ] Task 5: Add comprehensive testing (AC: 2.4.1, 2.4.2, 2.4.3, 2.4.4, 2.4.5)
  - [ ] Create `internal/adapters/spi/schema/loader_adapter_test.go` with table-driven unit tests
  - [ ] Add tests with mocked FileSystemPort and ConfigPort dependencies using test doubles
  - [ ] Test scenarios include:
    - Successful schema loading from valid JSON files with domain object validation
    - Property bank loading with $ref resolution and PropertyBank domain object creation
    - PropertySpec discriminator handling for all concrete types (String, Number, Date, File, Bool)
    - Error handling for malformed JSON files with specific error validation
    - Missing file and directory access error handling
    - Security validation: directory traversal prevention, path validation, file size limits
    - Domain constructor integration tests (verify adapter creates valid domain objects)
  - [ ] Add integration tests with actual JSON test fixtures in testdata/
  - [ ] Test $ref resolution with various reference patterns and circular reference detection
  - [ ] Add performance benchmarking tests:
    - Benchmark loading 100+ schema files (target: <100ms total)
    - Benchmark $ref resolution with 1000+ properties (target: <50ms)
    - Memory usage validation for large property banks (target: <50MB)
  - [ ] Add concurrent access testing:
    - Multiple goroutines loading schemas simultaneously
    - Race condition detection using `go test -race`
    - Thread-safety validation for property bank resolution
  - [ ] Ensure ≥85% test coverage for adapter implementations per testing-strategy.md

## Dev Notes

**Previous Story Insights:**
- Stories 2.1-2.3 will implement Config, Schema, and Property models providing foundation
- This story builds on existing FileSystemPort and ConfigPort from Epic 1
- Hexagonal architecture patterns established in Story 1.14/1.15 provide guidance

**Data Models:**
- SchemaEnginePort interface defined per `docs/architecture/components.md#schemaengineport`
- Returns domain objects directly: Schema and PropertyBank (no separate DTO types)
- SchemaLoaderAdapter implements port using filesystem abstractions per components.md
- Property bank support with $ref resolution using JSON pointer syntax per data-models.md
- Integration with Schema and Property domain models from Stories 2.2 and 2.3 via constructors
- Adapter handles JSON parsing and PropertySpec discriminator logic before domain object creation

**JSON Schema Format Examples:**
```json
// schemas/user.json - Basic schema file
{
  "name": "user",
  "extends": "base",
  "excludes": ["internal_id"],
  "properties": {
    "email": {
      "type": "string",
      "required": true,
      "pattern": "^[\\w\\.-]+@[\\w\\.-]+\\.[A-Za-z]{2,}$"
    },
    "profile": {
      "$ref": "#/properties/user-profile"
    }
  }
}

// schemas/properties/common.json - Property bank file
{
  "properties": {
    "user-profile": {
      "type": "object",
      "required": false,
      "properties": {
        "display_name": {"type": "string", "required": true},
        "avatar_url": {"type": "string", "required": false}
      }
    },
    "timestamp": {
      "type": "date",
      "required": true,
      "format": "RFC3339"
    }
  }
}
```

**$ref Resolution Examples:**
- Simple reference: `{"$ref": "#/properties/common-email"}` → resolved to EmailProperty definition
- Cross-file reference: `{"$ref": "common.json#/properties/timestamp"}` → loads from common.json property bank
- Nested reference chain: property → bank → property (with circular detection)

**API Specifications:**
- SchemaEnginePort interface per components.md with method signatures returning domain objects:
  - `LoadSchemas(ctx context.Context) ([]Schema, error)` - Load schema files from schemas/ directory as domain objects
  - `LoadPropertyBank(ctx context.Context) (PropertyBank, error)` - Load property banks from schemas/properties/ as domain object
- SchemaLoaderAdapter implements SchemaEnginePort using filesystem abstractions per components.md
- Integration with SchemaRegistry domain service per components.md dependency chain
- Error handling follows shared errors package with SchemaError, FileSystemError, and ValidationError types

**Component Specifications:**
- SchemaEnginePort located in `internal/ports/spi/schema.go`
- SchemaLoaderAdapter located in `internal/adapters/spi/schema/loader_adapter.go`
- Follows hexagonal architecture with port interface and concrete adapter

**File Locations:**
- Port interface: `internal/ports/spi/schema.go` (create new)
- Adapter implementation: `internal/adapters/spi/schema/loader_adapter.go` (create new)
- Tests: `internal/adapters/spi/schema/loader_adapter_test.go` (create new)

**Testing Requirements:**
- Unit tests for SchemaLoaderAdapter with mocked FileSystemPort and ConfigPort dependencies
- Unit tests for SchemaEnginePort interface compliance and method signatures
- Integration tests for schema loading from actual JSON files with various structures
- Error handling tests for malformed JSON, missing files, and directory access errors
- $ref resolution tests for property bank references including circular reference detection
- Security tests for path validation and directory traversal prevention
- Performance tests for large schema files and property bank resolution
- Concurrent access tests for thread-safe SchemaRegistry integration

**Technical Constraints:**
- Follow hexagonal architecture: port in SPI ports, adapter in SPI adapters per components.md
- Use dependency injection for FileSystemPort and ConfigPort following established patterns
- Use Go stdlib `encoding/json` for parsing with structured error handling per tech-stack.md
- Support $ref resolution in property banks using JSON pointer syntax per data-models.md
- Follow coding-standards.md: Go 1.23+ features, Result pattern for port boundaries if needed
- Ensure thread-safe implementation for concurrent SchemaRegistry usage
- Use shared errors package for consistent error types (SchemaError, FileSystemError)
- Implement comprehensive security validation for file path access within configured schema directory bounds

**Security Requirements & Threat Model:**
- **Path Traversal Prevention**: Reject any paths containing "..", absolute paths, or symbolic links
- **Directory Bounds Enforcement**: All file access must be within configured schema directory tree
- **File Type Validation**: Only accept .json files, reject executable or suspicious extensions
- **Input Size Limits**: Reject JSON files larger than 10MB to prevent resource exhaustion attacks
- **Malicious JSON Protection**: Validate JSON structure before parsing to prevent parser exploits
- **Resource Limits**: Limit $ref resolution depth (max 10 levels) to prevent infinite recursion
- **Error Information Leakage**: Sanitize error messages to avoid exposing internal file system structure

**Source References:**
- [Architecture: docs/architecture/components.md#schemaengineport] - Interface specification and method signatures
- [Architecture: docs/architecture/components.md#schemaloaderadapter] - Adapter implementation requirements
- [Architecture: docs/architecture/components.md#schemaregistry] - SchemaRegistry domain service integration
- [Architecture: docs/architecture/data-models.md#propertybank] - $ref resolution algorithm specification
- [Architecture: docs/architecture/source-tree.md] - File location in internal/ports/spi/ and internal/adapters/spi/
- [Architecture: docs/architecture/tech-stack.md#json-processing] - Go stdlib encoding/json usage
- [Architecture: docs/architecture/coding-standards.md#core-standards] - Go 1.23+ standards and Result patterns
- [Architecture: docs/architecture/testing-strategy.md#unit-tests] - Testing patterns and coverage targets
- [Architecture: docs/architecture/components.md#error-package] - Shared error types and handling patterns

### Testing

**Testing Strategy:**

- **Unit Tests**: Test SchemaLoaderAdapter with mocked FileSystemPort and ConfigPort dependencies
- **Integration Tests**: Test schema loading from actual JSON files with domain object validation
- **Error Tests**: Test error handling for malformed JSON, missing files, and security violations
- **$ref Resolution Tests**: Test property bank references including circular reference detection
- **PropertySpec Tests**: Test discriminator handling for all concrete types (String, Number, Date, File, Bool)
- **Security Tests**: Test path validation and directory traversal prevention
- **Performance Tests**: Test large schema files and concurrent loading scenarios

**Performance Benchmarks & Targets:**

- **Schema Loading Performance**:
  - Target: Load 100 schema files in <100ms
  - Benchmark: `BenchmarkSchemaLoading100Files`
  - Memory: <50MB total allocation for typical schema set

- **$ref Resolution Performance**:
  - Target: Resolve 1000 property references in <50ms
  - Benchmark: `BenchmarkPropertyBankResolution1000Refs`
  - Circular detection: <1ms for 10-level deep chains

- **Concurrent Access Performance**:
  - Target: 10 concurrent schema loads without performance degradation
  - Benchmark: `BenchmarkConcurrentSchemaLoading`
  - Race condition testing: `go test -race -count=100`

**Error Message Examples:**

Implement specific, helpful error messages:
- **Malformed JSON**: "Schema file 'user.json' contains invalid JSON at line 15, column 8: expected ',' or '}' after object property"
- **Missing $ref**: "Property reference '$ref: #/properties/invalid-email' not found in property bank 'common.json'"
- **Circular Reference**: "Circular reference detected in property chain: user-profile → contact-info → user-profile (max depth: 10 exceeded)"
- **Security Violation**: "Schema file path '../../../etc/passwd' is outside allowed directory bounds"
- **File Size**: "Schema file 'large-schema.json' (15.2MB) exceeds maximum allowed size (10MB)"

**Testing Standards:**

- Follow testing patterns from `docs/architecture/testing-strategy.md`
- Unit tests co-located with implementation files (`*_test.go`)
- Use table-driven tests for multiple scenarios
- Mock dependencies (FileSystemPort, ConfigPort) for isolated unit testing
- Integration tests with actual JSON test fixtures in `testdata/`
- Test both success and failure cases with specific error validation
- Target ≥85% coverage for adapter implementations per testing-strategy.md

**Acceptance Criteria Validation:**

Each test suite must validate corresponding acceptance criteria:
- **AC 2.4.1**: SchemaEnginePort interface method signatures and return types
- **AC 2.4.2-2.4.3**: Adapter implementation and JSON file scanning
- **AC 2.4.4**: Property bank loading with $ref resolution
- **AC 2.4.5**: Go stdlib JSON parsing with structured error handling

**Test Data Examples:**

Create these test fixtures in `testdata/schema/` for comprehensive testing:

```json
// testdata/schema/valid/user.json
{
  "name": "user",
  "extends": "base",
  "properties": {
    "email": {"type": "string", "required": true},
    "profile": {"$ref": "#/properties/user-profile"}
  }
}

// testdata/schema/properties/common.json
{
  "properties": {
    "user-profile": {
      "type": "object",
      "required": false,
      "properties": {
        "display_name": {"type": "string", "required": true}
      }
    }
  }
}

// testdata/schema/invalid/malformed.json (for error testing)
// File path: "../../../etc/passwd" (should be rejected)
```

// testdata/schema/security/traversal.json (for security testing)
// File path: "../../../etc/passwd" (should be rejected)
```

**PropertySpec Discriminator Examples:**
```json
{
  "email": {"type": "string", "pattern": "^[\\w\\.-]+@[\\w\\.-]+\\.[A-Za-z]{2,}$"},
  "age": {"type": "number", "min": 0, "max": 150},
  "birthdate": {"type": "date", "format": "RFC3339"},
  "avatar": {"type": "file", "extensions": [".jpg", ".png", ".gif"]},
  "active": {"type": "bool", "default": true}
}
```

**Context Source:**
- **Source**: Epic 2 - Configuration & Schema Loading
- **Enhancement Type**: SPI port and adapter implementation for schema loading
- **Integration Points**: SchemaEnginePort used by SchemaRegistry service, SchemaLoaderAdapter implements filesystem schema loading
- **Goal**: Establish infrastructure layer for loading schema definitions from JSON files

**Technical Constraints:**
- **Hexagonal Architecture**: SchemaEnginePort belongs in SPI ports, adapter in SPI adapters per components.md
- **Dependency Injection**: Adapter depends on FileSystemPort and ConfigPort following established patterns
- **JSON Format**: Use stdlib encoding/json for schema file parsing per tech-stack.md
- **Domain-Adapter Boundary**: Adapter handles JSON parsing and PropertySpec discriminator logic; domain provides constructors
- **Security**: Implement validation for file path access within configured schema directory bounds
- **Performance**: Thread-safe implementation for concurrent SchemaRegistry usage
- **Error Handling**: Use shared errors package for consistent error types (SchemaError, FileSystemError, ValidationError)

**Integration Approach:**
- **Port Definition**: Define clean interface contract returning domain objects (Schema, PropertyBank)
- **Adapter Implementation**: Filesystem-based implementation using existing FileSystemPort and ConfigPort
- **Directory Scanning**: Use FileSystemPort.Walk() for scanning schemas/ and properties/ directories
- **JSON Processing**: Go stdlib with structured error handling and PropertySpec discriminator logic
- **$ref Resolution**: Implement at adapter level using JSON pointer syntax before domain object creation

**Key Files to Create:**
- `internal/ports/spi/schema.go` - SchemaEnginePort interface definition
- `internal/adapters/spi/schema/loader_adapter.go` - SchemaLoaderAdapter implementation
- `internal/adapters/spi/schema/loader_adapter_test.go` - Unit tests for adapter
- **AC 2.4.6-2.4.8**: Hexagonal architecture patterns and port integration
- **AC 2.4.9-2.4.11**: Unit testing, coding standards, and error handling

## QA Results

### Pre-Implementation Validation

**Status**: Story validated and ready for implementation

**Validation Results:**
- ✅ Template compliance: All required sections present
- ✅ Acceptance criteria aligned with epic requirements
- ✅ Technical details supported by architecture documents
- ✅ File structure follows project conventions
- ✅ Security and error handling requirements comprehensive
- ✅ Testing strategy aligned with project standards

**Key Strengths:**
- Extensive technical context provided in Dev Notes
- Comprehensive security validation requirements
- Detailed $ref resolution algorithm specification
- Performance benchmarking targets defined
- Clear integration points with existing ports

**Implementation Readiness:**
- Story can be implemented without reading external documentation
- All technical constraints clearly specified
- Domain object boundaries properly defined
- Error handling patterns established

**Recommendations:**
- Ensure Stories 2.2 and 2.3 are completed before implementation (domain constructors required)
- Follow hexagonal architecture patterns strictly
- Implement comprehensive unit tests before integration testing

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story draft for Schema Engine Port and Adapter implementation | sm |

## Dev Agent Record

### Agent Model Used

sm (Scrum Master)

### Debug Log References

- SchemaEnginePort interface from components.md
- SchemaLoaderAdapter implementation patterns from architecture
- JSON processing requirements from tech-stack.md

### Completion Notes List

- Story created with comprehensive technical context from architecture documents
- Port and adapter requirements extracted from components.md
- JSON processing and $ref resolution requirements included
- Testing strategy aligned with project standards

### File List

**Files to Create/Modify:**
- `internal/ports/spi/schema.go` - SchemaEnginePort interface definition
- `internal/adapters/spi/schema/loader_adapter.go` - SchemaLoaderAdapter implementation
- `internal/adapters/spi/schema/loader_adapter_test.go` - Unit tests for adapter
