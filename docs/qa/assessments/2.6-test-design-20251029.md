# Test Design: Story 2.6 - SchemaValidator Service

**Date:** 2025-10-29
**Designer:** Quinn (Test Architect)
**Story:** 2.6 - SchemaValidator Service
**Epic:** 2 - Configuration & Schema Loading

---

## Test Strategy Overview

- **Total test scenarios:** 16
- **Unit tests:** 16 (100%)
- **Integration tests:** 0 (0%)
- **E2E tests:** 0 (0%)
- **Priority distribution:** P0: 12, P1: 4

**Rationale:** SchemaValidator is pure orchestration logic with no external dependencies, enabling thorough unit coverage. The service must aggregate schema-level validation, cross-schema constraints, and property bank reference checks without silent failures. Tests emphasize error aggregation via `errors.Join`, contextual messaging, and ensuring valid inputs pass without side effects.

---

## Test Scenarios by Acceptance Criteria

### AC 2.6.4-2.6.7: Model-Level Validation Orchestration

| ID           | Level | Priority | Test Description                                                            | Justification                                     |
| ------------ | ----- | -------- | --------------------------------------------------------------------------- | ------------------------------------------------- |
| 2.6-UNIT-001 | Unit  | P0       | ValidateAll succeeds with fully valid schemas and property bank             | Baseline functionality                            |
| 2.6-UNIT-002 | Unit  | P0       | Model validation error when schema has empty Name is surfaced with context  | Ensures schema.Validate errors bubble correctly   |
| 2.6-UNIT-003 | Unit  | P0       | Model validation error when property spec invalid bubbles with schema name  | Verifies error wrapping for nested validators     |

---

### AC 2.6.8-2.6.12: Cross-Schema Validation

| ID           | Level | Priority | Test Description                                                                      | Justification                                      |
| ------------ | ----- | -------- | ------------------------------------------------------------------------------------- | -------------------------------------------------- |
| 2.6-UNIT-004 | Unit  | P0       | Extends refers to missing parent → error lists child and missing parent              | Validates inheritance reference checking           |
| 2.6-UNIT-005 | Unit  | P0       | Duplicate schema names detected and all duplicates reported                          | Prevents ambiguous registry contents               |
| 2.6-UNIT-006 | Unit  | P0       | Property `$ref` missing from PropertyBank produces contextual error                  | Safeguards $ref integrity                          |
| 2.6-UNIT-007 | Unit  | P1       | Validator handles empty schema slice gracefully (no error)                           | Edge case for cold start                           |

---

### AC 2.6.13-2.6.15: Error Aggregation & Messaging

| ID           | Level | Priority | Test Description                                                                 | Justification                                        |
| ------------ | ----- | -------- | -------------------------------------------------------------------------------- | ---------------------------------------------------- |
| 2.6-UNIT-008 | Unit  | P0       | Multiple failures return aggregated error containing all individual messages     | Ensures errors.Join usage                           |
| 2.6-UNIT-009 | Unit  | P0       | Aggregated error preserves wrapped error types (errors.Is/As works)             | Downstream error handling needs proper wrapping     |
| 2.6-UNIT-010 | Unit  | P1       | Error strings include remediation hints per FR5/FR7                              | Documentation/UX requirement for operators          |

---

### AC 2.6.5, 2.6.18-2.6.20: Delegation & Documentation Checks

| ID           | Level | Priority | Test Description                                                     | Justification                                         |
| ------------ | ----- | -------- | -------------------------------------------------------------------- | ----------------------------------------------------- |
| 2.6-UNIT-011 | Unit  | P1       | SchemaValidator does not mutate inputs (pure orchestration)          | Confirms statelessness for future re-use              |
| 2.6-UNIT-012 | Unit  | P1       | GoDoc example builds, confirming documented behavior                 | Keeps documentation aligned with implementation       |

---

### AC 2.6.16-2.6.17: Logging Abstention

| ID           | Level | Priority | Test Description                                                 | Justification                                   |
| ------------ | ----- | -------- | ---------------------------------------------------------------- | ----------------------------------------------- |
| 2.6-UNIT-013 | Unit  | P0       | Ensure SchemaValidator makes no logging calls (via fake logger)  | Guarantees no hidden dependencies                |

---

### AC 2.6.8-2.6.12, 2.6.21: Additional Cross-Schema Coverage

| ID           | Level | Priority | Test Description                                                                       | Justification                                      |
| ------------ | ----- | -------- | -------------------------------------------------------------------------------------- | -------------------------------------------------- |
| 2.6-UNIT-014 | Unit  | P0       | Extends chain referencing multiple levels passes when parents exist                   | Positive coverage for inheritance logic            |
| 2.6-UNIT-015 | Unit  | P0       | Multiple `$ref` references resolve successfully when present in PropertyBank          | Ensures no false positives                         |
| 2.6-UNIT-016 | Unit  | P0       | Combination test: one model failure + one cross-schema failure aggregated together    | Reinforces aggregator across categories            |

---

## Test Scenario Details

### Valid Happy Path (2.6-UNIT-001, 2.6-UNIT-014, 2.6-UNIT-015)
```go
func TestSchemaValidator_ValidateAll_Success(t *testing.T) {
    validator := NewSchemaValidator()

    bank := PropertyBank{Properties: map[string]Property{
        "standard_title": {Name: "title", Spec: StringSpec{}},
        "standard_tags":  {Name: "tags", Spec: StringSpec{}},
    }}

    schemas := []Schema{
        {
            Name: "base",
            Properties: []Property{
                {Name: "title", Spec: StringSpec{}},
                {Name: "tags", Spec: StringSpec{}},
            },
        },
        {
            Name:    "meeting_note",
            Extends: "base",
            Properties: []Property{
                {Name: "title", Ref: "standard_title"},
                {Name: "tags", Ref: "standard_tags"},
            },
        },
    }

    err := validator.ValidateAll(context.Background(), schemas, bank)
    require.NoError(t, err)
}
```

### Missing Parent Schema (2.6-UNIT-004)
```go
func TestSchemaValidator_ValidateAll_MissingParent(t *testing.T) {
    validator := NewSchemaValidator()

    schemas := []Schema{{Name: "orphan", Extends: "missing"}}

    err := validator.ValidateAll(context.Background(), schemas, PropertyBank{})

    require.Error(t, err)
    assert.ErrorContains(t, err, "orphan")
    assert.ErrorContains(t, err, "missing")
}
```

### Duplicate Names (2.6-UNIT-005)
```go
func TestSchemaValidator_ValidateAll_DuplicateNames(t *testing.T) {
    validator := NewSchemaValidator()

    schemas := []Schema{
        {Name: "dup"},
        {Name: "dup"},
        {Name: "dup"},
    }

    err := validator.ValidateAll(context.Background(), schemas, PropertyBank{})

    require.Error(t, err)
    assert.ErrorContains(t, err, "dup")
    assert.ErrorContains(t, err, "duplicate schema name")
}
```

### Missing `$ref` (2.6-UNIT-006)
```go
func TestSchemaValidator_ValidateAll_MissingRef(t *testing.T) {
    validator := NewSchemaValidator()

    schemas := []Schema{
        {
            Name: "note",
            Properties: []Property{
                {Name: "title", Ref: "standard_title"},
            },
        },
    }

    err := validator.ValidateAll(context.Background(), schemas, PropertyBank{})

    require.Error(t, err)
    assert.ErrorContains(t, err, "standard_title")
    assert.ErrorContains(t, err, "$ref")
}
```

### Aggregated Errors (2.6-UNIT-008, 2.6-UNIT-009, 2.6-UNIT-016)
```go
func TestSchemaValidator_ValidateAll_AggregatesMultipleErrors(t *testing.T) {
    validator := NewSchemaValidator()

    schemas := []Schema{
        {Name: "", Properties: nil},               // Model error
        {Name: "orphan", Extends: "missing"},     // Cross-schema error
    }

    err := validator.ValidateAll(context.Background(), schemas, PropertyBank{})

    require.Error(t, err)
    assert.ErrorContains(t, err, "schema :")
    assert.ErrorContains(t, err, "orphan")
}
```

---

## Risk Coverage

- **RISK-VAL-001:** Invalid schemas pass validation → Mitigated by 2.6-UNIT-001 through 2.6-UNIT-006.
- **RISK-VAL-002:** Missing parents or `$ref` produce cryptic errors → Mitigated by 2.6-UNIT-004 & 2.6-UNIT-006 with messaging checks.
- **RISK-VAL-003:** Duplicate schema names slip through → Mitigated by 2.6-UNIT-005.
- **RISK-VAL-004:** Aggregated errors obscure original types → Mitigated by 2.6-UNIT-008 & 2.6-UNIT-009.
- **RISK-VAL-005:** Validator accidentally logs or mutates input data → Mitigated by 2.6-UNIT-011 & 2.6-UNIT-013.
- **RISK-VAL-006:** Empty inputs cause panics or errors → Mitigated by 2.6-UNIT-007.

---

## Test Execution Order

1. **Happy path baseline:** 2.6-UNIT-001, 2.6-UNIT-014, 2.6-UNIT-015.
2. **Model validation failures:** 2.6-UNIT-002, 2.6-UNIT-003.
3. **Cross-schema validations:** 2.6-UNIT-004, 2.6-UNIT-005, 2.6-UNIT-006, 2.6-UNIT-007.
4. **Error aggregation behavior:** 2.6-UNIT-008, 2.6-UNIT-009, 2.6-UNIT-016.
5. **Auxiliary guarantees:** 2.6-UNIT-010, 2.6-UNIT-011, 2.6-UNIT-012, 2.6-UNIT-013.
6. **Regression sweeps:** Re-run targeted cases after refactors to ensure `errors.Join` output stability.

---

## Quality Gates

- ✅ All 12 P0 scenarios implemented and passing.
- ✅ `go test ./internal/app/schema -race -v` passes (even though no shared state, guards future regressions).
- ✅ `golangci-lint run ./internal/app/schema` reports zero issues.
- ✅ Error messages verified to include schema/property names and remediation hints.
- ✅ Tests assert `errors.Is`/`errors.As` compatibility on aggregated results.

---

## Edge Cases & Considerations

- Use helper constructors for schemas and properties to keep tests concise and reduce duplication.
- When asserting aggregated errors, prefer substring checks combined with `errors.Is/As` to avoid brittle formatting assumptions.
- Ensure property bank fixtures cover both present and missing references.
- Keep validator stateless—tests should confirm no caching occurs between runs.

---

## Summary

The defined scenarios ensure SchemaValidator delivers comprehensive validation:

1. Valid configurations pass without noise.
2. Structural issues or cross-schema references fail fast with actionable messaging.
3. Aggregated errors remain analyzable and type-safe when joined.
4. No side effects, logging, or state retention occur, supporting deterministic startup behavior.

Collectively, these 16 unit tests provide high confidence before SchemaResolver consumes the validated schema set.
