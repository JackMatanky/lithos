# Test Design: Story 1.2

Date: 2025-10-28
Designer: Quinn (Test Architect)

## Test Strategy Overview

- Total test scenarios: 9
- Unit tests: 9 (100%)
- Integration tests: 0 (0%)
- E2E tests: 0 (0%)
- Priority distribution: P0: 9, P1: 0, P2: 0

## Test Scenarios by Acceptance Criteria

### AC1.2.1: NoteID Implementation

#### Scenarios

| ID           | Level | Priority | Test                                            | Justification                                             |
| ------------ | ----- | -------- | ----------------------------------------------- | --------------------------------------------------------- |
| 1.2-UNIT-001 | Unit  | P0       | Create NoteID and verify String() returns value | Pure constructor and method logic, core domain identifier |
| 1.2-UNIT-002 | Unit  | P0       | Use NoteID as map key for type safety           | Domain usage pattern, data integrity critical             |

### AC1.2.2: Frontmatter Implementation

#### Scenarios

| ID           | Level | Priority | Test                                                     | Justification                                             |
| ------------ | ----- | -------- | -------------------------------------------------------- | --------------------------------------------------------- |
| 1.2-UNIT-003 | Unit  | P0       | NewFrontmatter with fileClass present extracts correctly | Constructor and helper logic, schema reference extraction |
| 1.2-UNIT-004 | Unit  | P0       | NewFrontmatter without fileClass sets empty FileClass    | Edge case handling, defensive programming                 |
| 1.2-UNIT-005 | Unit  | P0       | SchemaName() returns FileClass value                     | Method behavior, interface compliance                     |

### AC1.2.3: Note Implementation

#### Scenarios

| ID           | Level | Priority | Test                                                    | Justification                                  |
| ------------ | ----- | -------- | ------------------------------------------------------- | ---------------------------------------------- |
| 1.2-UNIT-006 | Unit  | P0       | NewNote constructs with ID and Frontmatter              | Constructor logic, aggregate root creation     |
| 1.2-UNIT-007 | Unit  | P0       | SchemaName() delegates to Frontmatter.SchemaName()      | Delegation pattern, composition over embedding |
| 1.2-UNIT-008 | Unit  | P0       | Note struct has no File field (architecture compliance) | Prevents infrastructure leakage into domain    |
| 1.2-UNIT-009 | Unit  | P0       | Note JSON serialization preserves data round-trip       | Data integrity for caching/serialization       |

### AC1.2.4: Unit tests in note_test.go

**Coverage:** All scenarios above implemented as table-driven unit tests in `internal/domain/note_test.go`

### AC1.2.5: All tests pass

**Validation:** `go test ./internal/domain` returns 0 exit code with all tests passing

### AC1.2.6: Linting passes

**Validation:** `golangci-lint run --fix internal/domain` returns 0 exit code with no warnings

### AC1.2.7: Changes committed

**Validation:** Git commit with specified message exists

## Risk Coverage

This story implements core domain models that are fundamental to data integrity and system functionality. All tests are P0 priority because:

- Domain models handle critical business data
- Note entities are used throughout the system
- Data corruption could affect all note operations
- Schema validation depends on correct FileClass extraction

## Recommended Execution Order

1. P0 Unit tests (all scenarios) - Execute all 9 unit tests
2. Quality gates - Verify tests pass and linting clean
3. Commit validation - Confirm proper commit message

## Coverage Analysis

- **Full Coverage:** Every acceptance criterion has dedicated test scenarios
- **No Gaps:** All constructor, method, and structural requirements tested
- **Edge Cases:** Missing fileClass, JSON serialization, type safety covered
- **Architecture Compliance:** Tests verify no File embedding and proper delegation

## Test Design Recommendations

- **Test Framework:** Use Go's built-in testing with table-driven tests for multiple scenarios
- **Mocking:** No external dependencies, pure unit tests
- **Assertions:** Use testify/assert for readable assertions
- **Coverage Tool:** `go test -cover` to verify >90% coverage
- **CI Integration:** All tests run in CI pipeline before merge
