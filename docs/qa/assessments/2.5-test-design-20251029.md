# Test Design: Story 2.5 - SchemaRegistryPort & Adapter

**Date:** 2025-10-29
**Designer:** Quinn (Test Architect)
**Story:** 2.5 - SchemaRegistryPort & Adapter
**Epic:** 2 - Configuration & Schema Loading

---

## Test Strategy Overview

- **Total test scenarios:** 15
- **Unit tests:** 15 (100%)
- **Integration tests:** 0 (0%)
- **E2E tests:** 0 (0%)
- **Priority distribution:** P0: 11, P1: 4

**Rationale:** The registry adapter underpins every schema/property lookup at runtime. Because it is purely in-memory with a `sync.RWMutex`, all responsibilities can be validated via deterministic unit tests that exercise concurrency, defensive copies, idempotent registration, and error shaping. Coverage emphasizes FR5/FR7 access guarantees, FR9 idempotent reload behavior, and correct SchemaError composition.

---

## Test Scenarios by Acceptance Criteria

### AC 2.5.1-2.5.3: SchemaRegistryPort Interface Contract

| ID           | Level | Priority | Test Description                                                      | Justification                                      |
| ------------ | ----- | -------- | --------------------------------------------------------------------- | -------------------------------------------------- |
| 2.5-UNIT-001 | Unit  | P1       | GoDoc example compiles and demonstrates ErrNotFound semantics         | Ensures interface documentation matches behavior  |

---

### AC 2.5.4-2.5.6: Adapter Construction & Storage

| ID           | Level | Priority | Test Description                                                      | Justification                                       |
| ------------ | ----- | -------- | --------------------------------------------------------------------- | --------------------------------------------------- |
| 2.5-UNIT-002 | Unit  | P1       | NewSchemaRegistryAdapter initializes maps and stores injected logger  | Prevents nil map panics & verifies constructor wiring |

---

### AC 2.5.7-2.5.9: Thread Safety Guarantees

| ID           | Level | Priority | Test Description                                                      | Justification                                      |
| ------------ | ----- | -------- | --------------------------------------------------------------------- | -------------------------------------------------- |
| 2.5-UNIT-003 | Unit  | P0       | RegisterAll acquires write lock (verified via race detector)          | Core concurrency guarantee                          |
| 2.5-UNIT-004 | Unit  | P0       | Concurrent GetSchema/HasSchema reads run without race detector issues | Validates read-path locking                         |
| 2.5-UNIT-005 | Unit  | P0       | Concurrent GetProperty/HasProperty reads run without race issues      | Symmetry for property access                        |

---

### AC 2.5.10-2.5.12: Defensive Copying

| ID           | Level | Priority | Test Description                                                           | Justification                                           |
| ------------ | ----- | -------- | ---------------------------------------------------------------------------- | ------------------------------------------------------- |
| 2.5-UNIT-006 | Unit  | P0       | RegisterAll stores defensive copies (mutating input after register no-op)   | Prevents external mutations from leaking in             |
| 2.5-UNIT-007 | Unit  | P0       | GetSchema returns copy (mutating returned schema does not change registry)  | Guarantees read immutability                           |
| 2.5-UNIT-008 | Unit  | P0       | GetProperty returns copy (mutating returned property does not change state) | Guarantees read immutability for properties             |

---

### AC 2.5.13-2.5.15: Idempotent Registration & Logging

| ID           | Level | Priority | Test Description                                                                  | Justification                                      |
| ------------ | ----- | -------- | --------------------------------------------------------------------------------- | -------------------------------------------------- |
| 2.5-UNIT-009 | Unit  | P0       | RegisterAll clears previous entries before inserting new ones                    | Ensures idempotent reload (FR9)                    |
| 2.5-UNIT-010 | Unit  | P0       | Info log records counts for schemas and properties                               | Observability requirement                          |

---

### AC 2.5.16-2.5.18: Lookup Behavior

| ID           | Level | Priority | Test Description                                                                  | Justification                                      |
| ------------ | ----- | -------- | --------------------------------------------------------------------------------- | -------------------------------------------------- |
| 2.5-UNIT-011 | Unit  | P0       | GetSchema returns expected schema when present                                    | Core functionality                                 |
| 2.5-UNIT-012 | Unit  | P0       | GetSchema returns SchemaError with ErrNotFound metadata when name missing         | Error contract enforcement                         |
| 2.5-UNIT-013 | Unit  | P0       | GetProperty returns SchemaError with ErrNotFound metadata when property missing   | Error contract enforcement                         |
| 2.5-UNIT-014 | Unit  | P1       | HasSchema/HasProperty return accurate booleans without errors                     | Convenience API validation                         |

---

### AC 2.5.19-2.5.20: Error Context

| ID           | Level | Priority | Test Description                                                     | Justification                                  |
| ------------ | ----- | -------- | -------------------------------------------------------------------- | ---------------------------------------------- |
| 2.5-UNIT-015 | Unit  | P0       | SchemaError includes target name and wraps ErrNotFound classification | Required for diagnostics & downstream handling |

---

## Test Scenario Details

### Happy Path Registration and Lookups (P0)

**Covers:** 2.5-UNIT-006, 2.5-UNIT-007, 2.5-UNIT-008, 2.5-UNIT-009, 2.5-UNIT-011, 2.5-UNIT-014
```go
func TestSchemaRegistryAdapter_RegisterAndLookup_Success(t *testing.T) {
    logger := newTestLogger()
    registry := NewSchemaRegistryAdapter(logger)

    schemas := []Schema{{Name: "meeting-note"}}
    bank := PropertyBank{Properties: map[string]Property{"standard_title": {Name: "title"}}}

    require.NoError(t, registry.RegisterAll(context.Background(), schemas, bank))

    schema, err := registry.GetSchema(context.Background(), "meeting-note")
    require.NoError(t, err)
    assert.Equal(t, "meeting-note", schema.Name)

    prop, err := registry.GetProperty(context.Background(), "standard_title")
    require.NoError(t, err)
    assert.Equal(t, "title", prop.Name)

    // Mutate returned copies, then re-fetch to ensure defensive copying
    schema.Name = "mutated"
    prop.Name = "mutated"

    schema2, _ := registry.GetSchema(context.Background(), "meeting-note")
    prop2, _ := registry.GetProperty(context.Background(), "standard_title")
    assert.Equal(t, "meeting-note", schema2.Name)
    assert.Equal(t, "title", prop2.Name)

    assert.True(t, registry.HasSchema(context.Background(), "meeting-note"))
    assert.True(t, registry.HasProperty(context.Background(), "standard_title"))
}
```

### Idempotent Re-registration (P0)

**Covers:** 2.5-UNIT-009
```go
func TestSchemaRegistryAdapter_RegisterAll_Idempotent(t *testing.T) {
    registry := NewSchemaRegistryAdapter(newTestLogger())

    first := []Schema{{Name: "schema-a"}}
    second := []Schema{{Name: "schema-b"}}

    require.NoError(t, registry.RegisterAll(context.Background(), first, PropertyBank{}))
    require.NoError(t, registry.RegisterAll(context.Background(), second, PropertyBank{}))

    assert.False(t, registry.HasSchema(context.Background(), "schema-a"))
    assert.True(t, registry.HasSchema(context.Background(), "schema-b"))
}
```

### Missing Schema/Property Errors (P0)

**Covers:** 2.5-UNIT-012, 2.5-UNIT-013, 2.5-UNIT-015
```go
func TestSchemaRegistryAdapter_GetSchema_NotFound(t *testing.T) {
    registry := NewSchemaRegistryAdapter(newTestLogger())

    _, err := registry.GetSchema(context.Background(), "missing")

    require.Error(t, err)
    schemaErr := &SchemaError{}
    require.ErrorAs(t, err, &schemaErr)
    assert.Equal(t, ErrNotFound, schemaErr.Classification)
    assert.Contains(t, schemaErr.Message, "missing")
}
```

### Concurrency & Race Detection (P0)

**Covers:** 2.5-UNIT-003, 2.5-UNIT-004, 2.5-UNIT-005
```go
func TestSchemaRegistryAdapter_ConcurrentReads_NoRace(t *testing.T) {
    registry := NewSchemaRegistryAdapter(newTestLogger())

    schemas := []Schema{{Name: "schema"}}
    bank := PropertyBank{Properties: map[string]Property{"prop": {Name: "prop"}}}
    require.NoError(t, registry.RegisterAll(context.Background(), schemas, bank))

    var wg sync.WaitGroup
    for i := 0; i < 200; i++ {
        wg.Add(2)
        go func() {
            defer wg.Done()
            _, _ = registry.GetSchema(context.Background(), "schema")
        }()
        go func() {
            defer wg.Done()
            _ = registry.HasProperty(context.Background(), "prop")
        }()
    }
    wg.Wait()
}
```

### Logging Assertions (P0)

**Covers:** 2.5-UNIT-010
```go
func TestSchemaRegistryAdapter_RegisterAll_LogsCounts(t *testing.T) {
    log := newCapturingLogger()
    registry := NewSchemaRegistryAdapter(log)

    schemas := []Schema{{Name: "schema"}, {Name: "schema2"}}
    bank := PropertyBank{Properties: map[string]Property{"prop": {}, "prop2": {}}}

    require.NoError(t, registry.RegisterAll(context.Background(), schemas, bank))

    log.AssertHasInfo("registered", map[string]int{
        "schemas":    len(schemas),
        "properties": len(bank.Properties),
    })
}
```

---

## Risk Coverage

- **RISK-REG-001:** Registry returns stale data after reload → Mitigated by 2.5-UNIT-009.
- **RISK-REG-002:** Callers mutate registry state through returned references → Mitigated by 2.5-UNIT-006/007/008.
- **RISK-REG-003:** Concurrent lookups introduce races → Mitigated by 2.5-UNIT-003/004/005 with `-race` execution.
- **RISK-REG-004:** Missing schema/property errors lack actionable detail → Mitigated by 2.5-UNIT-012/013/015.
- **RISK-REG-005:** Logging omitted, hindering observability → Mitigated by 2.5-UNIT-010.
- **RISK-REG-006:** Constructor leaves nil maps causing panic on RegisterAll → Mitigated by 2.5-UNIT-002.

---

## Test Execution Order

1. **Interface & constructor smoke (P1):** 2.5-UNIT-001, 2.5-UNIT-002.
2. **Happy path registration & lookups (P0):** 2.5-UNIT-006/007/008/011/014.
3. **Idempotency & logging (P0):** 2.5-UNIT-009, 2.5-UNIT-010.
4. **Error shaping (P0):** 2.5-UNIT-012, 2.5-UNIT-013, 2.5-UNIT-015.
5. **Concurrency suite (P0):** 2.5-UNIT-003, 2.5-UNIT-004, 2.5-UNIT-005 (run with `-race`).
6. **Property-specific defensive copy (P0):** 2.5-UNIT-008 (if not fully covered earlier).
7. **Regression sweeps (P1):** Ensure Has* helpers (2.5-UNIT-014) remain accurate after refactors.

---

## Quality Gates

- ✅ All 11 P0 scenarios implemented and passing.
- ✅ Race detector `go test ./internal/adapters/spi/schema -race` reports zero issues.
- ✅ `golangci-lint run ./internal/ports/spi ./internal/adapters/spi/schema` passes cleanly.
- ✅ Logging assertions confirm info-level registration summary.
- ✅ Test fixture helpers provide deterministic cloning of schemas/properties for mutation tests.

---

## Edge Cases & Considerations

- Schema names & property IDs are case-sensitive; tests should cover mixed-case names to avoid accidental normalization.
- Empty registration input should be allowed (clears registry); include scenario within idempotency test to confirm zero-count logging.
- Error types must remain stable—tests should assert concrete type fields rather than only message substrings where possible.
- Future expansions (e.g., partial updates) may reuse defensive copy helpers; keep helper factories in tests for reusability.

---

## Test Fixture & Helper Guidance

- Use lightweight inline structs for schemas/properties (no need for JSON fixtures).
- Provide small helper constructors in tests, e.g., `stubSchema(name string) Schema` and `stubProperty(id string) Property`, to reduce duplication.
- For logging assertions, reuse the capturing logger utility introduced in Story 2.4 to keep test harness consistent.

---

## Summary

The outlined tests validate the SchemaRegistry adapter across concurrency, safety, and observability axes:

1. Constructor and interface documentation stay aligned with architecture contract.
2. RegisterAll provides deterministic, idempotent population with defensive copies.
3. Lookups surface precise SchemaError information for not-found scenarios.
4. Concurrent access remains race-free under `-race`.
5. Logging delivers visibility into registry population counts.

These 15 scenarios collectively ensure the registry can be trusted as the authoritative in-memory source for schemas and properties post-resolution.
