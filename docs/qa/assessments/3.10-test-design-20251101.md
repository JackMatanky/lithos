# Test Design: Story 3.10

Date: 2025-11-01
Designer: Quinn (Test Architect)

## Test Strategy Overview

- Total test scenarios: 16
- Unit tests: 10 (63%)
- Integration tests: 4 (25%)
- E2E tests: 2 (13%)
- Priority distribution: P0: 12, P1: 4

## Test Scenarios by Acceptance Criteria

### AC1: Notes with identical basenames in different vault directories must generate unique cache entries and NoteID values

#### Scenarios

| ID           | Level       | Priority | Test                      | Justification            |
| ------------ | ----------- | -------- | ------------------------- | ------------------------ |
| 3.10-UNIT-001 | Unit        | P0       | deriveNoteIDFromPath generates unique IDs for same basename different paths | Pure logic validation, data integrity critical |
| 3.10-UNIT-002 | Unit        | P0       | Cache key generation creates unique filenames from unique NoteIDs | Algorithm correctness for filesystem safety |
| 3.10-INT-001  | Integration | P0       | VaultIndexer creates unique cache entries for duplicate basenames | Component interaction validation, data integrity |

### AC2: NoteID generation must preserve vault-relative path information instead of using only the basename

#### Scenarios

| ID           | Level       | Priority | Test                      | Justification            |
| ------------ | ----------- | -------- | ------------------------- | ------------------------ |
| 3.10-UNIT-003 | Unit        | P0       | deriveNoteIDFromPath preserves full vault-relative path | Input validation and transformation logic |
| 3.10-UNIT-004 | Unit        | P0       | deriveNoteIDFromPath handles path normalization (Windows/Unix separators) | Cross-platform compatibility, pure function |
| 3.10-UNIT-005 | Unit        | P0       | deriveNoteIDFromPath strips vault root prefix correctly | Path manipulation logic |

### AC3: Cache filenames must be unique and deterministic based on the complete NoteID

#### Scenarios

| ID           | Level       | Priority | Test                      | Justification            |
| ------------ | ----------- | -------- | ------------------------- | ------------------------ |
| 3.10-UNIT-006 | Unit        | P0       | JSONCacheWriteAdapter generates deterministic cache keys from NoteID | Algorithm correctness, filesystem safety |
| 3.10-UNIT-007 | Unit        | P0       | Cache key generation replaces path separators with safe characters | Path-to-filename conversion logic |
| 3.10-UNIT-008 | Unit        | P0       | Cache keys are filesystem-safe across Windows/Unix/Mac | Cross-platform compatibility validation |

### AC4: QueryService ByPath and ByBasename methods must work correctly with the new NoteID scheme

#### Scenarios

| ID           | Level       | Priority | Test                      | Justification            |
| ------------ | ----------- | -------- | ------------------------- | ------------------------ |
| 3.10-UNIT-009 | Unit        | P0       | QueryService ByPath method uses full NoteID as key | Index population logic |
| 3.10-UNIT-010 | Unit        | P0       | QueryService ByBasename method extracts basename from NoteID | String manipulation and indexing |
| 3.10-INT-002  | Integration | P0       | QueryService RefreshFromCache populates byPath and byBasename indices | Component interaction, data flow validation |

### AC5: Incremental refresh operations must correctly map cache entries to source files using the new ID approach

#### Scenarios

| ID           | Level       | Priority | Test                      | Justification            |
| ------------ | ----------- | -------- | ------------------------- | ------------------------ |
| 3.10-INT-003  | Integration | P0       | VaultIndexer Refresh correctly maps ScanModified results to cache entries | Component interaction, incremental update logic |
| 3.10-INT-004  | Integration | P1       | Incremental refresh handles path-based NoteIDs in complex directory structures | Edge case validation, performance consideration |

### AC6: Existing vault functionality must continue to work without breaking changes to the domain model interface

#### Scenarios

| ID           | Level       | Priority | Test                      | Justification            |
| ------------ | ----------- | -------- | ------------------------- | ------------------------ |
| 3.10-E2E-001  | E2E         | P0       | Complete vault indexing and querying workflow maintains backward compatibility | Critical user journey, regression prevention |
| 3.10-INT-005  | Integration | P1       | Domain model interfaces remain unchanged (NoteID as opaque string) | Contract validation, breaking change prevention |

### AC7: Cache key generation must produce filesystem-safe filenames across all supported operating systems

#### Scenarios

| ID           | Level       | Priority | Test                      | Justification            |
| ------------ | ----------- | -------- | ------------------------- | ------------------------ |
| 3.10-UNIT-011 | Unit        | P0       | Cache key generation handles special characters in paths | Edge case handling, filesystem safety |
| 3.10-UNIT-012 | Unit        | P0       | Cache key generation handles very long paths | Boundary condition testing |

### AC8: The indexing pipeline must handle path normalization consistently for cross-platform compatibility

#### Scenarios

| ID           | Level       | Priority | Test                      | Justification            |
| ------------ | ----------- | -------- | ------------------------- | ------------------------ |
| 3.10-UNIT-013 | Unit        | P0       | Path normalization converts all separators to forward slashes | Cross-platform consistency |
| 3.10-E2E-002  | E2E         | P1       | Full indexing pipeline works with mixed path separators in vault | End-to-end validation, user environment simulation |

## Risk Coverage

This implementation addresses critical data integrity risks:

- Cache collision risk (P0): Multiple unit and integration tests for unique ID generation
- Path handling risk (P0): Comprehensive path normalization and cross-platform testing
- Query accuracy risk (P0): Index population and lookup validation
- Backward compatibility risk (P0): E2E tests ensuring existing functionality preserved

## Recommended Execution Order

1. P0 Unit tests (fail fast on core logic issues)
2. P0 Integration tests (validate component interactions)
3. P0 E2E tests (ensure end-to-end compatibility)
4. P1 tests (additional coverage for edge cases)
