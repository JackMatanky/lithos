# Requirements Traceability Matrix

## Story: 3.10 - Fix Note ID Collision and Path Handling

Date: 2025-11-01
Reviewer: Quinn (Test Architect)

## Test Strategy Overview

- Total test scenarios: 8
- Unit tests: 6 (75%)
- Integration tests: 2 (25%)
- E2E tests: 0 (0%)
- Priority distribution: P0: 8, P1: 0, P2: 0

## Coverage Summary

- Total Requirements: 8
- Fully Covered: 8 (100%)
- Partially Covered: 0 (0%)
- Not Covered: 0 (0%)

## Requirement Mappings

#### AC1: Notes with identical basenames in different vault directories must generate unique cache entries and NoteID values

**Coverage: FULL**

Given-When-Then Mappings:

- **Integration Test**: `tests/integration/duplicate_basename_test.go::TestDuplicateBasenameHandling_Integration`
  - Given: A vault with files having identical basenames in different directories
  - When: The indexing system processes the vault
  - Then: Unique NoteIDs are generated and unique cache files are created

#### AC2: NoteID generation must preserve vault-relative path information instead of using only the basename

**Coverage: FULL**

Given-When-Then Mappings:

- **Unit Test**: `internal/app/vault/indexer_test.go::TestDeriveNoteIDFromPath`
  - Given: Various path inputs including nested directories
  - When: deriveNoteIDFromPath function is called
  - Then: Full vault-relative paths are preserved in NoteID

- **Integration Test**: `tests/integration/duplicate_basename_test.go::TestDuplicateBasenameHandling_Integration`
  - Given: Files with same basename in different directories
  - When: Indexing processes the vault
  - Then: NoteIDs include full path information (e.g., "projects/meeting.md", "ideas/meeting.md")

#### AC3: Cache filenames must be unique and deterministic based on the complete NoteID

**Coverage: FULL**

Given-When-Then Mappings:

- **Unit Test**: `internal/adapters/spi/cache/helper_test.go::TestNoteFilePath`
  - Given: NoteIDs with path separators and special characters
  - When: noteFilePath function converts NoteID to cache filename
  - Then: Path separators are replaced with hyphens, producing unique filesystem-safe names

- **Integration Test**: `tests/integration/duplicate_basename_test.go::TestDuplicateBasenameHandling_Integration`
  - Given: Notes with different paths but same basename
  - When: Cache files are created
  - Then: Unique cache filenames are generated (e.g., "projects-meeting.md.json", "ideas-meeting.md.json")

#### AC4: QueryService ByPath and ByBasename methods must work correctly with the new NoteID scheme

**Coverage: FULL**

Given-When-Then Mappings:

- **Unit Test**: `internal/app/query/service_test.go::TestQueryService_ByPath_ExistingPath`
  - Given: QueryService with populated indices
  - When: ByPath is called with a valid path
  - Then: Correct note is returned

- **Unit Test**: `internal/app/query/service_test.go::TestQueryService_ByBasename_ExistingBasename`
  - Given: QueryService with notes having path-based NoteIDs
  - When: ByBasename is called with a basename
  - Then: All notes with that basename are returned

- **Unit Test**: `internal/app/query/service_test.go::TestQueryService_ByBasename_MultipleMatches`
  - Given: Multiple notes with same basename in different paths
  - When: ByBasename is called
  - Then: All matching notes are returned

- **Integration Test**: `tests/integration/duplicate_basename_test.go::TestDuplicateBasenameHandling_Integration`
  - Given: Indexed vault with duplicate basenames
  - When: ByBasename is called for "meeting"
  - Then: Both notes (from projects and ideas directories) are returned

#### AC5: Incremental refresh operations must correctly map cache entries to source files using the new ID approach

**Coverage: FULL**

Given-When-Then Mappings:

- **Unit Test**: `internal/app/query/service_test.go::TestQueryService_RefreshFromCache_Success`
  - Given: Cache with notes having path-based NoteIDs
  - When: RefreshFromCache rebuilds indices
  - Then: byPath and byBasename indices are correctly populated from NoteID paths

- **Integration Test**: `tests/integration/duplicate_basename_test.go::TestDuplicateBasenameHandling_Integration`
  - Given: Indexed vault
  - When: QueryService.RefreshFromCache is called
  - Then: Indices are populated allowing ByBasename to return multiple notes with same basename

#### AC6: Existing vault functionality must continue to work without breaking changes to the domain model interface

**Coverage: FULL**

Given-When-Then Mappings:

- **Unit Test**: `internal/app/vault/indexer_test.go::TestVaultIndexer_Build_CallsVaultScannerScanAll`
  - Given: VaultIndexer with dependencies
  - When: Build is called
  - Then: VaultScanner.ScanAll is called and notes are processed

- **Unit Test**: `internal/app/vault/indexer_test.go::TestVaultIndexer_Build_CallsCacheWriterPersist`
  - Given: VaultIndexer with dependencies
  - When: Build is called
  - Then: CacheWriter.Persist is called for each note

- **Unit Test**: `internal/app/query/service_test.go::TestQueryService_ByID_ExistingNote`
  - Given: QueryService with populated indices
  - When: ByID is called with existing NoteID
  - Then: Correct note is returned

- **Unit Test**: `internal/app/query/service_test.go::TestQueryService_ByFileClass_ExistingClass`
  - Given: QueryService with notes of different file classes
  - When: ByFileClass is called
  - Then: All notes of that class are returned

#### AC7: Cache key generation must produce filesystem-safe filenames across all supported operating systems

**Coverage: FULL**

Given-When-Then Mappings:

- **Unit Test**: `internal/adapters/spi/cache/helper_test.go::TestNoteFilePath`
  - Given: NoteIDs with various path separators and special characters
  - When: noteFilePath function processes the NoteID
  - Then: All path separators are normalized to hyphens, producing filesystem-safe names

#### AC8: The indexing pipeline must handle path normalization consistently for cross-platform compatibility

**Coverage: FULL**

Given-When-Then Mappings:

- **Unit Test**: `internal/app/vault/indexer_test.go::TestDeriveNoteIDFromPath`
  - Given: Paths with Windows backslash separators
  - When: deriveNoteIDFromPath processes the path
  - Then: Path separators are normalized to forward slashes for internal representation

## Critical Gaps

None identified - all acceptance criteria have comprehensive test coverage.

## Test Design Recommendations

Based on analysis, the current test coverage is excellent:

1. **Integration Testing**: The duplicate basename integration test provides end-to-end validation
2. **Unit Test Coverage**: Individual components are well-tested with edge cases
3. **Cross-Platform**: Path normalization is properly tested for Windows/Unix compatibility
4. **Performance**: No performance tests identified as needed for this functionality

## Risk Assessment

- **High Risk**: None - comprehensive test coverage mitigates implementation risks
- **Medium Risk**: None - all critical paths are tested
- **Low Risk**: None - edge cases like path normalization are covered

## Integration with Gates

This traceability shows full coverage across all acceptance criteria, supporting a PASS gate decision.
