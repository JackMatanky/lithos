# Test Design: Story 1.8

Date: 2025-10-28
Designer: Quinn (Test Architect)

## Test Strategy Overview

- Total test scenarios: 18
- Unit tests: 12 (67%)
- Integration tests: 5 (28%)
- E2E tests: 1 (5%)
- Priority distribution: P0: 10, P1: 6, P2: 2

## Test Scenarios by Acceptance Criteria

### AC1.8.1: ConfigPort Interface Creation

#### Scenarios

| ID           | Level       | Priority | Test                      | Justification            |
| ------------ | ----------- | -------- | ------------------------- | ------------------------ |
| 1.8-UNIT-001 | Unit        | P0       | ConfigPort interface exists | Pure interface contract validation |
| 1.8-UNIT-002 | Unit        | P0       | Load method signature correct | Interface contract verification |
| 1.8-UNIT-003 | Unit        | P1       | Interface documentation complete | Contract clarity validation |

### AC1.8.2-1.8.3: ViperAdapter Implementation

#### Scenarios

| ID           | Level       | Priority | Test                      | Justification            |
| ------------ | ----------- | -------- | ------------------------- | ------------------------ |
| 1.8-UNIT-004 | Unit        | P0       | NewViperAdapter constructor | Constructor validation |
| 1.8-UNIT-005 | Unit        | P1       | Constructor with logger injection | Dependency injection verification |
| 1.8-UNIT-006 | Unit        | P1       | Adapter implements ConfigPort | Interface compliance |

### AC1.8.4-1.8.5: Config File Search and Load

#### Scenarios

| ID           | Level       | Priority | Test                      | Justification            |
| ------------ | ----------- | -------- | ------------------------- | ------------------------ |
| 1.8-UNIT-007 | Unit        | P0       | Load defaults when no config | Baseline configuration |
| 1.8-UNIT-008 | Unit        | P0       | Config file overrides defaults | Precedence validation |
| 1.8-UNIT-009 | Unit        | P0       | Upward search finds config | File system interaction |
| 1.8-UNIT-010 | Unit        | P1       | Search stops at first config | Search algorithm correctness |
| 1.8-UNIT-011 | Unit        | P1       | CWD used when no config found | Fallback behavior |

### AC1.8.6: Environment Variable Mapping

#### Scenarios

| ID           | Level       | Priority | Test                      | Justification            |
| ------------ | ----------- | -------- | ------------------------- | ------------------------ |
| 1.8-UNIT-012 | Unit        | P0       | Env vars override config file | Precedence validation |
| 1.8-UNIT-013 | Unit        | P1       | All LITHOS_* vars mapped | Complete mapping coverage |
| 1.8-UNIT-014 | Unit        | P1       | Invalid env vars ignored | Error handling |

### AC1.8.7: VaultPath Validation

#### Scenarios

| ID           | Level       | Priority | Test                      | Justification            |
| ------------ | ----------- | -------- | ------------------------- | ------------------------ |
| 1.8-UNIT-015 | Unit        | P0       | VaultPath exists validation | Critical path validation |
| 1.8-UNIT-016 | Unit        | P0       | VaultPath is directory validation | Directory requirement |
| 1.8-UNIT-017 | Unit        | P1       | Validation error messages | Error clarity |

### AC1.8.8-1.8.9: Comprehensive Testing

#### Scenarios

| ID           | Level       | Priority | Test                      | Justification            |
| ------------ | ----------- | -------- | ------------------------- | ------------------------ |
| 1.8-INT-001  | Integration | P0       | End-to-end config loading | Component integration |
| 1.8-INT-002  | Integration | P1       | Config file parsing | JSON parsing validation |
| 1.8-INT-003  | Integration | P1       | File system operations | Real file system interaction |
| 1.8-INT-004  | Integration | P2       | Large config files | Performance boundary |
| 1.8-INT-005  | Integration | P2       | Concurrent config loading | Thread safety |

### AC1.8.10-1.8.12: Quality Gates

#### Scenarios

| ID           | Level       | Priority | Test                      | Justification            |
| ------------ | ----------- | -------- | ------------------------- | ------------------------ |
| 1.8-E2E-001  | E2E         | P0       | Full application startup | Critical user journey |

## Risk Coverage

### Critical Risks Addressed

- **Config Loading Failure**: P0 unit and integration tests ensure config loads reliably
- **Incorrect Precedence**: P0 tests validate env > file > defaults order
- **Invalid Vault Path**: P0 validation tests prevent startup with bad paths
- **File System Issues**: Integration tests cover real file operations

### Test Coverage by Component

- **ConfigPort Interface**: 3 unit tests (100% coverage)
- **ViperAdapter Constructor**: 3 unit tests (100% coverage)
- **Config Loading Logic**: 5 unit tests (100% coverage)
- **Environment Mapping**: 3 unit tests (100% coverage)
- **VaultPath Validation**: 3 unit tests (100% coverage)
- **Integration Scenarios**: 5 integration tests (100% coverage)
- **End-to-End**: 1 E2E test (100% coverage)

## Recommended Execution Order

1. P0 Unit tests (interface contracts, validation, precedence)
2. P0 Integration tests (end-to-end config loading)
3. P1 Unit tests (error handling, edge cases)
4. P1 Integration tests (parsing, file operations)
5. P0 E2E test (application startup)
6. P2 tests (performance, concurrency)

## Test Implementation Notes

### Unit Test Patterns

- Use table-driven tests for multiple scenarios
- Mock file system operations where possible
- Test error conditions explicitly
- Validate exact precedence order

### Integration Test Setup

- Create temporary directories for config search testing
- Use testdata/vault/lithos.json for real file parsing
- Clean up test files after execution
- Test both success and failure scenarios

### E2E Test Scope

- Test complete application startup with config loading
- Verify config values are used correctly by application
- Test both configured and default scenarios
- Validate error handling prevents invalid startup

## Quality Indicators

- All P0 scenarios covered with multiple test levels
- Critical error paths tested (invalid paths, missing files)
- Precedence logic validated at unit and integration levels
- File system operations tested with real and mock scenarios
- Interface contracts verified through compilation and runtime tests
