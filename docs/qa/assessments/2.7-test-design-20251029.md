# Test Design: Story 2.7 - SchemaResolver Service

**Date:** 2025-10-29
**Designer:** Quinn (Test Architect)
**Story:** 2.7 - SchemaResolver Service
**Epic:** 2 - Configuration & Schema Loading

_Update 2025-10-31: Removed no-op post-hydration substitution; existing unit scenario IDs remain valid._

---

## Test Strategy Overview

- **Total test scenarios:** 15
- **Unit tests:** 15 (100%)
- **Integration tests:** 0 (0%)
- **E2E tests:** 0 (0%)
- **Priority distribution:** P0: 11, P1: 4

**Rationale:** SchemaResolver is pure domain logic responsible for inheritance flattening and `$ref` substitution. All behaviors can be validated using deterministic unit tests that operate on in-memory schema/property fixtures. Coverage focuses on cycle detection, topological ordering, exclusion/override semantics, property bank substitution, immutability, and informative error construction.

---

## Test Scenarios by Acceptance Criteria

### AC 2.7.4-2.7.12: Resolve Algorithm & Property Merge

| ID           | Level | Priority | Test Description                                                                    | Justification                                         |
| ------------ | ----- | -------- | ----------------------------------------------------------------------------------- | ----------------------------------------------------- |
| 2.7-UNIT-001 | Unit  | P0       | Resolve single root schema without Extends returns identical schema copy           | Baseline behavior                                     |
| 2.7-UNIT-002 | Unit  | P0       | Two-level inheritance merges parent properties into child                          | Validates basic inheritance                           |
| 2.7-UNIT-003 | Unit  | P0       | Multi-level inheritance (grandparent → parent → child) resolves in correct order   | Ensures topological traversal                         |
| 2.7-UNIT-004 | Unit  | P0       | Excludes remove inherited properties by name                                        | Confirms exclusion handling                           |
| 2.7-UNIT-005 | Unit  | P0       | Child property overrides parent property of same name                               | Validates override semantics                          |
| 2.7-UNIT-006 | Unit  | P0       | Resolved schema populates ResolvedProperties without mutating original Properties   | Checks copy semantics                                  |
| 2.7-UNIT-007 | Unit  | P0       | $ref substitution replaces property with PropertyBank definition                    | FR5/FR9 requirement                                   |
| 2.7-UNIT-008 | Unit  | P0       | Missing $ref target yields SchemaError with schema/property context                 | Error handling requirement                            |

### AC 2.7.5-2.7.9 & 2.7.16-2.7.19: Graph, Cycles, Immutability, Errors

| ID           | Level | Priority | Test Description                                                                    | Justification                                         |
| ------------ | ----- | -------- | ----------------------------------------------------------------------------------- | ----------------------------------------------------- |
| 2.7-UNIT-009 | Unit  | P0       | Circular inheritance chain detected with full cycle path in error                   | Prevents infinite recursion                           |
| 2.7-UNIT-010 | Unit  | P0       | Resolver does not mutate input slices or schema structs (deep copy check)          | Guarantees immutability                               |
| 2.7-UNIT-011 | Unit  | P1       | Output order preserves topological parent-before-child ordering                     | Helpful for predictable downstream behavior           |
| 2.7-UNIT-012 | Unit  | P1       | Resolved schema retains original Extends/Excludes/Properties fields unchanged       | Documentation requirement                             |

### AC 2.7.13-2.7.15 & 2.7.20-2.7.21: `$ref` & Error Shaping

| ID           | Level | Priority | Test Description                                                                    | Justification                                         |
| ------------ | ----- | -------- | ----------------------------------------------------------------------------------- | ----------------------------------------------------- |
| 2.7-UNIT-013 | Unit  | P0       | Multiple `$ref` properties in a schema resolve using PropertyBank entries           | Ensures batch substitution works                      |
| 2.7-UNIT-014 | Unit  | P0       | Missing parent schema referenced by Extends produces SchemaError with context       | Complements validation safety net                     |
| 2.7-UNIT-015 | Unit  | P1       | Errors use correct SchemaError classification for cycle and missing `$ref` cases    | Downstream error handling relies on types             |

---

## Test Scenario Details

### Happy Path Inheritance & `$ref` (2.7-UNIT-001 through 2.7-UNIT-007, 2.7-UNIT-013)
```go
func TestSchemaResolver_Resolve_Success(t *testing.T) {
    resolver := NewSchemaResolver()

    bank := PropertyBank{Properties: map[string]Property{
        "standard_title": {Name: "title", Required: true},
        "standard_tags":  {Name: "tags", Required: false},
    }}

    schemas := []Schema{
        {
            Name: "base",
            Properties: []Property{{Name: "title", Required: true}},
        },
        {
            Name:    "meeting_note",
            Extends: "base",
            Excludes: []string{"tags"},
            Properties: []Property{
                {Name: "title", Required: false},                    // override
                {Name: "tags", Ref: "standard_tags"},              // inheritance exclusion + ref
                {Name: "agenda", Ref: "standard_title"},           // ref substitution
            },
        },
    }

    resolved, err := resolver.Resolve(context.Background(), schemas, bank)

    require.NoError(t, err)
    child := findSchema(resolved, "meeting_note")
    assert.ElementsMatch(t, []string{"title", "tags", "agenda"}, propertyNames(child.ResolvedProperties))
    assert.False(t, getProperty(child, "title").Required) // override respected
    assert.Equal(t, "tags", getProperty(child, "tags").Name)
    assert.True(t, getProperty(child, "tags").Spec == nil) // simple substitution result
}
```

### Cycle Detection (2.7-UNIT-009)
```go
func TestSchemaResolver_Resolve_CircularInheritance(t *testing.T) {
    resolver := NewSchemaResolver()

    schemas := []Schema{
        {Name: "A", Extends: "B"},
        {Name: "B", Extends: "C"},
        {Name: "C", Extends: "A"},
    }

    _, err := resolver.Resolve(context.Background(), schemas, PropertyBank{})

    require.Error(t, err)
    schemaErr := &SchemaError{}
    require.ErrorAs(t, err, &schemaErr)
    assert.Contains(t, schemaErr.Message, "circular inheritance")
    assert.Contains(t, schemaErr.Message, "A → B → C → A")
}
```

### Immutability (2.7-UNIT-010, 2.7-UNIT-012)
```go
func TestSchemaResolver_Resolve_Immutability(t *testing.T) {
    resolver := NewSchemaResolver()

    original := Schema{
        Name: "note",
        Properties: []Property{{Name: "title", Required: true}},
    }

    _, err := resolver.Resolve(context.Background(), []Schema{original}, PropertyBank{})
    require.NoError(t, err)

    assert.Equal(t, "note", original.Name)
    assert.Equal(t, 1, len(original.Properties))
    assert.Empty(t, original.ResolvedProperties)
}
```

### Missing `$ref` Error (2.7-UNIT-008, 2.7-UNIT-015)
```go
func TestSchemaResolver_Resolve_MissingRef(t *testing.T) {
    resolver := NewSchemaResolver()

    schemas := []Schema{{
        Name: "note",
        Properties: []Property{{Name: "title", Ref: "standard_title"}},
    }}

    _, err := resolver.Resolve(context.Background(), schemas, PropertyBank{})

    require.Error(t, err)
    schemaErr := &SchemaError{}
    require.ErrorAs(t, err, &schemaErr)
    assert.Contains(t, schemaErr.Message, "note")
    assert.Contains(t, schemaErr.Message, "standard_title")
    assert.Equal(t, ErrNotFound, schemaErr.Classification)
}
```

### Missing Parent Error (2.7-UNIT-014)
```go
func TestSchemaResolver_Resolve_MissingParent(t *testing.T) {
    resolver := NewSchemaResolver()

    schemas := []Schema{{Name: "child", Extends: "missing"}}

    _, err := resolver.Resolve(context.Background(), schemas, PropertyBank{})

    require.Error(t, err)
    schemaErr := &SchemaError{}
    require.ErrorAs(t, err, &schemaErr)
    assert.Contains(t, schemaErr.Message, "child")
    assert.Contains(t, schemaErr.Message, "missing")
}
```

---

## Risk Coverage

- **RISK-RES-001:** Parent properties leak without exclusions/overrides → Mitigated by 2.7-UNIT-002 through 2.7-UNIT-005.
- **RISK-RES-002:** Resolved schemas mutate originals → Mitigated by 2.7-UNIT-006, 2.7-UNIT-010, 2.7-UNIT-012.
- **RISK-RES-003:** Cycles cause panic or infinite recursion → Mitigated by 2.7-UNIT-009.
- **RISK-RES-004:** `$ref` substitution fails silently → Mitigated by 2.7-UNIT-007, 2.7-UNIT-008, 2.7-UNIT-013.
- **RISK-RES-005:** Missing parents not caught → Mitigated by 2.7-UNIT-014.
- **RISK-RES-006:** Errors lack actionable detail/classification → Mitigated by 2.7-UNIT-008, 2.7-UNIT-009, 2.7-UNIT-015.

---

## Test Execution Order

1. **Happy path inheritance & substitution:** 2.7-UNIT-001 through 2.7-UNIT-007, 2.7-UNIT-013.
2. **Error conditions:** 2.7-UNIT-008 (missing `$ref`), 2.7-UNIT-014 (missing parent).
3. **Cycle detection:** 2.7-UNIT-009.
4. **Immutability & field preservation:** 2.7-UNIT-010, 2.7-UNIT-012.
5. **Ordering & error classification:** 2.7-UNIT-011, 2.7-UNIT-015.
6. **Regression sweeps:** Re-run happy-path tests after changes to ensure deterministic ordering.

---

## Quality Gates

- ✅ All 11 P0 test scenarios implemented and passing.
- ✅ `go test ./internal/app/schema -race -v` passes (guards future concurrency regressions, even though resolver is synchronous).
- ✅ `golangci-lint run ./internal/app/schema` reports zero issues.
- ✅ Resolved schemas verified to be new copies with expected property sets.
- ✅ Errors expose schema/property context and SchemaError classification.

---

## Edge Cases & Considerations

- Build helper functions in tests (`makeSchema`, `makeProperty`, `findSchema`) to keep fixtures concise.
- When validating ordering, compare against expected slice of schema names after resolution.
- Ensure `$ref` substitution uses deep copies so that modifying resolved properties in tests does not affect the PropertyBank.
- Include tests where Excludes removes all parent properties to avoid nil-slice edge cases.

---

## Summary

This test plan verifies that SchemaResolver:

1. Produces flattened, immutable schema copies honoring inheritance rules.
2. Applies Excludes and overrides exactly as specified.
3. Substitutes `$ref` values using PropertyBank while surfacing missing references.
4. Detects and reports cycles or missing parents with actionable SchemaError details.

Together, the 15 unit tests provide high confidence that the resolver meets architectural expectations before SchemaEngine promotes the resolved schemas to the registry.
