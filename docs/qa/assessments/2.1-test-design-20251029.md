# Test Design: Story 2.1 - Config Domain Model

**Date:** 2025-10-29
**Designer:** Quinn (Test Architect)
**Story:** 2.1 - Config Domain Model
**Epic:** 2 - Configuration & Schema Loading

---

## Test Strategy Overview

- **Total test scenarios:** 12
- **Unit tests:** 12 (100%)
- **Integration tests:** 0 (0%)
- **E2E tests:** 0 (0%)
- **Priority distribution:** P0: 10, P1: 2

**Rationale:** Config is a pure domain model with no external dependencies. All functionality is testable at the unit level through constructor logic, helper methods, and JSON marshaling. No integration or E2E tests are needed as there are no component interactions or user-facing workflows.

---

## Test Scenarios by Acceptance Criteria

### AC 2.1.1-2.1.4: Config Model Structure

**Requirement:** Create Config struct with 6 fields, JSON tags, NewConfig() constructor with defaults, and PropertyBankPath() helper.

#### Scenarios

| ID           | Level | Priority | Test Description                                      | Justification                                    |
| ------------ | ----- | -------- | ----------------------------------------------------- | ------------------------------------------------ |
| 2.1-UNIT-001 | Unit  | P0       | NewConfig with all defaults creates valid Config      | Core constructor behavior, foundational logic    |
| 2.1-UNIT-002 | Unit  | P0       | NewConfig applies VaultPath default to CWD            | Critical default path resolution                 |
| 2.1-UNIT-003 | Unit  | P0       | NewConfig applies TemplatesDir default correctly      | Path construction depends on VaultPath default   |
| 2.1-UNIT-004 | Unit  | P0       | NewConfig applies SchemasDir default correctly        | Path construction depends on VaultPath default   |
| 2.1-UNIT-005 | Unit  | P0       | NewConfig applies PropertyBankFile default            | Default filename must match architecture spec    |
| 2.1-UNIT-006 | Unit  | P0       | NewConfig applies CacheDir default correctly          | Hidden directory path construction               |
| 2.1-UNIT-007 | Unit  | P0       | NewConfig applies LogLevel default to "info"          | Default logging verbosity                        |
| 2.1-UNIT-008 | Unit  | P0       | NewConfig with partial config (mix of values/defaults) | Real-world scenario: some config, some defaults |
| 2.1-UNIT-009 | Unit  | P1       | NewConfig with full config uses provided values       | Verify no defaults override explicit values      |
| 2.1-UNIT-010 | Unit  | P0       | PropertyBankPath() returns correct joined path        | Critical helper method for schema loading        |

**Coverage Notes:**
- Tests 001-007 verify each individual default application
- Test 008 verifies default logic works with partial configuration (most common scenario)
- Test 009 verifies explicit values are not overridden
- Test 010 validates path construction helper

---

### AC 2.1.5-2.1.6: Value Object Semantics

**Requirement:** Config is immutable (no setters), with GoDoc explaining value object semantics.

#### Scenarios

| ID           | Level | Priority | Test Description                              | Justification                             |
| ------------ | ----- | -------- | --------------------------------------------- | ----------------------------------------- |
| 2.1-UNIT-011 | Unit  | P1       | Config has no setter methods (immutability)   | Enforce value object pattern at test time |

**Coverage Notes:**
- This test uses reflection or compile-time verification to ensure no setter methods exist
- Immutability is enforced by struct design (no exported mutator methods)
- GoDoc verification is done through documentation review, not automated tests

---

### AC 2.1.7-2.1.9: Unit Tests & Quality Gates

**Requirement:** Comprehensive unit tests, linting passes, all tests pass.

#### Scenarios

| ID           | Level | Priority | Test Description                        | Justification                                  |
| ------------ | ----- | -------- | --------------------------------------- | ---------------------------------------------- |
| 2.1-UNIT-012 | Unit  | P0       | JSON marshal/unmarshal round-trip       | Serialization integrity for config persistence |

**Coverage Notes:**
- Tests verify JSON struct tags are correct
- Round-trip test ensures no data loss during serialization
- Linting verification (golangci-lint) is part of quality gates, not test scenarios

---

## Test Scenario Details

### Priority P0 Tests (Must Pass - 10 scenarios)

**2.1-UNIT-001: NewConfig with all defaults**
```go
func TestNewConfig_AllDefaults(t *testing.T) {
    cfg := NewConfig("", "", "", "", "", "")

    assert.Equal(t, ".", cfg.VaultPath) // CWD
    assert.Equal(t, filepath.Join(".", "templates"), cfg.TemplatesDir)
    assert.Equal(t, filepath.Join(".", "schemas"), cfg.SchemasDir)
    assert.Equal(t, "property_bank.json", cfg.PropertyBankFile)
    assert.Equal(t, filepath.Join(".", ".lithos", "cache"), cfg.CacheDir)
    assert.Equal(t, "info", cfg.LogLevel)
}
```

**2.1-UNIT-002: VaultPath default to CWD**
```go
func TestNewConfig_VaultPathDefault(t *testing.T) {
    cfg := NewConfig("", "provided-templates", "provided-schemas", "bank.json", "cache", "debug")

    assert.Equal(t, ".", cfg.VaultPath)
    // Verify other provided values are not overridden
    assert.Equal(t, "provided-templates", cfg.TemplatesDir)
}
```

**2.1-UNIT-003: TemplatesDir default**
```go
func TestNewConfig_TemplatesDirDefault(t *testing.T) {
    cfg := NewConfig("/custom/vault", "", "", "", "", "")

    assert.Equal(t, filepath.Join("/custom/vault", "templates"), cfg.TemplatesDir)
}
```

**2.1-UNIT-004: SchemasDir default**
```go
func TestNewConfig_SchemasDirDefault(t *testing.T) {
    cfg := NewConfig("/custom/vault", "", "", "", "", "")

    assert.Equal(t, filepath.Join("/custom/vault", "schemas"), cfg.SchemasDir)
}
```

**2.1-UNIT-005: PropertyBankFile default**
```go
func TestNewConfig_PropertyBankFileDefault(t *testing.T) {
    cfg := NewConfig("", "", "", "", "", "")

    assert.Equal(t, "property_bank.json", cfg.PropertyBankFile)
}
```

**2.1-UNIT-006: CacheDir default**
```go
func TestNewConfig_CacheDirDefault(t *testing.T) {
    cfg := NewConfig("/custom/vault", "", "", "", "", "")

    assert.Equal(t, filepath.Join("/custom/vault", ".lithos", "cache"), cfg.CacheDir)
}
```

**2.1-UNIT-007: LogLevel default**
```go
func TestNewConfig_LogLevelDefault(t *testing.T) {
    cfg := NewConfig("", "", "", "", "", "")

    assert.Equal(t, "info", cfg.LogLevel)
}
```

**2.1-UNIT-008: Partial config with defaults**
```go
func TestNewConfig_PartialConfig(t *testing.T) {
    cfg := NewConfig("/vault", "", "custom-schemas", "", "", "debug")

    assert.Equal(t, "/vault", cfg.VaultPath)
    assert.Equal(t, filepath.Join("/vault", "templates"), cfg.TemplatesDir) // default
    assert.Equal(t, "custom-schemas", cfg.SchemasDir) // provided
    assert.Equal(t, "property_bank.json", cfg.PropertyBankFile) // default
    assert.Equal(t, filepath.Join("/vault", ".lithos", "cache"), cfg.CacheDir) // default
    assert.Equal(t, "debug", cfg.LogLevel) // provided
}
```

**2.1-UNIT-010: PropertyBankPath() helper**
```go
func TestConfig_PropertyBankPath(t *testing.T) {
    cfg := NewConfig("", "", "/custom/schemas", "custom_bank.json", "", "")

    expected := filepath.Join("/custom/schemas", "custom_bank.json")
    assert.Equal(t, expected, cfg.PropertyBankPath())
}
```

**2.1-UNIT-012: JSON round-trip**
```go
func TestConfig_JSONRoundTrip(t *testing.T) {
    original := NewConfig("/vault", "/templates", "/schemas", "bank.json", "/cache", "debug")

    // Marshal to JSON
    jsonData, err := json.Marshal(original)
    require.NoError(t, err)

    // Unmarshal back
    var restored Config
    err = json.Unmarshal(jsonData, &restored)
    require.NoError(t, err)

    // Verify all fields preserved
    assert.Equal(t, original.VaultPath, restored.VaultPath)
    assert.Equal(t, original.TemplatesDir, restored.TemplatesDir)
    assert.Equal(t, original.SchemasDir, restored.SchemasDir)
    assert.Equal(t, original.PropertyBankFile, restored.PropertyBankFile)
    assert.Equal(t, original.CacheDir, restored.CacheDir)
    assert.Equal(t, original.LogLevel, restored.LogLevel)
}
```

### Priority P1 Tests (Should Pass - 2 scenarios)

**2.1-UNIT-009: Full config uses provided values**
```go
func TestNewConfig_FullConfig(t *testing.T) {
    cfg := NewConfig("/vault", "/templates", "/schemas", "bank.json", "/cache", "debug")

    // Verify all provided values are used (no defaults applied)
    assert.Equal(t, "/vault", cfg.VaultPath)
    assert.Equal(t, "/templates", cfg.TemplatesDir)
    assert.Equal(t, "/schemas", cfg.SchemasDir)
    assert.Equal(t, "bank.json", cfg.PropertyBankFile)
    assert.Equal(t, "/cache", cfg.CacheDir)
    assert.Equal(t, "debug", cfg.LogLevel)
}
```

**2.1-UNIT-011: Immutability verification**
```go
func TestConfig_Immutability(t *testing.T) {
    // Verify Config has no setter methods
    configType := reflect.TypeOf(Config{})

    for i := 0; i < configType.NumMethod(); i++ {
        method := configType.Method(i)
        methodName := method.Name

        // Setters typically start with "Set"
        assert.False(t, strings.HasPrefix(methodName, "Set"),
            "Config should not have setter method: %s", methodName)
    }
}
```

---

## Risk Coverage

This story addresses foundational risks:

- **RISK-CONFIG-001**: Invalid default paths cause initialization failures
  - Mitigated by: 2.1-UNIT-002 through 2.1-UNIT-007 (default validation)

- **RISK-CONFIG-002**: Explicit config values are overridden by defaults
  - Mitigated by: 2.1-UNIT-008, 2.1-UNIT-009 (partial and full config tests)

- **RISK-CONFIG-003**: Config mutation causes inconsistent application state
  - Mitigated by: 2.1-UNIT-011 (immutability verification)

- **RISK-CONFIG-004**: Config serialization loses data
  - Mitigated by: 2.1-UNIT-012 (JSON round-trip test)

---

## Test Execution Order

1. **P0 Unit Tests** (fail fast on critical issues):
   - 2.1-UNIT-001: All defaults (foundational)
   - 2.1-UNIT-002 through 2.1-UNIT-007: Individual default tests
   - 2.1-UNIT-008: Partial config (most common scenario)
   - 2.1-UNIT-010: PropertyBankPath helper
   - 2.1-UNIT-012: JSON round-trip

2. **P1 Unit Tests** (nice to have):
   - 2.1-UNIT-009: Full config
   - 2.1-UNIT-011: Immutability verification

---

## Quality Gates

**Required for story completion:**

- ✅ All 10 P0 unit tests pass
- ✅ All 2 P1 unit tests pass
- ✅ `golangci-lint run ./internal/domain` produces zero warnings
- ✅ Test coverage for `config.go` ≥ 90%
- ✅ No race conditions detected by `go test -race`

**Metrics:**
- Expected test execution time: < 50ms (pure unit tests)
- Expected coverage: 95-100% for Config domain model

---

## Edge Cases & Considerations

**Handled by tests:**
- Empty string parameters trigger default logic
- Absolute paths provided directly without modification
- Relative paths composed correctly with VaultPath
- JSON struct tags match snake_case convention

**Out of scope for this story:**
- Path validation (file system checks) - handled by ConfigPort adapter
- Invalid LogLevel handling - handled by Logger package
- VaultPath existence verification - handled by ConfigPort adapter

---

## Dependencies

**Prerequisites:**
- Go stdlib packages: `path/filepath`, `encoding/json`, `reflect`, `strings`
- No external dependencies required

**Downstream consumers (future stories):**
- Story 2.4: SchemaPort and SchemaLoaderAdapter will use Config.SchemasDir
- Story 3.X: CacheAdapters will use Config.CacheDir
- Epic 1.X: TemplateLoaderAdapter will use Config.TemplatesDir

---

## Test Maintenance Considerations

**Low maintenance risk:**
- Pure unit tests with no external dependencies
- Stable domain model (value objects rarely change)
- No brittle test data or fixtures

**Potential future changes:**
- Adding new config fields → Add corresponding default tests
- Changing default values → Update test expectations
- Adding validation → May require new test scenarios

---

## Summary

This test design provides **comprehensive coverage** of the Config domain model through **12 focused unit tests**. The test strategy emphasizes:

1. **Fail-fast approach**: P0 tests catch critical default logic errors immediately
2. **No redundancy**: Each test has a single, clear purpose
3. **High maintainability**: Pure unit tests with no external dependencies
4. **Complete coverage**: Every acceptance criterion has explicit test coverage

The Config model is **ideal for unit testing** - pure domain logic, no infrastructure dependencies, deterministic behavior. No integration or E2E tests are needed.
