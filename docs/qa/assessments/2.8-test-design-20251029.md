# Test Design: Story 2.8 - SchemaEngine Orchestrator

**Date:** 2025-10-29
**Designer:** Quinn (Test Architect)
**Story:** 2.8 - SchemaEngine Orchestrator
**Epic:** 2 - Configuration & Schema Loading

---

## Test Strategy Overview

- **Total test scenarios:** 14
- **Unit tests:** 14 (100%)
- **Integration tests:** 0 (0%)
- **E2E tests:** 0 (0%)
- **Priority distribution:** P0: 10, P1: 4

**Rationale:** SchemaEngine orchestrates the full schema initialization pipeline. Because downstream services rely on its guarantees, we exercise every stage with deterministic fakes, verify error propagation, logging, timing, and generic accessor delegation. No external dependencies are touched—tests operate entirely in-memory with stub loggers.

---

## Test Scenarios by Acceptance Criteria

### AC 2.8.4-2.8.7: Load Pipeline Stages & Error Handling

| ID           | Level | Priority | Test Description                                                                 | Justification                                         |
| ------------ | ----- | -------- | -------------------------------------------------------------------------------- | ----------------------------------------------------- |
| 2.8-UNIT-001 | Unit  | P0       | Load succeeds when all stages pass (loads, validates, resolves, registers)      | Baseline functionality                                |
| 2.8-UNIT-002 | Unit  | P0       | Load fails fast when SchemaPort.Load returns error                              | Ensures fail-fast behavior at stage 1                 |
| 2.8-UNIT-003 | Unit  | P0       | Load fails fast when SchemaValidator.ValidateAll returns error                  | Ensures fail-fast behavior at stage 2                 |
| 2.8-UNIT-004 | Unit  | P0       | Load fails fast when SchemaResolver.Resolve returns error                       | Ensures fail-fast behavior at stage 3                 |
| 2.8-UNIT-005 | Unit  | P0       | Load fails fast when SchemaRegistryPort.RegisterAll returns error               | Ensures fail-fast behavior at stage 4                 |

### AC 2.8.5, 2.8.7: Logging & Timing

| ID           | Level | Priority | Test Description                                                                 | Justification                                         |
| ------------ | ----- | -------- | -------------------------------------------------------------------------------- | ----------------------------------------------------- |
| 2.8-UNIT-006 | Unit  | P0       | Info logs emitted for each stage with durations and counts                       | Observability requirement (NFR3)                      |
| 2.8-UNIT-007 | Unit  | P0       | Error log emitted when a stage fails                                             | Ensures failures are visible                          |

### AC 2.8.8-2.8.10: Generic Accessor Delegation

| ID           | Level | Priority | Test Description                                                                 | Justification                                         |
| ------------ | ----- | -------- | -------------------------------------------------------------------------------- | ----------------------------------------------------- |
| 2.8-UNIT-008 | Unit  | P0       | Get[Schema] delegates to registry and returns schema                            | Confirms generic dispatch                             |
| 2.8-UNIT-009 | Unit  | P0       | Get[Property] delegates to registry and returns property                        | Confirms generic dispatch                             |
| 2.8-UNIT-010 | Unit  | P0       | Get[Schema] propagates ErrNotFound from registry                                | Ensures error behavior preserved                      |
| 2.8-UNIT-011 | Unit  | P1       | Has[Schema]/Has[Property] return bool results from registry without error       | Convenience behavior                                  |

### AC 2.8.11-2.8.13 & Constructor Validation

| ID           | Level | Priority | Test Description                                                                 | Justification                                         |
| ------------ | ----- | -------- | -------------------------------------------------------------------------------- | ----------------------------------------------------- |
| 2.8-UNIT-012 | Unit  | P1       | Constructor panics or errors when required dependencies are nil                  | Prevents misconfiguration                             |
| 2.8-UNIT-013 | Unit  | P0       | Constructor instantiates SchemaValidator and SchemaResolver internally           | Guarantees internal services ready                    |

### AC 2.8.19: Fake Infrastructure & Stage Recording

| ID           | Level | Priority | Test Description                                                                 | Justification                                         |
| ------------ | ----- | -------- | -------------------------------------------------------------------------------- | ----------------------------------------------------- |
| 2.8-UNIT-014 | Unit  | P0       | Stage fakes record call order (load→validate→resolve→register)                  | Confirms orchestration order                          |

---

## Test Scenario Details

### Successful Pipeline (2.8-UNIT-001, 2.8-UNIT-006, 2.8-UNIT-013, 2.8-UNIT-014)
```go
func TestSchemaEngine_Load_Success(t *testing.T) {
    fakePort := &fakeSchemaPort{schemas: []Schema{{Name: "note"}}, bank: PropertyBank{}}
    fakeRegistry := &fakeSchemaRegistryPort{}
    log := newCapturingLogger()

    engine := NewSchemaEngine(fakePort, fakeRegistry, log)

    err := engine.Load(context.Background())
    require.NoError(t, err)

    assert.Equal(t, 1, fakePort.loadCalls)
    assert.Equal(t, 1, fakeRegistry.registerCalls)
    log.AssertHasInfo("loading schemas")
    log.AssertHasInfo("schema engine ready")
}
```

### Stage Failure Propagation (2.8-UNIT-002 through 2.8-UNIT-005, 2.8-UNIT-007)
```go
func TestSchemaEngine_Load_Failures(t *testing.T) {
    cases := map[string]struct {
        portErr      error
        validatorErr error
        resolverErr  error
        registryErr  error
        wantContains string
    }{
        "port":      {portErr: errors.New("load fail"), wantContains: "load fail"},
        "validator": {validatorErr: errors.New("validate fail"), wantContains: "validate fail"},
        "resolver":  {resolverErr: errors.New("resolve fail"), wantContains: "resolve fail"},
        "registry":  {registryErr: errors.New("register fail"), wantContains: "register fail"},
    }

    for name, tc := range cases {
        t.Run(name, func(t *testing.T) {
            port := &fakeSchemaPort{err: tc.portErr}
            registry := &fakeSchemaRegistryPort{err: tc.registryErr}
            log := newCapturingLogger()

            engine := NewSchemaEngine(port, registry, log)
            engine.validator = &fakeValidator{err: tc.validatorErr}
            engine.resolver = &fakeResolver{err: tc.resolverErr}

            err := engine.Load(context.Background())
            require.Error(t, err)
            assert.ErrorContains(t, err, tc.wantContains)
            log.AssertHasError(tc.wantContains)
        })
    }
}
```

### Generic Accessors (2.8-UNIT-008 through 2.8-UNIT-011)
```go
func TestSchemaEngine_GetAndHas(t *testing.T) {
    registry := &fakeSchemaRegistryPort{
        schemas: map[string]Schema{"note": {Name: "note"}},
        properties: map[string]Property{"standard_title": {Name: "title"}},
    }
    engine := NewSchemaEngine(&fakeSchemaPort{}, registry, newCapturingLogger())

    schema, err := engine.Get[Schema](context.Background(), "note")
    require.NoError(t, err)
    assert.Equal(t, "note", schema.Name)

    prop, err := engine.Get[Property](context.Background(), "standard_title")
    require.NoError(t, err)
    assert.Equal(t, "title", prop.Name)

    _, err = engine.Get[Schema](context.Background(), "missing")
    require.Error(t, err)

    assert.True(t, engine.Has[Schema](context.Background(), "note"))
    assert.False(t, engine.Has[Property](context.Background(), "missing"))
}
```

### Constructor Validation (2.8-UNIT-012, 2.8-UNIT-013)
```go
func TestNewSchemaEngine_DependencyValidation(t *testing.T) {
    assert.Panics(t, func() { NewSchemaEngine(nil, &fakeSchemaRegistryPort{}, newCapturingLogger()) })
    assert.Panics(t, func() { NewSchemaEngine(&fakeSchemaPort{}, nil, newCapturingLogger()) })
    assert.Panics(t, func() { NewSchemaEngine(&fakeSchemaPort{}, &fakeSchemaRegistryPort{}, nil) })

    engine := NewSchemaEngine(&fakeSchemaPort{}, &fakeSchemaRegistryPort{}, newCapturingLogger())
    assert.NotNil(t, engine.validator)
    assert.NotNil(t, engine.resolver)
}
```

### Stage Ordering (2.8-UNIT-014)
```go
func TestSchemaEngine_Load_StageOrder(t *testing.T) {
    recorder := &stageRecorder{}
    engine := &SchemaEngine{
        schemaPort: recorder,
        registry:   recorder,
        validator:  recorder,
        resolver:   recorder,
        log:        newCapturingLogger(),
    }

    err := engine.Load(context.Background())
    require.NoError(t, err)
    assert.Equal(t, []string{"load", "validate", "resolve", "register"}, recorder.calls)
}
```

---

## Risk Coverage

- **RISK-ENG-001:** Pipeline silently skips a stage → Mitigated by 2.8-UNIT-014 and logging checks.
- **RISK-ENG-002:** Errors swallowed or misreported → Mitigated by 2.8-UNIT-002 through 2.8-UNIT-007.
- **RISK-ENG-003:** Accessors bypass registry invariants → Mitigated by 2.8-UNIT-008 through 2.8-UNIT-011.
- **RISK-ENG-004:** Constructor misconfiguration leads to nil dereferences → Mitigated by 2.8-UNIT-012, 2.8-UNIT-013.
- **RISK-ENG-005:** Logging omits critical observability data → Mitigated by 2.8-UNIT-006, 2.8-UNIT-007.

---

## Test Execution Order

1. **Constructor validation:** 2.8-UNIT-012, 2.8-UNIT-013.
2. **Happy path pipeline:** 2.8-UNIT-001, 2.8-UNIT-006, 2.8-UNIT-014.
3. **Stage failure matrix:** 2.8-UNIT-002 through 2.8-UNIT-005, 2.8-UNIT-007.
4. **Accessor delegation:** 2.8-UNIT-008 through 2.8-UNIT-011.
5. **Regression sweeps:** Re-run happy path to ensure log assertions stay stable after changes.

---

## Quality Gates

- ✅ All 10 P0 scenarios implemented and passing.
- ✅ `go test ./internal/app/schema -race -v` passes.
- ✅ `golangci-lint run ./internal/app/schema` reports zero issues.
- ✅ Capturing logger asserts presence of stage logs and durations.
- ✅ Fakes validate stage order and call counts without using external mocks.

---

## Edge Cases & Considerations

- Use a monotonic clock (e.g., `time.Since`) in production code; tests can inject a fake timer if needed to ensure durations are recorded.
- Ensure Load() can be called only once or document behavior if repeated (tests should confirm the designed behavior, e.g., idempotent or guarded).
- When asserting logs, allow tolerance for duration formatting by matching substrings rather than full message equality.
- Keep fakes minimal but thread-safe if concurrency is introduced later.

---

## Summary

The SchemaEngine tests ensure:

1. Stage orchestration follows the documented order and fails fast on errors.
2. Logging provides full visibility into each stage’s duration and error paths.
3. Generic accessors delegate to the registry without bypassing domain rules.
4. Constructor safeguards guarantee internal validator/resolver availability.

These 14 unit tests give confidence that SchemaEngine is a reliable entry point for schema initialization before downstream services consume registry data.
