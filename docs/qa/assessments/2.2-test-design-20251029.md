# Test Design: Story 2.2 - Property & PropertySpec Models

**Date:** 2025-10-29
**Designer:** Quinn (Test Architect)
**Story:** 2.2 - Property & PropertySpec Models
**Epic:** 2 - Configuration & Schema Loading

---

## Test Strategy Overview

- **Total test scenarios:** 35
- **Unit tests:** 35 (100%)
- **Integration tests:** 0 (0%)
- **E2E tests:** 0 (0%)
- **Priority distribution:** P0: 29, P1: 6

**Rationale:** Property and PropertySpec models are rich domain models with validation behavior but no external dependencies (only stdlib regex and time). All functionality is testable at the unit level. These models are foundational for schema validation, making comprehensive test coverage critical for data integrity.

---

## Test Scenarios by Acceptance Criteria

### AC 2.2.1-2.2.3: Property Model Structure

**Requirement:** Create Property struct with Name, Required, Array, Spec fields and Validate() method.

#### Scenarios

| ID           | Level | Priority | Test Description                                   | Justification                                |
| ------------ | ----- | -------- | -------------------------------------------------- | -------------------------------------------- |
| 2.2-UNIT-001 | Unit  | P0       | Property.Validate() succeeds with valid structure  | Happy path validation must work              |
| 2.2-UNIT-002 | Unit  | P0       | Property.Validate() fails when Name is empty       | Critical structural validation               |
| 2.2-UNIT-003 | Unit  | P0       | Property.Validate() fails when Spec is nil         | Critical structural validation               |
| 2.2-UNIT-004 | Unit  | P0       | Property.Validate() delegates to Spec.Validate()   | Polymorphic validation pattern must work     |
| 2.2-UNIT-005 | Unit  | P0       | Property.Validate() wraps Spec errors with context | Error messages must be informative           |

---

### AC 2.2.4-2.2.5: PropertySpec Interface

**Requirement:** Define PropertySpec interface and PropertySpecType enum.

#### Scenarios

| ID           | Level | Priority | Test Description                               | Justification                            |
| ------------ | ----- | -------- | ---------------------------------------------- | ---------------------------------------- |
| 2.2-UNIT-006 | Unit  | P1       | PropertySpecType constants have correct values     | Verify enum string values match spec     |
| 2.2-UNIT-007 | Unit  | P0       | Each PropertySpec variant implements interface | Compile-time verification via test types |

---

### AC 2.2.6-2.2.8: StringSpec Implementation

**Requirement:** StringSpec with Enum and Pattern, validation for regex Pattern.

#### Scenarios

| ID           | Level | Priority | Test Description                                          | Justification                            |
| ------------ | ----- | -------- | --------------------------------------------------------- | ---------------------------------------- |
| 2.2-UNIT-008 | Unit  | P0       | StringSpec.Type() returns PropertyTypeString              | Type identification must be correct      |
| 2.2-UNIT-009 | Unit  | P0       | StringSpec.Validate() succeeds with valid Pattern         | Valid regex must pass                    |
| 2.2-UNIT-010 | Unit  | P0       | StringSpec.Validate() fails with invalid Pattern regex    | Invalid regex must be caught early       |
| 2.2-UNIT-011 | Unit  | P0       | StringSpec.Validate() succeeds with empty Pattern         | Empty pattern means no constraint        |
| 2.2-UNIT-012 | Unit  | P1       | StringSpec.Validate() succeeds with Enum list             | Enum doesn't need validation             |
| 2.2-UNIT-013 | Unit  | P1       | StringSpec.Validate() succeeds with both Enum and Pattern | Combined constraints are valid           |
| 2.2-UNIT-014 | Unit  | P1       | StringSpec JSON round-trip preserves data                 | Serialization integrity                  |

---

### AC 2.2.9-2.2.11: NumberSpec Implementation

**Requirement:** NumberSpec with Min, Max, Step pointer fields, validation for constraints.

#### Scenarios

| ID           | Level | Priority | Test Description                                    | Justification                       |
| ------------ | ----- | -------- | --------------------------------------------------- | ----------------------------------- |
| 2.2-UNIT-015 | Unit  | P0       | NumberSpec.Type() returns PropertyTypeNumber        | Type identification must be correct |
| 2.2-UNIT-016 | Unit  | P0       | NumberSpec.Validate() succeeds with valid Min/Max   | Valid range must pass               |
| 2.2-UNIT-017 | Unit  | P0       | NumberSpec.Validate() fails when Min > Max          | Logical constraint violation        |
| 2.2-UNIT-018 | Unit  | P0       | NumberSpec.Validate() succeeds with valid Step      | Positive step must pass             |
| 2.2-UNIT-019 | Unit  | P0       | NumberSpec.Validate() fails when Step <= 0          | Step must be positive               |
| 2.2-UNIT-020 | Unit  | P1       | NumberSpec.Validate() succeeds with nil pointers    | Nil means no constraint             |
| 2.2-UNIT-021 | Unit  | P1       | NumberSpec.Validate() succeeds with Min only        | Partial constraints are valid       |
| 2.2-UNIT-022 | Unit  | P1       | NumberSpec.Validate() succeeds with Max only        | Partial constraints are valid       |
| 2.2-UNIT-023 | Unit  | P0       | NumberSpec.Validate() allows Min == Max (boundary)  | Equality is valid constraint        |
| 2.2-UNIT-024 | Unit  | P1       | NumberSpec JSON round-trip preserves pointer values | Serialization handles nil pointers  |

---

### AC 2.2.12-2.2.14: BoolSpec Implementation

**Requirement:** BoolSpec as empty struct, always valid.

#### Scenarios

| ID           | Level | Priority | Test Description                              | Justification                       |
| ------------ | ----- | -------- | --------------------------------------------- | ----------------------------------- |
| 2.2-UNIT-025 | Unit  | P0       | BoolSpec.Type() returns PropertyTypeBool      | Type identification must be correct |
| 2.2-UNIT-026 | Unit  | P0       | BoolSpec.Validate() always returns nil        | No constraints to validate          |
| 2.2-UNIT-027 | Unit  | P1       | BoolSpec JSON round-trip works (empty struct) | Serialization of marker type        |

---

### AC 2.2.15-2.2.17: DateSpec Implementation

**Requirement:** DateSpec with Format field, validation for Go time layout.

#### Scenarios

| ID           | Level | Priority | Test Description                                              | Justification                           |
| ------------ | ----- | -------- | ------------------------------------------------------------- | --------------------------------------- |
| 2.2-UNIT-028 | Unit  | P0       | DateSpec.Type() returns PropertyTypeDate                      | Type identification must be correct     |
| 2.2-UNIT-029 | Unit  | P0       | DateSpec.Validate() succeeds with valid Go time layout        | Valid format must pass                  |
| 2.2-UNIT-030 | Unit  | P0       | DateSpec.Validate() fails with invalid Go time layout         | Invalid format must be caught early     |
| 2.2-UNIT-031 | Unit  | P1       | DateSpec.Validate() succeeds with empty Format (RFC3339 default) | Empty means RFC3339 default          |
| 2.2-UNIT-032 | Unit  | P1       | DateSpec JSON round-trip preserves Format                     | Serialization integrity                 |

---

### AC 2.2.18-2.2.20: FileSpec Implementation

**Requirement:** FileSpec with FileClass and Directory regex patterns, handles negation prefix.

#### Scenarios

| ID           | Level | Priority | Test Description                                          | Justification                               |
| ------------ | ----- | -------- | --------------------------------------------------------- | ------------------------------------------- |
| 2.2-UNIT-033 | Unit  | P0       | FileSpec.Type() returns PropertyTypeFile                  | Type identification must be correct         |
| 2.2-UNIT-034 | Unit  | P0       | FileSpec.Validate() succeeds with valid FileClass pattern | Valid regex must pass                       |
| 2.2-UNIT-035 | Unit  | P0       | FileSpec.Validate() fails with invalid FileClass regex    | Invalid regex must be caught early          |
| 2.2-UNIT-036 | Unit  | P0       | FileSpec.Validate() succeeds with valid Directory pattern | Valid regex must pass                       |
| 2.2-UNIT-037 | Unit  | P0       | FileSpec.Validate() fails with invalid Directory regex    | Invalid regex must be caught early          |
| 2.2-UNIT-038 | Unit  | P0       | FileSpec.Validate() handles negation prefix (^) correctly | Negation is stripped before regex compile   |
| 2.2-UNIT-039 | Unit  | P1       | FileSpec.Validate() succeeds with both filters            | Combined filters are valid                  |
| 2.2-UNIT-040 | Unit  | P1       | FileSpec.Validate() succeeds with empty fields            | Empty means no constraint                   |
| 2.2-UNIT-041 | Unit  | P1       | FileSpec JSON round-trip preserves patterns               | Serialization integrity                     |

---

## Test Scenario Details

### Property Model Tests (P0)

**2.2-UNIT-001: Valid Property structure**
```go
func TestProperty_Validate_Success(t *testing.T) {
    property := Property{
        Name:     "title",
        Required: true,
        Array:    false,
        Spec:     StringSpec{},
    }

    err := property.Validate(context.Background())
    assert.NoError(t, err)
}
```

**2.2-UNIT-002: Empty Name fails**
```go
func TestProperty_Validate_EmptyName(t *testing.T) {
    property := Property{
        Name:     "",
        Required: true,
        Spec:     StringSpec{},
    }

    err := property.Validate(context.Background())
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "name cannot be empty")
}
```

**2.2-UNIT-003: Nil Spec fails**
```go
func TestProperty_Validate_NilSpec(t *testing.T) {
    property := Property{
        Name:     "title",
        Required: true,
        Spec:     nil,
    }

    err := property.Validate(context.Background())
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "spec cannot be nil")
}
```

**2.2-UNIT-004: Delegates to Spec.Validate()**
```go
func TestProperty_Validate_DelegatesToSpec(t *testing.T) {
    // Use StringSpec with invalid pattern
    property := Property{
        Name:     "title",
        Required: true,
        Spec:     StringSpec{Pattern: "[invalid"},
    }

    err := property.Validate(context.Background())
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "property title") // Context wrapping
    assert.Contains(t, err.Error(), "invalid pattern") // Spec error
}
```

---

### StringSpec Tests

**2.2-UNIT-009: Valid Pattern**
```go
func TestStringSpec_Validate_ValidPattern(t *testing.T) {
    spec := StringSpec{Pattern: "^[A-Z][a-z]+$"}

    err := spec.Validate(context.Background())
    assert.NoError(t, err)
}
```

**2.2-UNIT-010: Invalid Pattern**
```go
func TestStringSpec_Validate_InvalidPattern(t *testing.T) {
    spec := StringSpec{Pattern: "[invalid"}

    err := spec.Validate(context.Background())
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "invalid pattern regex")
}
```

**2.2-UNIT-011: Empty Pattern succeeds**
```go
func TestStringSpec_Validate_EmptyPattern(t *testing.T) {
    spec := StringSpec{Pattern: ""}

    err := spec.Validate(context.Background())
    assert.NoError(t, err)
}
```

---

### NumberSpec Tests

**2.2-UNIT-016: Valid Min/Max range**
```go
func TestNumberSpec_Validate_ValidRange(t *testing.T) {
    min, max := 0.0, 100.0
    spec := NumberSpec{Min: &min, Max: &max}

    err := spec.Validate(context.Background())
    assert.NoError(t, err)
}
```

**2.2-UNIT-017: Min > Max fails**
```go
func TestNumberSpec_Validate_MinGreaterThanMax(t *testing.T) {
    min, max := 100.0, 0.0
    spec := NumberSpec{Min: &min, Max: &max}

    err := spec.Validate(context.Background())
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "min")
    assert.Contains(t, err.Error(), "cannot be greater than max")
}
```

**2.2-UNIT-019: Step <= 0 fails**
```go
func TestNumberSpec_Validate_InvalidStep(t *testing.T) {
    tests := []struct{
        name string
        step float64
    }{
        {"zero step", 0.0},
        {"negative step", -1.0},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            spec := NumberSpec{Step: &tt.step}

            err := spec.Validate(context.Background())
            assert.Error(t, err)
            assert.Contains(t, err.Error(), "step must be positive")
        })
    }
}
```

**2.2-UNIT-023: Min == Max boundary case**
```go
func TestNumberSpec_Validate_MinEqualsMax(t *testing.T) {
    value := 42.0
    spec := NumberSpec{Min: &value, Max: &value}

    err := spec.Validate(context.Background())
    assert.NoError(t, err)
}
```

---

### DateSpec Tests

**2.2-UNIT-029: Valid Go time layout**
```go
func TestDateSpec_Validate_ValidFormat(t *testing.T) {
    tests := []struct{
        name   string
        format string
    }{
        {"RFC3339", time.RFC3339},
        {"custom", "2006-01-02"},
        {"with time", "2006-01-02 15:04:05"},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            spec := DateSpec{Format: tt.format}

            err := spec.Validate(context.Background())
            assert.NoError(t, err)
        })
    }
}
```

**2.2-UNIT-030: Invalid Go time layout**
```go
func TestDateSpec_Validate_InvalidFormat(t *testing.T) {
    spec := DateSpec{Format: "YYYY-MM-DD"} // Invalid: not Go layout

    err := spec.Validate(context.Background())
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "invalid")
}
```

---

### FileSpec Tests

**2.2-UNIT-034: Valid FileClass pattern**
```go
func TestFileSpec_Validate_ValidFileClass(t *testing.T) {
    spec := FileSpec{FileClass: "note|article"}

    err := spec.Validate(context.Background())
    assert.NoError(t, err)
}
```

**2.2-UNIT-038: Negation prefix handling**
```go
func TestFileSpec_Validate_NegationPrefix(t *testing.T) {
    tests := []struct{
        name    string
        pattern string
        valid   bool
    }{
        {"valid negation", "^note", true},
        {"invalid negation", "^[invalid", false},
        {"valid without negation", "note", true},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            spec := FileSpec{FileClass: tt.pattern}

            err := spec.Validate(context.Background())
            if tt.valid {
                assert.NoError(t, err)
            } else {
                assert.Error(t, err)
            }
        })
    }
}
```

---

## Risk Coverage

This story addresses critical schema validation risks:

- **RISK-PROP-001**: Invalid Property structure causes schema validation failures
  - Mitigated by: 2.2-UNIT-001 through 2.2-UNIT-005 (Property validation)

- **RISK-PROP-002**: Invalid regex patterns cause runtime panics during frontmatter validation
  - Mitigated by: 2.2-UNIT-010 (StringSpec), 2.2-UNIT-035, 2.2-UNIT-037 (FileSpec)

- **RISK-PROP-003**: Illogical number constraints cause validation confusion
  - Mitigated by: 2.2-UNIT-017, 2.2-UNIT-019 (NumberSpec validation)

- **RISK-PROP-004**: Invalid date formats cause parsing failures
  - Mitigated by: 2.2-UNIT-030 (DateSpec validation)

- **RISK-PROP-005**: Polymorphic validation breaks type-specific behavior
  - Mitigated by: 2.2-UNIT-004, 2.2-UNIT-007 (interface delegation)

---

## Test Execution Order

1. **P0 Unit Tests** (fail fast on critical issues):
   - Property model tests (2.2-UNIT-001 through 2.2-UNIT-005)
   - Type() method tests for all variants (2.2-UNIT-008, 015, 025, 028, 033)
   - Critical validation tests for each spec (2.2-UNIT-009, 010, 017, 019, 029, 030, 034, 035, 037, 038)

2. **P1 Unit Tests** (edge cases and completeness):
   - PropertySpecType enum verification (2.2-UNIT-006)
   - Interface implementation (2.2-UNIT-007)
   - Optional constraint tests (nil pointers, empty strings)
   - JSON serialization tests

---

## Quality Gates

**Required for story completion:**

- ✅ All 29 P0 unit tests pass
- ✅ All 6 P1 unit tests pass (35 total)
- ✅ `golangci-lint run ./internal/domain` produces zero warnings
- ✅ Test coverage for `property.go` and `property_spec.go` ≥ 95%
- ✅ No race conditions detected by `go test -race`

**Metrics:**
- Expected test execution time: < 100ms (pure unit tests, some regex compilation)
- Expected coverage: 95-100% for Property and PropertySpec models

---

## Edge Cases & Considerations

**Handled by tests:**
- Empty strings vs nil pointers (different semantics)
- Negation prefix (^) in FileSpec patterns
- Min == Max boundary case for NumberSpec
- Invalid regex patterns caught early
- Invalid Go time layouts caught early
- Polymorphic delegation via interface

**Out of scope for this story:**
- Actual value validation (e.g., testing if "abc" matches pattern) - handled by FrontmatterService (Epic 3)
- Schema resolution and inheritance - handled by SchemaResolver (Story 2.7)
- PropertyBank integration - handled by Story 2.3

---

## Dependencies

**Prerequisites:**
- Go stdlib packages: `context`, `regexp`, `time`, `encoding/json`, `reflect`, `strings`, `fmt`
- Error types from Story 1.4: `ValidationError`
- No external dependencies required

**Downstream consumers (future stories):**
- Story 2.3: PropertyBank uses Property definitions
- Story 2.4: SchemaLoader deserializes PropertySpec variants
- Story 2.6: SchemaValidator calls Property.Validate()
- Epic 3: FrontmatterService uses PropertySpec for value validation

---

## Test Maintenance Considerations

**Moderate maintenance risk:**
- Pure unit tests but more complex than Story 2.1
- Regex and time layout validation adds edge cases
- Polymorphism requires careful interface testing

**Potential future changes:**
- Adding new PropertySpec variants → Add new test suites
- Changing validation rules → Update expectations
- Adding new constraint fields → Add corresponding tests

---

## Summary

This test design provides **comprehensive coverage** of Property and PropertySpec models through **35 focused unit tests**. The test strategy emphasizes:

1. **Polymorphic validation testing**: Ensures interface delegation works correctly
2. **Regex and format validation**: Catches invalid patterns early (before runtime)
3. **Constraint logic testing**: Validates NumberSpec, DateSpec, FileSpec constraints
4. **Edge case coverage**: Nil pointers, empty strings, negation prefixes, boundaries
5. **Type safety**: Verifies all PropertySpec variants implement interface

These rich domain models are **critical for schema validation integrity**. The 29 P0 tests ensure data corruption and runtime panics are prevented through rigorous structural validation.
