# Test Design: Story 2.3 - PropertyBank Domain Model

**Date:** 2025-10-29
**Designer:** Quinn (Test Architect)
**Story:** 2.3 - PropertyBank Domain Model
**Epic:** 2 - Configuration & Schema Loading

---

## Test Strategy Overview

- **Total test scenarios:** 12
- **Unit tests:** 12 (100%)
- **Integration tests:** 0 (0%)
- **E2E tests:** 0 (0%)
- **Priority distribution:** P0: 11, P1: 1

**Rationale:** PropertyBank is a singleton registry domain model with validation behavior. All functionality is testable at the unit level through constructor validation (now decomposed into private helper methods), lookup operations, and JSON deserialization. Tests also verify that the constructor clones the input map to protect the singleton instance while future integration work will exercise the `sync.Once` loader.

---

## Test Scenarios by Acceptance Criteria

### AC 2.3.1-2.3.3: PropertyBank Model Structure & Constructor

**Requirement:** PropertyBank struct with Properties map, NewPropertyBank() constructor with validation.

#### Scenarios

| ID           | Level | Priority | Test Description                                        | Justification                                  |
| ------------ | ----- | -------- | ------------------------------------------------------- | ---------------------------------------------- |
| 2.3-UNIT-001 | Unit  | P0       | NewPropertyBank() succeeds with valid properties        | Happy path must work                                            |
| 2.3-UNIT-002 | Unit  | P0       | NewPropertyBank() fails with empty property ID (key)    | Property IDs must be non-empty                                  |
| 2.3-UNIT-003 | Unit  | P0       | NewPropertyBank() fails with invalid property structure | Must delegate validation to Property.Validate()                 |
| 2.3-UNIT-004 | Unit  | P0       | NewPropertyBank() returns multiple validation errors    | Must report ALL validation issues, not just first               |
| 2.3-UNIT-005 | Unit  | P0       | NewPropertyBank() clones input map to enforce isolation | Private helper must prevent aliasing of caller-provided maps    |
| 2.3-UNIT-006 | Unit  | P1       | NewPropertyBank() succeeds with empty map               | Empty bank is valid (no properties defined yet)                 |

---

### AC 2.3.6-2.3.7: Read-Only Access via Lookup()

**Requirement:** Lookup() method provides read-only access without exposing internal map.

#### Scenarios

| ID           | Level | Priority | Test Description                               | Justification                           |
| ------------ | ----- | -------- | ---------------------------------------------- | --------------------------------------- |
| 2.3-UNIT-007 | Unit  | P0       | Lookup() returns property when ID exists       | Primary lookup behavior                 |
| 2.3-UNIT-008 | Unit  | P0       | Lookup() returns false when ID not found       | Not-found path must work                |
| 2.3-UNIT-009 | Unit  | P0       | Lookup() returns copy, not reference           | Immutability protection                 |

---

### AC 2.3.11-2.3.13: JSON Deserialization & Test Fixture

**Requirement:** JSON unmarshalling from test fixture, verify structure.

#### Scenarios

| ID           | Level | Priority | Test Description                                              | Justification                        |
| ------------ | ----- | -------- | ------------------------------------------------------------- | ------------------------------------ |
| 2.3-UNIT-010 | Unit  | P0       | JSON unmarshal from fixture creates valid PropertyBank        | Serialization integrity              |
| 2.3-UNIT-011 | Unit  | P0       | JSON unmarshal verifies standard_title property structure     | Fixture validation: string property  |
| 2.3-UNIT-012 | Unit  | P0       | JSON unmarshal verifies standard_tags and iso_date properties | Fixture validation: array & date     |

---

## Test Scenario Details

### Constructor Tests (P0)

**2.3-UNIT-001: Valid PropertyBank**
```go
func TestNewPropertyBank_Success(t *testing.T) {
    properties := map[string]Property{
        "standard_title": {
            Name:     "title",
            Required: true,
            Array:    false,
            Spec:     StringSpec{Pattern: "^.{1,200}$"},
        },
        "standard_tags": {
            Name:     "tags",
            Required: false,
            Array:    true,
            Spec:     StringSpec{},
        },
    }

    bank, err := NewPropertyBank(properties)

    require.NoError(t, err)
    require.NotNil(t, bank)
    assert.Len(t, bank.Properties, 2)
}
```

**2.3-UNIT-002: Empty property ID fails**
```go
func TestNewPropertyBank_EmptyPropertyID(t *testing.T) {
    properties := map[string]Property{
        "": { // Empty key
            Name:     "title",
            Required: true,
            Spec:     StringSpec{},
        },
    }

    bank, err := NewPropertyBank(properties)

    assert.Error(t, err)
    assert.Nil(t, bank)
    assert.Contains(t, err.Error(), "property ID cannot be empty")
}
```

**2.3-UNIT-003: Invalid property structure**
```go
func TestNewPropertyBank_InvalidProperty(t *testing.T) {
    properties := map[string]Property{
        "invalid_prop": {
            Name:     "", // Invalid: empty name
            Required: true,
            Spec:     StringSpec{},
        },
    }

    bank, err := NewPropertyBank(properties)

    assert.Error(t, err)
    assert.Nil(t, bank)
    assert.Contains(t, err.Error(), "invalid_prop") // Context
    assert.Contains(t, err.Error(), "name") // Delegated error
}
```

**2.3-UNIT-004: Multiple validation errors**
```go
func TestNewPropertyBank_MultipleErrors(t *testing.T) {
    properties := map[string]Property{
        "": { // Error 1: empty ID
            Name:     "title",
            Required: true,
            Spec:     StringSpec{},
        },
        "invalid_prop": { // Error 2: empty name
            Name:     "",
            Required: true,
            Spec:     StringSpec{},
        },
        "bad_spec": { // Error 3: nil spec
            Name:     "field",
            Required: true,
            Spec:     nil,
        },
    }

    bank, err := NewPropertyBank(properties)

    assert.Error(t, err)
    assert.Nil(t, bank)

    // Verify all errors are reported
    errStr := err.Error()
    assert.Contains(t, errStr, "property ID cannot be empty")
    assert.Contains(t, errStr, "invalid_prop")
    assert.Contains(t, errStr, "bad_spec")
}
```

**2.3-UNIT-005: Constructor clones input map**
```go
func TestNewPropertyBank_InputMapIsolation(t *testing.T) {
    properties := map[string]Property{
        "standard_title": {
            Name:     "title",
            Required: true,
            Spec:     StringSpec{},
        },
    }

    bank, err := NewPropertyBank(properties)
    require.NoError(t, err)

    // Mutate the original map after construction
    properties["standard_title"] = Property{Name: "mutated"}
    delete(properties, "standard_title")

    // Bank retains original copy
    prop, found := bank.Lookup("standard_title")
    assert.True(t, found)
    assert.Equal(t, "title", prop.Name)
}
```

**2.3-UNIT-006: Constructor accepts empty map**
```go
func TestNewPropertyBank_EmptyMap(t *testing.T) {
    bank, err := NewPropertyBank(map[string]Property{})

    assert.NoError(t, err)
    assert.NotNil(t, bank)
    assert.Empty(t, bank.Properties)
}
```

---

### Lookup Tests (P0)

**2.3-UNIT-007: Lookup succeeds**
```go
func TestPropertyBank_Lookup_Found(t *testing.T) {
    properties := map[string]Property{
        "standard_title": {
            Name:     "title",
            Required: true,
            Spec:     StringSpec{Pattern: "^.{1,200}$"},
        },
    }
    bank, _ := NewPropertyBank(properties)

    prop, found := bank.Lookup("standard_title")

    assert.True(t, found)
    assert.Equal(t, "title", prop.Name)
    assert.True(t, prop.Required)
}
```

**2.3-UNIT-008: Lookup not found**
```go
func TestPropertyBank_Lookup_NotFound(t *testing.T) {
    properties := map[string]Property{
        "standard_title": {
            Name:     "title",
            Required: true,
            Spec:     StringSpec{},
        },
    }
    bank, _ := NewPropertyBank(properties)

    prop, found := bank.Lookup("nonexistent")

    assert.False(t, found)
    assert.Equal(t, Property{}, prop) // Zero value
}
```

**2.3-UNIT-009: Lookup returns copy (immutability)**
```go
func TestPropertyBank_Lookup_ReturnsCopy(t *testing.T) {
    properties := map[string]Property{
        "standard_title": {
            Name:     "title",
            Required: true,
            Spec:     StringSpec{},
        },
    }
    bank, _ := NewPropertyBank(properties)

    // Get property and attempt mutation
    prop1, _ := bank.Lookup("standard_title")
    prop1.Name = "MUTATED"

    // Get again and verify original unchanged
    prop2, _ := bank.Lookup("standard_title")
    assert.Equal(t, "title", prop2.Name)
    assert.NotEqual(t, "MUTATED", prop2.Name)
}
```

---

### JSON Deserialization Tests (P0)

**2.3-UNIT-010: Unmarshal from fixture**
```go
func TestPropertyBank_JSONUnmarshal_FromFixture(t *testing.T) {
    // Read test fixture
    data, err := os.ReadFile("testdata/schemas/property_bank.json")
    require.NoError(t, err)

    // Unmarshal to struct matching JSON structure
    var bankData struct {
        Properties map[string]Property `json:"properties"`
    }
    err = json.Unmarshal(data, &bankData)
    require.NoError(t, err)

    // Create PropertyBank
    bank, err := NewPropertyBank(bankData.Properties)

    require.NoError(t, err)
    assert.Len(t, bank.Properties, 3) // standard_title, standard_tags, iso_date
}
```

**2.3-UNIT-011: Verify standard_title from fixture**
```go
func TestPropertyBank_JSONUnmarshal_StandardTitle(t *testing.T) {
    // Read and unmarshal fixture
    data, _ := os.ReadFile("testdata/schemas/property_bank.json")
    var bankData struct {
        Properties map[string]Property `json:"properties"`
    }
    json.Unmarshal(data, &bankData)
    bank, _ := NewPropertyBank(bankData.Properties)

    // Verify standard_title property
    prop, found := bank.Lookup("standard_title")

    assert.True(t, found)
    assert.Equal(t, "title", prop.Name)
    assert.True(t, prop.Required)
    assert.False(t, prop.Array)

    // Verify StringSpec
    stringSpec, ok := prop.Spec.(StringSpec)
    assert.True(t, ok)
    assert.Equal(t, "^.{1,200}$", stringSpec.Pattern)
}
```

**2.3-UNIT-012: Verify standard_tags and iso_date**
```go
func TestPropertyBank_JSONUnmarshal_StandardTagsAndDate(t *testing.T) {
    // Read and unmarshal fixture
    data, _ := os.ReadFile("testdata/schemas/property_bank.json")
    var bankData struct {
        Properties map[string]Property `json:"properties"`
    }
    json.Unmarshal(data, &bankData)
    bank, _ := NewPropertyBank(bankData.Properties)

    // Verify standard_tags (array property)
    tags, found := bank.Lookup("standard_tags")
    assert.True(t, found)
    assert.Equal(t, "tags", tags.Name)
    assert.False(t, tags.Required)
    assert.True(t, tags.Array)

    // Verify iso_date (date property)
    date, found := bank.Lookup("iso_date")
    assert.True(t, found)
    assert.Equal(t, "date", date.Name)
    assert.True(t, date.Required)

    // Verify DateSpec
    dateSpec, ok := date.Spec.(DateSpec)
    assert.True(t, ok)
    assert.Equal(t, "2006-01-02", dateSpec.Format)
}
```

---

## Risk Coverage

This story addresses critical $ref resolution risks:

- **RISK-BANK-001**: Invalid PropertyBank causes schema loading failures
  - Mitigated by: 2.3-UNIT-001 through 2.3-UNIT-004 (constructor validation)

- **RISK-BANK-002**: Empty property IDs cause $ref resolution failures
  - Mitigated by: 2.3-UNIT-002 (empty ID validation)

- **RISK-BANK-003**: Invalid properties in bank cause runtime errors
  - Mitigated by: 2.3-UNIT-003 (property validation delegation)

- **RISK-BANK-004**: Caller mutates PropertyBank source map after construction
  - Mitigated by: 2.3-UNIT-005 (constructor clones input map)

- **RISK-BANK-005**: Lookup mutations corrupt PropertyBank state
  - Mitigated by: 2.3-UNIT-009 (immutability test)

- **RISK-BANK-006**: JSON deserialization fails or loses data
  - Mitigated by: 2.3-UNIT-010 through 2.3-UNIT-012 (fixture tests)

---

## Test Execution Order

1. **P0 Constructor Tests** (fail fast on validation):
   - 2.3-UNIT-001: Valid PropertyBank
   - 2.3-UNIT-002: Empty ID validation
   - 2.3-UNIT-003: Property validation delegation
   - 2.3-UNIT-004: Multiple errors reported
   - 2.3-UNIT-005: Input map isolation

2. **P0 Lookup Tests** (core access pattern):
   - 2.3-UNIT-007: Lookup found
   - 2.3-UNIT-008: Lookup not found
   - 2.3-UNIT-009: Immutability

3. **P0 JSON Tests** (serialization integrity):
   - 2.3-UNIT-010 through 2.3-UNIT-012: Fixture deserialization

4. **P1 Edge Case Tests**:
   - 2.3-UNIT-006: Empty bank

---

## Quality Gates

**Required for story completion:**

- ✅ All 11 P0 unit tests pass
- ✅ All P1 unit tests pass (12 total)
- ✅ Test fixture `testdata/schemas/property_bank.json` created with 3 properties
- ✅ `golangci-lint run ./internal/domain` produces zero warnings
- ✅ Test coverage for `property_bank.go` ≥ 95%
- ✅ No race conditions detected by `go test -race`

**Metrics:**
- Expected test execution time: < 50ms (pure unit tests with file I/O)
- Expected coverage: 95-100% for PropertyBank model

---

## Edge Cases & Considerations

**Handled by tests:**
- Empty property ID (map key)
- Constructor clone protects against caller map mutations
- Empty PropertyBank (no properties defined)
- Property validation errors
- Multiple simultaneous validation errors
- Lookup immutability (returns copy)
- JSON deserialization from file

**Out of scope for this story:**
- $ref resolution logic - handled by SchemaResolver (Story 2.7)
- PropertyBank loading from file system - handled by SchemaLoader (Story 2.4)
- Circular reference detection - handled by SchemaResolver (Story 2.7)

---

## Test Fixture Specification

**File:** `testdata/schemas/property_bank.json`

**Contents:**
```json
{
  "properties": {
    "standard_title": {
      "name": "title",
      "required": true,
      "array": false,
      "spec": {
        "type": "string",
        "pattern": "^.{1,200}$"
      }
    },
    "standard_tags": {
      "name": "tags",
      "required": false,
      "array": true,
      "spec": {
        "type": "string"
      }
    },
    "iso_date": {
      "name": "date",
      "required": true,
      "array": false,
      "spec": {
        "type": "date",
        "format": "2006-01-02"
      }
    }
  }
}
```

**Purpose:**
- Realistic test data for JSON deserialization
- Covers string, array, and date property types
- Demonstrates required and optional properties
- Provides $ref resolution test cases for Story 2.7

---

## Dependencies

**Prerequisites:**
- Story 2.2: Property and PropertySpec models
- Go stdlib: `context`, `encoding/json`, `fmt`, `errors`, `os`
- Error types from Story 1.4: `ValidationError`

**Downstream consumers (future stories):**
- Story 2.4: SchemaLoader loads PropertyBank from file system
- Story 2.7: SchemaResolver uses PropertyBank for $ref resolution
- Epic 3: FrontmatterService indirectly uses resolved properties

---

## Test Maintenance Considerations

**Low maintenance risk:**
- Pure unit tests with simple fixture
- Singleton pattern is stable
- No complex state management

**Potential future changes:**
- Adding validation rules → Update constructor tests
- Changing $ref format → Update fixture and tests
- Adding metadata fields → Update deserialization tests

---

## Summary

This test design provides **comprehensive coverage** of PropertyBank singleton model through **12 focused unit tests**. The test strategy emphasizes:

1. **Constructor validation**: Catches invalid properties, IDs, and aggregated error paths surfaced from private helpers early
2. **Map isolation**: Confirms the constructor clones caller input to support singleton safety
3. **Immutability protection**: Ensures Lookup cannot mutate state
4. **JSON deserialization**: Verifies fixture loading works correctly while supporting downstream singleton loader work
5. **Foundation for $ref resolution**: Fixture-driven tests keep downstream schema resolution scenarios realistic

PropertyBank is a **critical singleton** for the entire schema system. The 11 P0 tests ensure data integrity and correct $ref resolution foundation.
