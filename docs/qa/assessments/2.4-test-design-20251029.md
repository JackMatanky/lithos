# Test Design: Story 2.4 - SchemaPort Interface & Loader Adapter

**Date:** 2025-10-29
**Designer:** Quinn (Test Architect)
**Story:** 2.4 - SchemaPort Interface & Loader Adapter
**Epic:** 2 - Configuration & Schema Loading

---

## Test Strategy Overview

- **Total test scenarios:** 12
- **Unit tests:** 12 (100%)
- **Integration tests:** 0 (0%)
- **E2E tests:** 0 (0%)
- **Priority distribution:** P0: 8, P1: 4

**Rationale:** SchemaPort and its filesystem loader adapter mediate every schema load at startup, so defects here cascade across the entire configuration pipeline. All behavior is exercisable through fast unit tests using fixture directories and stubbed config/loggers. Coverage focuses on load ordering, error surfacing with remediation guidance, duplicate detection, FR6 preservation of unknown JSON fields, and ensuring property bank is read exactly once per load.

---

## Test Scenarios by Acceptance Criteria

### AC 2.4.1-2.4.3: SchemaPort Interface Definition

**Requirement:** Define SchemaPort interface with Load signature, GoDoc references, and raw schema contract.

| ID           | Level | Priority | Test Description                                             | Justification                                      |
| ------------ | ----- | -------- | ------------------------------------------------------------ | -------------------------------------------------- |
| 2.4-UNIT-001 | Unit  | P1       | GoDoc example compiles and demonstrates raw Load contract    | Documentation example verifies interface semantics |

---

### AC 2.4.4-2.4.5: SchemaLoaderAdapter Construction

**Requirement:** Adapter instantiated with Config and Logger dependencies.

| ID           | Level | Priority | Test Description                                                  | Justification                                       |
| ------------ | ----- | -------- | ----------------------------------------------------------------- | --------------------------------------------------- |
| 2.4-UNIT-002 | Unit  | P1       | NewSchemaLoaderAdapter retains injected Config and Logger fields  | Guards constructor regression before functional tests|

---

### AC 2.4.6-2.4.7: Property Bank Loading Behavior

**Requirement:** Resolve property bank path, load once per call, preserve unknown fields, fail fast on issues.

| ID           | Level | Priority | Test Description                                                             | Justification                                                  |
| ------------ | ----- | -------- | ---------------------------------------------------------------------------- | -------------------------------------------------------------- |
| 2.4-UNIT-003 | Unit  | P0       | Load() succeeds with valid property bank fixture (before schemas)            | Happy path validates ordering and parsed structure             |
| 2.4-UNIT-004 | Unit  | P0       | Load() fails when property bank file missing with ResourceError + remediation| Critical startup failure path with actionable guidance         |
| 2.4-UNIT-005 | Unit  | P0       | Load() fails when property bank JSON malformed with SchemaError + remediation| Detects corrupted configuration                                |
| 2.4-UNIT-009 | Unit  | P0       | Property bank file read exactly once per Load() invocation                    | Enforces singleton semantics and avoids redundant IO          |
| 2.4-UNIT-013 | Unit  | P1       | Adapter uses Config.PropertyBankPath() value (not manual joins)              | Guards contract with configuration abstraction                 |

---

### AC 2.4.8-2.4.9: Schema Loading Semantics

**Requirement:** Load all schema JSON files (excluding property bank), preserve unknown fields, detect duplicates.

| ID           | Level | Priority | Test Description                                                             | Justification                                             |
| ------------ | ----- | -------- | ---------------------------------------------------------------------------- | --------------------------------------------------------- |
| 2.4-UNIT-006 | Unit  | P0       | Load() succeeds with multiple schema fixtures                                | Confirms main functionality                               |
| 2.4-UNIT-007 | Unit  | P0       | Duplicate schema names produce error listing all duplicates                  | Prevents ambiguous runtime behavior                       |
| 2.4-UNIT-008 | Unit  | P0       | Empty schemas directory returns empty slice without error                    | Expected edge case handling                               |
| 2.4-UNIT-014 | Unit  | P1       | Property bank JSON is ignored during schema scan                             | Ensures filter prevents duplicate property bank ingestion |

---

### AC 2.4.10-2.4.12: Error Handling & Logging

**Requirement:** Wrap errors with context, remediation hints, and emit debug logs.

| ID           | Level | Priority | Test Description                                                                | Justification                                    |
| ------------ | ----- | -------- | ------------------------------------------------------------------------------- | ------------------------------------------------ |
| 2.4-UNIT-012 | Unit  | P0       | Debug logger receives property bank + schema count messages in happy path       | Verifies observability per acceptance criteria   |
| *(Covered)*  | Unit  | P0       | 2.4-UNIT-004/005/006 reuse ensure remediation hints & typed errors              | Error wrapping validated in earlier scenarios    |

---

## Test Scenario Details

### Happy Path Loading (P0)

**2.4-UNIT-003 & 2.4-UNIT-006: Successful property bank + schema load**
```go
func TestSchemaLoaderAdapter_Load_Success(t *testing.T) {
    cfg := stubConfig{
        schemasDir:       testdataPath("schemas/success"),
        propertyBankPath: testdataPath("schemas/success/property_bank.json"),
    }
    log := newTestLogger()
    adapter := NewSchemaLoaderAdapter(cfg, log)

    schemas, bank, err := adapter.Load(context.Background())

    require.NoError(t, err)
    assert.NotNil(t, bank)
    assert.Contains(t, bank.Properties, "standard_title")
    assert.Len(t, schemas, 2) // base-note, meeting-note
    assert.ElementsMatch(t, []string{"base-note", "meeting-note"}, pluckNames(schemas))
    log.AssertHasDebug("loading property bank", "path", cfg.propertyBankPath)
    log.AssertHasDebug("schema loading complete", "count", 2)
}
```

### Missing Property Bank (P0)

**2.4-UNIT-004: ResourceError with remediation**
```go
func TestSchemaLoaderAdapter_Load_MissingPropertyBank(t *testing.T) {
    cfg := stubConfig{
        schemasDir:       testdataPath("schemas/empty"),
        propertyBankPath: testdataPath("schemas/empty/property_bank.json"),
    }
    adapter := NewSchemaLoaderAdapter(cfg, newTestLogger())

    schemas, bank, err := adapter.Load(context.Background())

    assert.Error(t, err)
    assert.Nil(t, schemas)
    assert.Equal(t, PropertyBank{}, bank)

    resErr := &ResourceError{}
    require.ErrorAs(t, err, &resErr)
    assert.Equal(t, cfg.propertyBankPath, resErr.Target)
    assert.Contains(t, resErr.Remediation, "Create schemas/property_bank.json")
}
```

### Malformed Schema JSON (P0)

**2.4-UNIT-006 & 2.4-UNIT-011: Schema error propagation and unknown field retention**
```go
func TestSchemaLoaderAdapter_Load_MalformedSchema(t *testing.T) {
    cfg := stubConfig{
        schemasDir:       testdataPath("schemas/malformed"),
        propertyBankPath: testdataPath("schemas/malformed/property_bank.json"),
    }
    adapter := NewSchemaLoaderAdapter(cfg, newTestLogger())

    schemas, bank, err := adapter.Load(context.Background())

    assert.Error(t, err)
    assert.Nil(t, schemas)
    assert.Equal(t, PropertyBank{}, bank)

    schemaErr := &SchemaError{}
    require.ErrorAs(t, err, &schemaErr)
    assert.Contains(t, schemaErr.Message, "malformed schema JSON")
    assert.Contains(t, schemaErr.Remediation, "Check JSON syntax")
    assert.Contains(t, schemaErr.SchemaName, "invalid.json")
}
```

### Duplicate Schema Names (P0)

**2.4-UNIT-007: Aggregated duplicate detection**
```go
func TestSchemaLoaderAdapter_Load_DuplicateNames(t *testing.T) {
    cfg := stubConfig{
        schemasDir:       testdataPath("schemas/duplicate"),
        propertyBankPath: testdataPath("schemas/duplicate/property_bank.json"),
    }
    adapter := NewSchemaLoaderAdapter(cfg, newTestLogger())

    _, _, err := adapter.Load(context.Background())

    require.Error(t, err)
    schemaErr := &SchemaError{}
    require.ErrorAs(t, err, &schemaErr)
    assert.Contains(t, schemaErr.Message, "Schema names must be unique")
    assert.Contains(t, schemaErr.Message, "meeting-note")
    assert.Contains(t, schemaErr.Message, "daily-note")
}
```

### Property Bank Read Once (P0)

**2.4-UNIT-009: Reader instrumentation**
```go
func TestSchemaLoaderAdapter_Load_PropertyBankReadOnce(t *testing.T) {
    var reads atomic.Int32
    fs := countingFS{ReadFileFunc: func(path string) ([]byte, error) {
        if strings.HasSuffix(path, "property_bank.json") {
            reads.Add(1)
        }
        return os.ReadFile(path)
    }}

    adapter := newSchemaLoaderWithFS(stubConfig{...}, newTestLogger(), fs)

    _, _, err := adapter.Load(context.Background())

    require.NoError(t, err)
    assert.Equal(t, int32(1), reads.Load())
}
```

---

## Risk Coverage

- **RISK-SCHEMA-001:** Startup fails silently due to missing property bank → Mitigated by 2.4-UNIT-004.
- **RISK-SCHEMA-002:** Corrupt JSON goes unnoticed until runtime → Mitigated by 2.4-UNIT-005 & 2.4-UNIT-006.
- **RISK-SCHEMA-003:** Duplicate schema names cause undefined behavior → Mitigated by 2.4-UNIT-007.
- **RISK-SCHEMA-004:** Property bank reloaded per schema causing inconsistent state → Mitigated by 2.4-UNIT-009.

- **RISK-SCHEMA-006:** Insufficient observability during load failures → Mitigated by 2.4-UNIT-012 and error remediation checks.
- **RISK-SCHEMA-007:** Adapter bypasses config abstractions leading to environment drift → Mitigated by 2.4-UNIT-013.

---

## Test Execution Order

1. **Constructor & interface smoke (P1):** 2.4-UNIT-001, 2.4-UNIT-002, 2.4-UNIT-013, 2.4-UNIT-014.
2. **Happy path (P0):** 2.4-UNIT-003, 2.4-UNIT-006, 2.4-UNIT-012.
3. **Property bank error paths (P0):** 2.4-UNIT-004, 2.4-UNIT-005, 2.4-UNIT-009.
4. **Schema error paths (P0):** 2.4-UNIT-006 (malformed), 2.4-UNIT-007 (duplicates), 2.4-UNIT-008 (empty dir).
5. **Regression sweeps (P1):** Re-run targeted tests with alternate fixtures (e.g., nested directories) as needed.

---

## Quality Gates

- ✅ All 10 P0 scenarios implemented and passing.
- ✅ All P1 scenarios implemented (documentation + constructor guards).
- ✅ Test fixtures under `testdata/schemas/` cover success, missing, malformed, duplicate, and empty-directory cases.
- ✅ `golangci-lint run ./internal/ports/spi ./internal/adapters/spi/schema` reports zero issues.
- ✅ `go test ./internal/ports/spi ./internal/adapters/spi/schema -race -v` passes.
- ✅ Logging assertions confirm debug breadcrumbs for property bank load and total schema count.

---

## Edge Cases & Considerations

- Nested directories: ensure `filepath.WalkDir` (or equivalent) respects nested schema folders without reloading property bank.
- Large schema sets: duplicate detection should handle >2 duplicates without truncating messages.
- Windows vs POSIX paths: tests should avoid hard-coded separators when composing fixture paths.
- Concurrent Load() calls are out of scope for this story (adapter expected to be single-call during startup).

---

## Test Fixture Specification

**Directory:** `testdata/schemas/`

```
success/
  property_bank.json
  base-note.json
  meeting-note.json
malformed/
  property_bank.json
  invalid.json
empty/
  property_bank.json (optional stub with minimal content)
duplicate/
  property_bank.json
  daily-note.json
  meeting-note.json
  nested/meeting-note.json (duplicate name)
unknown-fields/
  property_bank.json (includes extra keys)
  base-note.json (includes custom metadata)
```

Fixtures should reuse structures from Story 2.3 where possible to avoid drift, but include schema-specific metadata (e.g., `extends`, `excludes`, and arbitrary unknown properties) to assert FR6 behavior.

---

## Test Maintenance Considerations

- Centralize fixture creation helpers to reduce duplication across schema-related stories.
- Use helper constructors for `stubConfig` and `newTestLogger()` so future config additions require changes in one place.
- Favor golden JSON fixtures over inline strings to mirror real filesystem behavior and keep `encoding/json` pathways realistic.

---

## Summary

This test plan delivers comprehensive coverage for the SchemaPort loader boundary by:

1. Verifying constructor wiring and documentation.
2. Exercising the complete happy path with logging and ordering guarantees.
3. Failing fast on missing/malformed resources with remediation guidance.
4. Ensuring property bank reads occur exactly once per load and duplicates surface with actionable detail.

Together, these 12 targeted unit tests provide the confidence needed before SchemaResolver and SchemaValidator consume the loader outputs.
