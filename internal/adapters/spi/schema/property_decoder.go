package schema

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/JackMatanky/lithos/internal/domain"
)

// extractPropertyType extracts and validates the type field from property
// fields.
func extractPropertyType(fields map[string]json.RawMessage) (string, error) {
	typeRaw, hasType := fields["type"]
	if !hasType {
		return "", fmt.Errorf("type field is required for all properties")
	}
	var typeStr string
	if typeErr := json.Unmarshal(typeRaw, &typeStr); typeErr != nil {
		return "", typeErr
	}
	if typeStr == "" {
		return "", fmt.Errorf("type field is required for all properties")
	}
	return typeStr, nil
}

// extractPropertyFlags extracts required and array flags from property fields.
func extractPropertyFlags(
	fields map[string]json.RawMessage,
) (required, array bool, err error) {
	requiredRaw, hasRequired := fields["required"]
	if hasRequired {
		if reqErr := json.Unmarshal(requiredRaw, &required); reqErr != nil {
			return false, false, reqErr
		}
	}

	arrayRaw, hasArray := fields["array"]
	if hasArray {
		if arrErr := json.Unmarshal(arrayRaw, &array); arrErr != nil {
			return false, false, arrErr
		}
	}
	return required, array, nil
}

// extractPropertySpec extracts the spec fields by removing header and reserved
// fields.
func extractPropertySpec(
	fields map[string]json.RawMessage,
) (json.RawMessage, error) {
	// Remove header and reserved fields from spec
	delete(fields, "type")
	delete(fields, "required")
	delete(fields, "array")
	delete(fields, "name") // name comes from the map key
	delete(fields, "id")   // id is generated by domain

	return json.Marshal(fields)
}

// parsePropertyDef parses a full Property definition from JSON.
func decodePropertyDefinition(
	raw json.RawMessage,
) (typeName string, required, array bool, specRaw json.RawMessage, err error) {
	// Unmarshal once into a map to extract both header and spec fields
	var fields map[string]json.RawMessage
	if fieldsErr := json.Unmarshal(raw, &fields); fieldsErr != nil {
		return "", false, false, nil, fieldsErr
	}

	// Extract and validate type
	typeName, err = extractPropertyType(fields)
	if err != nil {
		return "", false, false, nil, err
	}

	// Extract flags
	required, array, err = extractPropertyFlags(fields)
	if err != nil {
		return "", false, false, nil, err
	}

	// Extract spec
	specRaw, err = extractPropertySpec(fields)
	if err != nil {
		return "", false, false, nil, err
	}

	return typeName, required, array, specRaw, nil
}

func parsePropertyDef(
	ctx context.Context,
	name string,
	raw json.RawMessage,
	path string,
	owner string,
) (domain.Property, error) {
	typeName, required, array, specRaw, decodeErr := decodePropertyDefinition(
		raw,
	)
	if decodeErr != nil {
		return domain.Property{}, propertyDefinitionError(
			fmt.Sprintf("failed to parse property %q", name),
			owner,
			path,
			decodeErr,
		)
	}

	parser, ok := propertySpecParsers[typeName]
	if !ok {
		return domain.Property{}, propertyDefinitionError(
			fmt.Sprintf("unsupported property type %q", typeName),
			owner,
			path,
			fmt.Errorf("no parser registered"),
		)
	}

	spec, err := parser(specRaw)
	if err != nil {
		return domain.Property{}, propertyDefinitionError(
			fmt.Sprintf("invalid spec for property %q", name),
			owner,
			path,
			err,
		)
	}

	// Use domain.NewPropertyWithContext to propagate caller's context
	propertyPtr, err := domain.NewPropertyWithContext(
		ctx,
		name,
		required,
		array,
		spec,
	)
	if err != nil {
		return domain.Property{}, propertyDefinitionError(
			fmt.Sprintf("invalid property definition for %q", name),
			owner,
			path,
			err,
		)
	}

	return *propertyPtr, nil
}
